<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>python爬虫之如何实现并发 | RhubarbC的博客</title><meta name="description" content="在学习爬虫过程中，我发现使用并发的方案是必不可少的！实现并发的方式有很多，如多线程、多进程还有异步IO等等。在实际运用中，我也只是会各种调包实现并发，但是内部怎么实现的却是一点都不知道。奈何我有一颗好奇的心，这篇文章就是来写一下我学习实现并发的几个方案和python中实现并发的常用模块以及分析它们底层是怎么实现的！"><meta name="keywords" content="多线程,多进程,异步IO,python爬虫性能"><meta name="author" content="Rhubarb C"><meta name="copyright" content="Rhubarb C"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="python爬虫之如何实现并发"><meta name="twitter:description" content="在学习爬虫过程中，我发现使用并发的方案是必不可少的！实现并发的方式有很多，如多线程、多进程还有异步IO等等。在实际运用中，我也只是会各种调包实现并发，但是内部怎么实现的却是一点都不知道。奈何我有一颗好奇的心，这篇文章就是来写一下我学习实现并发的几个方案和python中实现并发的常用模块以及分析它们底层是怎么实现的！"><meta name="twitter:image" content="http://yoursite.com/img/topimg.jpg"><meta property="og:type" content="article"><meta property="og:title" content="python爬虫之如何实现并发"><meta property="og:url" content="http://yoursite.com/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/"><meta property="og:site_name" content="RhubarbC的博客"><meta property="og:description" content="在学习爬虫过程中，我发现使用并发的方案是必不可少的！实现并发的方式有很多，如多线程、多进程还有异步IO等等。在实际运用中，我也只是会各种调包实现并发，但是内部怎么实现的却是一点都不知道。奈何我有一颗好奇的心，这篇文章就是来写一下我学习实现并发的几个方案和python中实现并发的常用模块以及分析它们底层是怎么实现的！"><meta property="og:image" content="http://yoursite.com/img/topimg.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Scrapy框架入门" href="http://yoursite.com/2019/10/30/Scrapy%E6%A1%86%E6%9E%B6/"><link rel="next" title="hexo上传图片小坑" href="http://yoursite.com/2019/10/24/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%8E%92%E5%9D%91/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://deehuang.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: Rhubarb C","link":"链接: http://yoursite.com/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/","source":"来源: RhubarbC的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">RhubarbC的博客</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#爬虫性能相关"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">爬虫性能相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#多线程实现并发请求"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">多线程实现并发请求</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#多进程实现并发请求"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">多进程实现并发请求</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#异步IO实现（伪）并发请求"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">异步IO实现（伪）并发请求</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#协程"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">协程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#异步IO"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">异步IO</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#异步IO模块的使用"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">异步IO模块的使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#asyncio-模块"><span class="toc_mobile_items-number">4.3.1.</span> <span class="toc_mobile_items-text">asyncio 模块</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#asyncio-aiohttp-模块"><span class="toc_mobile_items-number">4.3.1.1.</span> <span class="toc_mobile_items-text">asyncio+aiohttp 模块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#asyncio-requests-模块"><span class="toc_mobile_items-number">4.3.1.2.</span> <span class="toc_mobile_items-text">asyncio+requests 模块</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#gevent-模块"><span class="toc_mobile_items-number">4.3.2.</span> <span class="toc_mobile_items-text">gevent 模块</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#gevent-requests"><span class="toc_mobile_items-number">4.3.2.1.</span> <span class="toc_mobile_items-text">gevent+requests:</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#grequests-模块"><span class="toc_mobile_items-number">4.3.2.2.</span> <span class="toc_mobile_items-text">grequests 模块</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Twisted-模块"><span class="toc_mobile_items-number">4.3.3.</span> <span class="toc_mobile_items-text">Twisted 模块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Tornado-模块"><span class="toc_mobile_items-number">4.3.4.</span> <span class="toc_mobile_items-text">Tornado 模块</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#自定义异步IO模块"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">自定义异步IO模块</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#非阻塞socket"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">非阻塞socket</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#IO多路复用"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">IO多路复用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#自定义异步IO模块开发"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">自定义异步IO模块开发</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#爬虫性能相关"><span class="toc-number">1.</span> <span class="toc-text">爬虫性能相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多线程实现并发请求"><span class="toc-number">2.</span> <span class="toc-text">多线程实现并发请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多进程实现并发请求"><span class="toc-number">3.</span> <span class="toc-text">多进程实现并发请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步IO实现（伪）并发请求"><span class="toc-number">4.</span> <span class="toc-text">异步IO实现（伪）并发请求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#协程"><span class="toc-number">4.1.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步IO"><span class="toc-number">4.2.</span> <span class="toc-text">异步IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步IO模块的使用"><span class="toc-number">4.3.</span> <span class="toc-text">异步IO模块的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#asyncio-模块"><span class="toc-number">4.3.1.</span> <span class="toc-text">asyncio 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-aiohttp-模块"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">asyncio+aiohttp 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-requests-模块"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">asyncio+requests 模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gevent-模块"><span class="toc-number">4.3.2.</span> <span class="toc-text">gevent 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gevent-requests"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">gevent+requests:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grequests-模块"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">grequests 模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Twisted-模块"><span class="toc-number">4.3.3.</span> <span class="toc-text">Twisted 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tornado-模块"><span class="toc-number">4.3.4.</span> <span class="toc-text">Tornado 模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义异步IO模块"><span class="toc-number">5.</span> <span class="toc-text">自定义异步IO模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#非阻塞socket"><span class="toc-number">5.1.</span> <span class="toc-text">非阻塞socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO多路复用"><span class="toc-number">5.2.</span> <span class="toc-text">IO多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义异步IO模块开发"><span class="toc-number">5.3.</span> <span class="toc-text">自定义异步IO模块开发</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/topimg.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">python爬虫之如何实现并发</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-25<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-04</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/">python网络爬虫</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">10.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 34 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="爬虫性能相关"><a href="#爬虫性能相关" class="headerlink" title="爬虫性能相关"></a>爬虫性能相关</h1><p>爬虫是基于浏览器客户端实现的一种技术!</p>
<p>在使用爬虫的时候，不难发现我们使用requests模块帮助我们来发请求，如果服务端没有返回响应，那么我们的程序就会像二愣子一样傻不愣登的死等下去（单线程方案）。</p>
<p>上面的方法显然效率是特别低的。聪明的做法应该是“同时”去发多个请求，某一请求完成后“告诉一下我”，我再去拿数据搞事情。</p>
<p>我们所熟识的能够“同时”帮我们做操作，实现并发效果的方法有多线程和多进程还有异步IO。因为这些方法都是能大大提高我们爬虫性能滴！所以我们也需要学习掌握这些方法的使用和原理</p>
<p>下面我来分享下关于学习利用多线程、多进程和异步IO这三种常见的实现并发的方案是怎么去实现”并发“和”回调“一些学习心得！</p>
<p><a href="https://www.cnblogs.com/wupeiqi/articles/6229292.html" target="_blank" rel="noopener">参考文献</a></p>
<hr>
<h1 id="多线程实现并发请求"><a href="#多线程实现并发请求" class="headerlink" title="多线程实现并发请求"></a>多线程实现并发请求</h1><p>使用线程池开多线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    下载页面</span></span><br><span class="line"><span class="string">    为了方便区分我们这里把该函数叫做主体函数，主体函数执行完后会触发回调函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    print(url,response)</span><br><span class="line">    reuten response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">done</span><span class="params">(future,*args,**kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    回调函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(future,args,kwargs)  <span class="comment"># 回调函数不直接把response传入，而是封装成一个future对象</span></span><br><span class="line">    response = future.result()  <span class="comment"># 通过future对象的result方法可以取到我们的返回值</span></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">5</span>)</span><br><span class="line">url_list = [</span><br><span class="line">    <span class="string">'http://www.baidu,com'</span>,</span><br><span class="line">    <span class="string">'http://www.pianshen.com/article/292812067/'</span>,</span><br><span class="line">    <span class="string">'http://deehuang.github.io'</span>,</span><br><span class="line">    <span class="string">'http://www.zhihu.com'</span>,</span><br><span class="line">    <span class="string">'http://www.sina.com'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    v = pool.submit(task,url)  <span class="comment"># 使用线程池中的线程去执行task函数，把url作为实参传入</span></span><br><span class="line">    v.add_done_callback(done)  <span class="comment"># 添加回调函数，这里表示task执行完后执行done方法</span></span><br><span class="line">pool.shutdown(wait=<span class="literal">True</span>)  <span class="comment"># 关闭线程池，Wait是等待所有调度的线程执行完后再关闭</span></span><br></pre></td></tr></table></figure>

<p>如果我们希望线程执行完<code>task</code>函数后再执行一个回调函数，我们可以使用一个变量去接收<code>pool.sumit(task,url)</code>的返回值，然后给这个返回值可以添加一个回调函数<code>add_done_callback(done)</code><br>上面的例子中，我们执行完<code>task</code>后传入回调函数中的参数是一个<code>future</code>对象（这是<code>add_done_callback（）</code>帮我封装的，它除了封装了返回值还有别的东西），而不直接是<code>task</code>返回的<code>response</code>对象。通过<code>future.result()</code>就可以拿到我们的<code>requests</code>请求返回的<code>response</code>对象！<br>PS：实际运用中，我们也可以不使用回调函数，可以直接把所有的逻辑代码写到主体函数中，使用和不使用回调都是多线程方式，这两种多线程方式只不过编写方式不一样而已（使用回调函数代码耦合会低一些）。</p>
<p>这就是我们使用线程池实现多线程实现并发的发起请求操作的方法（有些小伙伴可能会”有开多线程难道非要用线程池?”的疑问。使用线程池是为了方便对线程的管理， 线程的创建和销毁的开销是巨大的，而通过线程池的重用大大减少了这些不必要的开销，当然既然少了这么多消费内存的开销，其线程执行速度也是突飞猛进的提升。 ）</p>
<h1 id="多进程实现并发请求"><a href="#多进程实现并发请求" class="headerlink" title="多进程实现并发请求"></a>多进程实现并发请求</h1><p>多进程实现并发方案跟多线程的实现的方案几乎是一模一样的。<br>只不过我们引入的是线程池了</p>
<p><code>from concurrent.futures import ProcessPoolExecutor</code><br><code>pool = processPoolExecutor(8)</code><br><code>v = pool.submit(task,url)  # 使用进程池中的线程去执行task函数，把url作为实参传入</code><br><code>v.add_done_callback(done)  # 添加回调函数，这里表示task执行完后执行done方法</code></p>
<hr>
<p>总结一下多线程和多进程实现并发的方案：</p>
<p>1.优点：可以实现并发</p>
<p>2.缺点：如果请求发出去后和等待返回响应的这段时间里（IO阻塞），这些被调度的线程（进程）就处于没事做的空闲状态。我觉得挺浪费的（因为开启线程就占用了资源），既然占用资源我就想让线程（进程）不断地帮我做事情，如果在阻塞的事件中可以让这些线程（进程）去做别的事情，那真是美滋滋（这大概是所有老板的心声吧~）</p>
<p>3.编写方式：</p>
<ul>
<li>直接返回处理</li>
<li>通过回调函数处理</li>
</ul>
<p>4.两种方案的对比（从对比线程和进程的区别去探讨这个问题）：</p>
<ul>
<li>线程是cpu工作的最小单元，线程存在进程里边，”它是真实地工作者“</li>
<li>每开一个进程，该进程中的所有线程共享这个资源集里的资源  <em>头脑风暴</em>：进程就像是一个房子。这个房子里面人就是线程，该房子（线程）里的所有人共享这个房子的所有资源。通过这个例子不难想象，开进程是十分耗费资源的，相当于重搭一个房子。而使用多线程的方式就相当于在屋子里多放几个人而不用专门为每个人重搭一个房子</li>
<li>什么时候用多进程?什么时候用多进程？<br>  因为python的GIL锁的原因（<strong>同一时刻只允许一个进程中的一个线程被cpu调度</strong>），所以对于<strong>计算密集型</strong>的程序我们使用多进程的方案会好一些；对于<strong>io密集型</strong>的程序用多线程会更好（遇到io操作的时候不用跟cpu交互，因为遇到Io操作cpu就会切到别的线程去执行，所以就好像不受GIL的限制）</li>
</ul>
<hr>
<h1 id="异步IO实现（伪）并发请求"><a href="#异步IO实现（伪）并发请求" class="headerlink" title="异步IO实现（伪）并发请求"></a>异步IO实现（伪）并发请求</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>学习异步IO模型，我们首先要理解<strong>协程</strong>的概念:</p>
<p>协程简单的理解为规定了让一个<strong>线程</strong>先执行一下一个<strong>函数1</strong>，执行到一半，再切换到另外一个<strong>函数2</strong>执行，然后又回去执行<strong>函数1</strong>（是从上次执行的状态继续往下执行）……。这样的过程就像是线程分片了（然线程先执行这个又执行下那个），所以它也被叫做微线程</p>
<p>实现上面过程的方式就是用我们的生成器函数，在函数中使用yield返回函数值，就是一个生成器函数。当函数遇到yield就会跳出函数并返回yield所带的值，再次执行该函数的时候会从上一次yield的地方继续往下执行（实现了保存上下文状态）。</p>
<p>协程的特点在于是一个线程执行。<br>协程的最大优势是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程的数量越多，协程的性能优势越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多 </p>
<p>更多的关于协程的学习可以参考<a href="https://www.cnblogs.com/sunzhiqi/p/10064835.html" target="_blank" rel="noopener">这里</a></p>
<p>总结：协程本质是一种上下文切换技术，通过生成器yield记录状态的特性来实现</p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><strong>协程</strong>仅仅提供的功能只是切换，它只能单纯的执行下这个函数又去执行下别的函数……这样的过程。利用协程可以并发的发送多个请求（实际上不是并发只不过速度非常快看似并发）。即是用<u>一个线程</u>就能把所有的请求（放到不同的生成器函数中）并发的发送过去。<u>但是单纯的它并不能帮我们完成任何的操作!</u></p>
<p>异步IO的理解：如果一个IO被阻塞，系统会切换到其他的进程/线程/协程以便充分利用CPU。<u>并且，在IO的数据返回后，能实时监测并实现自动<strong>回调</strong>这就是<strong>异步IO</strong></u>（异步强调的是回调功能）。如果不切换，一直等待这个IO完成，就是同步IO </p>
<p>协程和异步IO的关系：异步IO的实现可以用多进程也可以用多线程，但是它们都存在一个限制，就是线程或进程的数量在一个操作系统中是有限的，同时它们切换也要消耗一定的资源。要知道很多时候我们要并发的代码块并不大，比如说只是<em>get</em>一个网页，因此，人们会把这个代码块进一步的从线程中脱离出来，就是利用我们的协程，它是微线程，能帮助我们实现像线程<strong>切换</strong>的效果（协程本质是一种上下文切换技术，通过生成器yield记录状态的特性来实现）。但是异步IO并不是说实现<strong>切换</strong>功能就行了，它最主要的功能是<strong>回调</strong>！怎么实现自动回调呢？我们后面再说（可以提前引入一下，利用”io多路复用“）</p>
<p>利用协程+异步IO就可以完成并发的发送请求并且一旦某一个请求的结果返回时，<strong>回调</strong>继续执行该请求函数下面的任务。因为是一个线程处理多个http请求，所以当同一时刻有多个http请求返回的时候也只能处理一个请求，所以我们称异步IO方案实现的<strong>伪</strong>并发请求</p>
<p>可能有的人还是有点不太理解上面是什么意思？不是协程自己就已经实现了并发的去发送请求吗?<br>我们所说的并发HTTP请求实际上是包括了两个部分的：发送请求+处理响应内容。不是说你只是发个请求后面的事情就不管了。我们请求的目的不是就是为了拿数据搞事情吗?多线程和多进程每个进程遇到io操作是同步操作，所以不用考虑回调的问题。（就是说线程/进程一直等到数据返回了才会往下执行，这期间该线程/进程会被一直挂起）。</p>
<p>协程完成的只是切换功能,但是什么时候切换呀！它不知道HTTP请求啥时候会返回！所以我们需要利用异步IO的功能（监听请求并回调）。</p>
<p>总结：</p>
<p>异步IO不仅需要能在遇到IO阻塞的操作时候能实现切换，还需要监听请求状态并<strong>自动回调!</strong> <strong>自动回调!</strong> <strong>自动回调!</strong>(重要的事情说三遍)。可以简单的傻瓜式理解为，<strong>协程就是切换，异步就是回调。</strong><br>所以协程+异步IO ==》 一个线程发送N个Http请求 </p>
<p>这里需要注意一下的是：<br><u>异步IO的并非必须跟协程搭配</u>。切换功能的实现可以使用多线程/进程（或者是后面会说到的无阻塞socket）。使用协程带给我们的好处是开销小并且能在碰到IO操作的进行切换（实现非阻塞）。还有！在使用异步io的监测到请求有响应时候能提供<strong>切回去</strong>，继续<strong>往下执行</strong>的效果。即给我们的<strong>回调</strong>实现了便捷！</p>
<p>因为下面会讲到无阻塞socket+io多路复用(提前引入，异步IO的监测功能就它提供)。我一开始就总是疑惑协程不是跟异步IO有关系吗。在这里面用在了哪里？其实这个方案里并没有引用协程。。如果还想深究，看完全部文章后，可以去看一下<a href="https://blog.csdn.net/weixin_41207499/article/details/80657201" target="_blank" rel="noopener">这篇文章</a></p>
<p>这里介绍协程最主要是因为紧接着要介绍的异步IO模块有些是通过协程去实现的！</p>
<h2 id="异步IO模块的使用"><a href="#异步IO模块的使用" class="headerlink" title="异步IO模块的使用"></a>异步IO模块的使用</h2><p>Python作为一个”面向调包”的语言（调侃一下），这种单线程+异步IO来实现处理N多个请求的模块当然是必须存在的，我们慢慢的引入这些模块。</p>
<h3 id="asyncio-模块"><a href="#asyncio-模块" class="headerlink" title="asyncio 模块"></a>asyncio 模块</h3><p>python3的内置模块<code>asyncio</code>可以帮助我们完成上面的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">asyncio模块的固定用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'执行func1之前'</span>)</span><br><span class="line">	<span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">5</span>)   <span class="comment">#必须写的是yield form---&gt;固定写法</span></span><br><span class="line">	print(<span class="string">'执行func1结束'</span>)</span><br><span class="line">	</span><br><span class="line">tasks = [func1(),func1()]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>是不是把上述的代码改成<code>发送http请求,获取结果</code>不就实现了并发的发送处理http请求了呢？</p>
<p>很遗憾的是asynico模块不支持HTTP请求，支持TCP请求。我们知道HTTP是基于TCP做的，所以我们可以根据这个协议来对这个模块做一个改造</p>
<p>回顾一下HTTP和TCP请求：</p>
<p>  TCP：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client = socket()</span><br><span class="line">client.connect()</span><br><span class="line">client.send(b&apos;asdasdasdas&apos;)</span><br></pre></td></tr></table></figure>

<p>  HTTP:<br>  HTTP实际上内部也是用的TCP请求的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client = socket()</span><br><span class="line">client.connect()</span><br><span class="line">client.send(data)</span><br></pre></td></tr></table></figure>

<p>  只不过它在<code>send（）</code>中<code>data</code>内容是不一样的，就是说HTTP只是规定了一个<strong>数据格式</strong><br>  它的格式是这样的：<br><code>data = &quot;&quot;&quot;GET %S HTTP/1.0\r\nHost:%s\r\n\r\n&quot;&quot;&quot;%(url,host)</code><br>  其实就是我们所说的Http请求三部分：请求首行、请求头、请求体</p>
<p>PS:请求首行和请求头之间一个换行，请求头和请求头直接一个换行，请求头和请求体之间两个换行<br><img alt data-src="/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/1.jpg" class="lozad"></p>
<p>这样我们就可以通过自己构造http数据格式来通过asyncio模块去发HTTP请求了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">asyncio模块实现发送Http请求  ---&gt;固定用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(host,url=<span class="string">'/'</span>)</span>:</span></span><br><span class="line">	reader,writer = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.open_connection(host,<span class="number">80</span>)<span class="comment"># 创建连接，本质上就是通过socket创建一个连接</span></span><br><span class="line">    </span><br><span class="line">    request_headet_content = <span class="string">"""GET %S HTTP/1.0\r\nHost:%s\r\n\r\n"""</span>%(url,host)<span class="comment">#我们构造的http请求的格式</span></span><br><span class="line">    request_headet_content = bytes(request_header_content,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    </span><br><span class="line">    writer.write(request_header_content)  <span class="comment"># TCP的sent</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> writer.drain()</span><br><span class="line">    text = <span class="keyword">yield</span> <span class="keyword">from</span> reader.read()  <span class="comment"># Tcp的recv</span></span><br><span class="line">    print(host,utl,text)</span><br><span class="line">    writer.close()  <span class="comment"># 关闭socket</span></span><br><span class="line">	</span><br><span class="line">tasks = [task(<span class="string">'deehuang.github.io'</span>,<span class="string">'/link/'</span>), <span class="comment"># (host,url)</span></span><br><span class="line">         task(<span class="string">'deehuang.github.io'</span>,<span class="string">'/tags/'</span>)]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<h4 id="asyncio-aiohttp-模块"><a href="#asyncio-aiohttp-模块" class="headerlink" title="asyncio+aiohttp 模块"></a>asyncio+aiohttp 模块</h4><p><code>asyncio</code>模块可以实现异步IO的功能，但是对HTTP的不友好显然给我们带来了许多麻烦。我们每次都要自己去封装HTTP数据包，但是python作为”面向调包“的语言，它当然也有帮我们封装HTTP数据包的模块，就是我们的<code>aiohttp</code>模块（这不是一个内置模块，需要先安装pip install aiohttp再使用）</p>
<p><code>asynico+aiohttp</code>两者结合就方便地实现了使用异步IO发送HTTP请求了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">asyncio+aiohttp模块的搭配固定用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(url)</span>:</span></span><br><span class="line">	print(url)</span><br><span class="line">    response = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.reques(<span class="string">'GET'</span>,url) <span class="comment">#这一句代码就把上面我们自己封装Http数据包和创建socket连接,返回值就相当于是我们的socket链接对象</span></span><br><span class="line">    data = <span class="keyword">yield</span> form response.read()</span><br><span class="line">    print(url,response)</span><br><span class="line">    response.close()</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">tasks = [task(<span class="string">'http://deehuang.github.io/'</span>), <span class="comment"># (url)</span></span><br><span class="line">         task(<span class="string">'http://www.baidu.com/'</span>)]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>小总结：<br><em>asynico</em>里面帮助我们完成的是异步的功能<br><em>aiohttp</em>帮助我们完成的是封装Http数据包的功能和创建socket链接的功能<br>这两个组件是配合使用的，<em>aiohttp</em>也是基于<em>asynico</em>去开发的</p>
<h4 id="asyncio-requests-模块"><a href="#asyncio-requests-模块" class="headerlink" title="asyncio+requests 模块"></a>asyncio+requests 模块</h4><p><em>asynico</em>除了可以搭配<em>aiohttp</em>模块使用，还能和requests模块搭配使用！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">asyncio+requests模块的搭配固定用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(func,*args)</span>:</span></span><br><span class="line">    print(func,args)</span><br><span class="line">	loop = asyncio.get_event_loop()</span><br><span class="line">    future = loop.run_in_executor(<span class="literal">None</span>,func,*args) <span class="comment"># 把args当作参数传入func中</span></span><br><span class="line">    response = <span class="keyword">yield</span> <span class="keyword">from</span> future</span><br><span class="line">    print(response.url,response.content)</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">tasks = [task(requests.get,<span class="string">'http://deehuang.github.io/'</span>), <span class="comment"># (func,url)</span></span><br><span class="line">         task(requests.get,<span class="string">'http://www.baidu.com/'</span>)]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>requests模块实际上在这里也是帮助我们封装Http数据包并且建立socket连接，然后通过socket发过去</p>
<h3 id="gevent-模块"><a href="#gevent-模块" class="headerlink" title="gevent 模块"></a>gevent 模块</h3><p>如今主流的一个帮助我们做网络请求提高并发的模块，它内部原理跟asyncio原理本质上是一样的！</p>
<p><strong>gevent</strong>内部依赖于<strong>greenlet</strong>模块，<em>greenlet</em>是一个协程的模块（复习一下协程，是一个微线程，是我们自己指定一个线程先执行什么再执行什么再执行什么……这样的一个过程）。<em>greenlet</em>只是做协程，处理网络请求我们没办法指定先执行什么然后执行什么，它是根据请求的响应来决定什么时候执行的。所以说<em>gevent</em>依赖于<em>greenlet</em>实现切换功能，而<em>gevent</em>内部也实现了异步IO的功能。两者结合起来去完成并发。</p>
<p><em>gevent</em>,<em>greenlet</em>都不是内置模块，所以需要去安装它们<br><code>pip install greenlet</code><br><code>pip install gevent</code></p>
<p><em>gevent</em>和<em>asyncio</em>一样，内部只是支持socket级别的操作，即只支持TCP，不支持HTTP。所以我们还是需要搭配其他的http封包模块去帮助我们发Http请求</p>
<h4 id="gevent-requests"><a href="#gevent-requests" class="headerlink" title="gevent+requests:"></a><em>gevent</em>+requests:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">gevent+requests实现并发  ----&gt;标准用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()  <span class="comment">#这句不要忘记了，它内部会找到我们原来的所有的socket（原来socket中的io操作如sent,recv，connect等等都是同步操作），都变成gevent帮我们封装成异步IO的socket </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(method,url,req_kwargs)</span>:</span></span><br><span class="line">    print(method,url,req_kwargs)</span><br><span class="line">    response = requests.request(method=method,url=url,**req_kwargs)</span><br><span class="line">    print(response.url,response.content)</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 发送请求 ####</span></span><br><span class="line">gevent.joinall([</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>如果我们需要同时并发的任务有特别多，例如有一百个请求需要发出去。我们一个线程处理的完吗？肯定效率是非常低的。所以gevent非常友好的给我们提供了协程池，来控制我们最多向远程发起请求的数量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### 发送请求（协程池控制最大携程数量） ####</span></span><br><span class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</span><br><span class="line">pool = Pool(<span class="number">5</span>) <span class="comment"># 最多调用五个协程切换任务</span></span><br><span class="line">gevent.joinall([</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h4 id="grequests-模块"><a href="#grequests-模块" class="headerlink" title="grequests 模块"></a>grequests 模块</h4><p>再次感慨“面向调包”语言的强大，有人已经把上面的gevent和requests封装成一个模块供我们快速调用了。（其实我觉得是有点low的，因为上面也没几句代码……:sweat:)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> grequests</span><br><span class="line"></span><br><span class="line">request_list = &#123;</span><br><span class="line">	grequests.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">	grequests.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">	grequests.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 执行并获取响应列表 ####</span></span><br><span class="line">response_list = grequests.map(request_list,size=<span class="number">5</span>) <span class="comment">#size表示的协程池内协程数量</span></span><br><span class="line">print(response_list)</span><br></pre></td></tr></table></figure>

<h3 id="Twisted-模块"><a href="#Twisted-模块" class="headerlink" title="Twisted 模块"></a>Twisted 模块</h3><p>不是python的内置模块，所以需要安装 <code>pip install twisted</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.web.client <span class="keyword">import</span> getPage,defer</span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_done</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="string">"""每下载完一个页面就执行这个函数"""</span></span><br><span class="line">    print(arg)</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_done</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="string">"""所有页面下载完后执行这个函数"""</span></span><br><span class="line">    print(<span class="string">'done'</span>)</span><br><span class="line">    reactor.stop() <span class="comment"># 全部请求处理完后，终止循环</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">@defer.inlineCallbacks    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(url)</span>:</span></span><br><span class="line">    res = getPage(bytes(url,encoding=<span class="string">'utf-8'</span>))  <span class="comment"># 发送http请求</span></span><br><span class="line">    res.addCallback(one_done)  <span class="comment"># 添加回调函数，每下载完成一个页面后执行onde_done回调函数</span></span><br><span class="line">    <span class="keyword">yield</span> res</span><br><span class="line"></span><br><span class="line">url_list = [<span class="string">'http://deehuang.github.io/'</span>,</span><br><span class="line">            <span class="string">'http://www.baidu.com/'</span>]</span><br><span class="line"></span><br><span class="line">defer_list = []  <span class="comment"># 放的是已经向url发送请求的对象</span></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    v = task(url) <span class="comment"># 执行task函数，因为有defer_inlineCallbacks装饰器，当我们执行到getPage()后会立即返回!即把请求发过去不等请求回来,实现并发发请求。返回已经向url发送请求的对象</span></span><br><span class="line">    defer_list.append(v)   </span><br><span class="line">d = defer.DeferredList(defer_list)  <span class="comment"># 把已经向url发送请求的对象列表放到该特殊对象中</span></span><br><span class="line">d.addBoth(all_done)</span><br><span class="line"></span><br><span class="line">reactor.run() <span class="comment"># 这是一个死循环，它会“一直”去DeferredList中监听所有的请求状态，如某一请求返回后接着从原来返回的函数往下执行（该实例中每个请求返回后去执行one_done）。所有请求处理完后触发d.addBoth中添加的回调函数，即all_done，实现异步操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求全部处理完后，reacotor.run还是会傻傻的一直循环，要终止循环我们需要在all_done中去终止循环，</span></span><br></pre></td></tr></table></figure>

<p>上面例子中的<code>reactor.run()</code>死循环，我们有一个专业的名词叫做<strong>“事件循环”</strong><br>这个事件循环的作用就是帮助我们监测咱们发出去的<u>请求</u>，看它是否又没返回。<br>所以我们在使用所有的异步IO框架的时候要有一个概念：通过事件循环去监听每个请求的返回状态，当每个请求返回后通过回调执行相应的方法。所有的请求都返回处理完后，需要把整个事件循环终止掉！</p>
<p>PS: scrapy异步IO请求的实现是基于Twisted来完成的</p>
<h3 id="Tornado-模块"><a href="#Tornado-模块" class="headerlink" title="Tornado 模块"></a>Tornado 模块</h3><p>Tornado框架的异步功能用来做异步IO请求模块也是相当不错的，它的用法和Twisted十分相似。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> HTTPRequest</span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">0</span> <span class="comment"># 计数器，用于中止IO循环</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_response</span><span class="params">(response)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理返回值内容（需要维护计数器，来停止IO循环），调用 ioloop.IOLoop.current().stop()</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">global</span> COUNT</span><br><span class="line">    COUNT -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> response.error:</span><br><span class="line">        print(<span class="string">"Error:"</span>, response.error)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(response.body)</span><br><span class="line">	<span class="keyword">if</span> COUNT = <span class="number">0</span>: <span class="comment"># 终止事件循环</span></span><br><span class="line">        ioloop.IOLoop.current().stop()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">'http://www.baidu.com'</span>,</span><br><span class="line">        <span class="string">'http://cn.bing.com'</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">global</span> COUNT</span><br><span class="line">    COUNT = len(url_list)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">        print(url)</span><br><span class="line">        http_client = AsyncHTTPClient() </span><br><span class="line">        http_client.fetch(HTTPRequest(url), handle_response) <span class="comment"># handle_response是回调函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ioloop.IOLoop.current().add_callback(func)</span><br><span class="line">ioloop.IOLoop.current().start()  <span class="comment"># 死循环  ---&gt; 事件循环</span></span><br></pre></td></tr></table></figure>

<p><em>Tornado</em>不像<em>Twisted</em>一样内部自动的维护一个计算器。每次计算我们要发送请求的数量（<code>url_list中的数量</code>），请求返回执行回调函数后该计数器自动减1。当计数器为0时应该终止事件循环函数<code>ioloop.IOLoop.current().stop()</code>。这个计数器在<em>Tornado</em>中需要我们手动的去设计<br>  而<em>Twisted</em>已经内部帮我们把计数器封装好了，当计数器值为0时在内部触发add.Both()添加的回调函数。</p>
<hr>
<p>对于上面的异步IO请求模块使用的优先级，我个人认为是这样的：<br>gevent &gt; Twisted &gt; Tornado &gt; asyncio  (这个比较标准纯粹是怎么方便怎么用…..)</p>
<hr>
<h1 id="自定义异步IO模块"><a href="#自定义异步IO模块" class="headerlink" title="自定义异步IO模块"></a>自定义异步IO模块</h1><p>这些内置或第三方的异步IO请求模块，在日常生活中我们作为一个”<u>使用者</u>“掌握怎么去使用就足够了。对于内部很多细节的实现我们基本不用去深究。但是，作为一个充满好奇心的小白当然是不满足的！下面将摸索一下异步IO请求的底层原理及实现，以一个（小白）“<u>开发者</u>”的角度自己去写一个异步IO模块！</p>
<p>我们是否有这样的疑问：我们知道协程提供切换功能实现非阻塞，异步IO使请求得到响应后实现自动回调功能。两者加起来就可以用一个线程发送处理多个http请求。那么异步IO是怎么做到监测到请求的响应的呢？？？（提前引入一下是通过“io多路复用”来实现的）<br>所以要自定义异步IO模块，我们首先要理解一些前戏：</p>
<h2 id="非阻塞socket"><a href="#非阻塞socket" class="headerlink" title="非阻塞socket"></a>非阻塞socket</h2><p>我们先来由浅入深的来看看一个Http请求的本质。我们知道HTTP是建立在TCP之上的协议，所以我们先来从讨论下socket。<br>socket有客户端和服务端。所有的web网站都是服务端，而我们的浏览器属于客户端。 </p>
<p>如图我们写了一个URL，回键一敲！ </p>
<p><img alt data-src="/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/2.jpg" class="lozad"><br>这就往这个URL地址发送了一个请求，它本质上就是把一些规定好格式的字符串通过<code>socket.sent(&quot;我是http数据包&quot;)</code>发到服务端去了。</p>
<p>上面的过程中，浏览器帮我做了两件事：1.创建socket对c象与服务器连接。2.往url地址发送请求。<br>其实这里边有两个io操作，首先是建立“<u>连接</u>”，然后是“<u>发送</u>”数据。这两个过程都是比较耗时的。默认情况下“连接”和“发送”或者“接收数据”的时候是会<u>阻塞</u>住的，如果我们想让它不<u>阻塞</u>，我们可以在创建socket的时候设置<code>setblocking(Fasle)</code>，要注意的一点是，不阻塞的情况下，程序无数据（连接无响应，数据未返回）就会报错（可以用异常处理来解决）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line"><span class="comment"># 设置非阻塞</span></span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 此时所有的socket操作都不会阻塞</span></span><br><span class="line"><span class="comment"># 设置了非阻塞后，客户端发送连接请求不会等待服务端响应就直接往下走</span></span><br></pre></td></tr></table></figure>

<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>上述在使用无阻塞socket时，我们说可以使用异常处理去处理无数据（连接无响应，数据未返回）的地方。异常处理的作用只能忽略、也可以说是跳过了它们。可是我们是希望在遇到IO阻塞的地方能不阻塞去执行别的任务，等阻塞的地方<strong>返回响应时</strong>，我们能<strong>马上发现</strong>并再去做<strong>相应的处理</strong>。</p>
<p>那么怎么使得阻塞的地方返回响应时我们能马上做相应处理呢？我们可以整一个死循环，去不断地监测多个socket对象。当某一socket对象有变化时（建立连接成功或接收到数据）,我们立即把这个socket对象拿出来做相应的处理。<br>上面这一想法有一个专业的术语，叫做<strong>Io多路复用</strong>，它的意思是“<strong>单个线程</strong>，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流” 。<br>不明白？从字面上理解就是多路网络复用一个io线程<br>不明白？我所理解的大白话就是用一个线程去监听多个socket对象的状态改变！<br>还不明白？看下图：</p>
<p><img alt data-src="/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/3.jpg" class="lozad"></p>
<p>图中可以明白：在同一个线程里面， 通过拨开关的方式，来同时传输多个I/O流 。现在市面上使用的io多路复用模块有<em>select</em>,<em>poll</em>和<em>epoll</em>。它们三个都是IO多路复用的具体的实现。<br>头脑风暴：你有N个不知道什么时候来水的水龙头需要接水，你根据某种信号一会儿拧这个龙头，一会儿拧那个龙头把水都接了就是多路复用（一个线程）。使用残像拳在每个水龙头前派一个你的分身蹲守就是Threaded IO（多线程）。其实后者也没啥不好，因为未来的内核会消除上下文切换的软硬件性能损耗<br>更多内容理解内容可以参考<a href="https://www.zhihu.com/question/32163005" target="_blank" rel="noopener">这里</a></p>
<p>这里我们只从客户端的角度去实现无阻塞socket+io多路复用的使用（这里使用的是python中io多路复用模块select模块的）。再次重复一下：使用IO多路复用模块的作用是帮助我们循环去监听哪个sock发送了变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">伪代码，主要是帮助理解</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">server = socket.socket()</span><br><span class="line"><span class="comment"># 设置非阻塞</span></span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    socket对象<span class="number">1.</span>connet()</span><br><span class="line">    socket对象<span class="number">2.</span>connet()</span><br><span class="line">    socket对象<span class="number">3.</span>connet()  <span class="comment"># 无阻塞，程序直接往下走，无数据报错</span></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">	<span class="keyword">pass</span>   <span class="comment"># 捕捉无数据异常</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    r,w,e = select.select([socket对象<span class="number">1</span>，socket对象<span class="number">2</span>，socket对象<span class="number">3</span>],<span class="comment">#监测是否有数据传来</span></span><br><span class="line">                          [socket对象<span class="number">1</span>，socket对象<span class="number">2</span>，socket对象<span class="number">3</span>],<span class="comment">#监测是否完成连接</span></span><br><span class="line">                          [],<span class="comment">#监测是否发生异常的socket</span></span><br><span class="line">                          <span class="number">0.05</span>) <span class="comment">#最多等待的超时时间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># r 表示有人给我发数据，即当有数据发送过来后，就会把该socket对象放到r中：此时可以通过socket对象.recv去接收数据了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># w 表示我已经和别人创建连接成功，即当连接创建完成后（三次握手），就会把该socket对象放在w中：此时可以通过socket对象.sent('我是Http数据包')发送http请求了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#e 表示socket内部发生异常就会把该socket对象放在e中</span></span><br></pre></td></tr></table></figure>

<p> <em>select</em>模块以列表形式接受四个参数，分别是需要监听的可读文件对象，可写文件对象，产生异常的文件对象和超时设置，当某个文件描述符状态改变后，会返回三个列表。 （这里我们的文件描述符只针对<em>socket</em>）</p>
<p><em>select</em>会一直轮询，挨个问一遍<em>socket</em>对象，你有没有变化啊？有变化就把该socket添加到相应的存储空间（如上面的r、w和e）。<br>当问完后，此时如果我有设定第四个参数超时时间 <code>timeout ＝ n</code>时，那么如果监听的<em>socket</em>均无任何变化，则select会阻塞n秒，之后返回三个空列表，如果监听的句柄有变化，则直接执行；<br>当超时时间为空，则select会一直阻塞，直到监听的socket有发生变化</p>
<p>也就是说我们select无论是否设置了参数timeout，只要socket有变化，就会返回变化的socket列表，然后程序继续往下执行（而不是说一直阻塞住直到监听到所有的监听对象都有变化才返回）。<br>我们对这些返回的<em>socket</em>执行完相应任务，<em>select</em>结束了（即一有<em>socket</em>状态改变，它就不阻塞了，会往下执行程序）！ 如果我们想让它一直监听轮询直到处理完全部的<em>socket</em>的话就需要把它放到死循环中去！这个循环就叫做事件循环(用于检测请求的socket是否已经就绪，从而执行相关操作)。<br>更多select模块的讲解可以看<a href="http://www.manongjc.com/detail/6-afuhpfbowfjvqbs.html" target="_blank" rel="noopener">这里</a></p>
<p>拓展：<code>r,w,e = select.select([],[],[],0.05)</code>里面的[]参数中，不仅可以放<em>socket</em>对象，只要一个对象提供<code>fileno</code>方法，并返回一个文件描述符，就可以被<em>select</em>监听!</p>
<p>所以<em>select</em>内部监听的其实是对象下的<code>fileno()</code>方法返回的文件描述符。<br>即我们自己写一个类，类中封装一个<code>fileno()</code>方法，因为我们没办法自己写文件描述符，所以我们直接调用socket对象的文件描述<code>socket().fileno()</code>在我们方法的最后返回。那么我们自定义的对象就可以放到<em>select</em>中去被监听！</p>
<p><img alt="select监听自定义对象" data-src="/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/4.jpg" class="lozad"></p>
<p><u>要记住上面的三个前戏内容（无阻塞socket，io多路复用模块select，select监听的对象）！！它是我们自定义异步IO模块的关键！</u></p>
<h2 id="自定义异步IO模块开发"><a href="#自定义异步IO模块开发" class="headerlink" title="自定义异步IO模块开发"></a>自定义异步IO模块开发</h2><p>有了上面的前戏，我们不难理解 异步IO请求的本质则是【非阻塞Socket】+【IO多路复用】！<br>异步IO请求的本质则是【非阻塞Socket】+【IO多路复用】 ！<br>异步IO请求的本质则是【非阻塞Socket】+【IO多路复用】 ！ (重要的事情说三遍!!!)</p>
<p><strong>要明确的一点是：我们一直在写的都是socket的客户端，因为爬虫基于是客户端实现的一种技术!</strong></p>
<p>本质上浏览器发送一个请求就是做下面这样的事情(认识HTTP的本质)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="comment">###############HTTP请求本质，阻塞###############</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line"><span class="comment"># 1.连接</span></span><br><span class="line">sk.connect((<span class="string">'www.baidu.com'</span>,<span class="number">80</span>))  <span class="comment"># IO阻塞</span></span><br><span class="line">print(<span class="string">'连接成功啦！！'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.连接成功发送消息</span></span><br><span class="line">sk.send(<span class="string">b"GET / HTTP/1.0\r\nHost:www.baidu.com\r\n\r\n"</span>)</span><br><span class="line"><span class="comment">#sk.send(b"POST / HTTP/1.0\r\nHost:www.baidu.com\r\n\r\nk1=v1&amp;k2=v2")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.等待服务端响应</span></span><br><span class="line">data = sk.recv(<span class="number">8096</span>) <span class="comment"># IO阻塞</span></span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">sk.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">###############HTTP请求本质，无阻塞###############</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.setblocking(<span class="literal">False</span>) <span class="comment"># 设置完后，该socket就是非阻塞的了</span></span><br><span class="line"><span class="comment"># 1.连接</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sk.connect((<span class="string">'www.baidu.com'</span>,<span class="number">80</span>))</span><br><span class="line">    <span class="comment"># 无阻塞会直接往下走，会报BlockingIOError:无法立即完成一个非阻止性套接字操作</span></span><br><span class="line">    <span class="comment"># 使用异常处理处理日常使程序正常执行,不至于崩溃</span></span><br><span class="line">    print(<span class="string">'连接成功啦！！'</span>)</span><br><span class="line"><span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">	print(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="comment"># 弄一个事件循环不断去监听socket有没有返回响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.连接成功发送消息</span></span><br><span class="line">sk.send(<span class="string">b"GET / HTTP/1.0\r\nHost:www.baidu.com\r\n\r\n"</span>)</span><br><span class="line"><span class="comment">#sk.send(b"POST / HTTP/1.0\r\nHost:www.baidu.com\r\n\r\nk1=v1&amp;k2=v2")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.等待服务端响应</span></span><br><span class="line">data = sk.recv(<span class="number">8096</span>) <span class="comment"># IO无阻塞</span></span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>上面案例中我写的非阻塞的Http请求实现方式，使用了一个事件循环不断地去监听<em>socket</em>有没有返回响应。此时程序会卡在这里的。这是非常Low的。<br>既然使用非阻塞<em>socket</em>，我们希望的就是能在遇到IO阻塞的时候去执行别的任务（如再去发送别的请求），等到有数据返回的时候执行回调，这就是我们异步IO的功能（使用select去实现）。而不是卡在一个地方！循环监测”一个<em>socket</em>”的状态。<br>所以我们的正戏开始！下面我们就来实现自定义异步IO模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span>:</span></span><br><span class="line">    <span class="string">"""封装请求和相应的基本数据比如说域名Host和回调函数"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,sk,host,callback)</span>:</span></span><br><span class="line">        self.socket = sk</span><br><span class="line">        self.host = host</span><br><span class="line">        self.callback = callback</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fileno</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""让select可以直接监听我们这个对象"""</span></span><br><span class="line">        <span class="keyword">return</span>(self.socket.fileno)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpResponse</span>:</span></span><br><span class="line">    <span class="string">"""格式化和处理响应数据（分割请求头请求体）"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,recv_data)</span>:</span></span><br><span class="line">        self.recv_data = recv_data</span><br><span class="line">        self.header_dict = &#123;&#125;</span><br><span class="line">        self.body = <span class="literal">None</span></span><br><span class="line">    	initialize()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 分割响应头和响应体，以两个换行符分割，1表示顺序分割1次 注意接收到的数据是bytes类型</span></span><br><span class="line">    	headers,body = self.recv_data.split(<span class="string">b'\r\n\r\n'</span>,<span class="number">1</span>)</span><br><span class="line">        self.body = body</span><br><span class="line">        <span class="comment"># 分割出每一个响应头，以一个换行符分割</span></span><br><span class="line">		header_list = headers.split(<span class="string">b'\r\n'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> header_list:</span><br><span class="line">            <span class="comment">#分出每个响应头中的键值对以字典形式存放</span></span><br><span class="line">            h_str = str(h,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">            v = h_str.split(<span class="string">":"</span>,<span class="number">1</span>)  <span class="comment"># 响应头中键值对是以':'分割的(响应首行不是键值对形式，需处理)</span></span><br><span class="line">            <span class="keyword">if</span> len(v) == <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 以键值对形式存在的响应头，直接放入字典中</span></span><br><span class="line">                self.header_dict[v[<span class="number">0</span>]] = v[<span class="number">1</span>]</span><br><span class="line">             <span class="keyword">elif</span> len(v) == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 请求首行放的是一些staus等信息，不以键值对形式存在，这里做特殊处理。</span></span><br><span class="line">                <span class="comment"># 请求首行的信息HTTP/1.1 200 OK</span></span><br><span class="line">                self.header_dict[<span class="string">'staus'</span>] = v[<span class="number">0</span>]</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncRequest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn = []   <span class="comment"># 用于检测sock是否有数据可读</span></span><br><span class="line">        self.connection = [] <span class="comment"># 用于检测是否已经连接成功</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_request</span><span class="params">(self,host,callback)</span>:</span></span><br><span class="line">        <span class="string">"""创建socket并连接服务器"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sk = socket.socket()</span><br><span class="line">            sk.setblocking(<span class="literal">False</span>)  <span class="comment"># 设置为非阻塞socket</span></span><br><span class="line">            sk.connect((host,<span class="number">80</span>))  <span class="comment"># 非阻塞，发送链接请求后马上往下执行，会报错</span></span><br><span class="line">        <span class="keyword">except</span> BlockingIoError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        request = HttpRequest(sk,host,callback)</span><br><span class="line">         <span class="comment"># 把request封装的socket对象全放到了我们的conn列表中</span></span><br><span class="line">        self.conn.append(request) </span><br><span class="line">        <span class="comment"># 把request封装的socket对象全放到了我们的connection列表中</span></span><br><span class="line">        self.connection.append(request) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""事件循环，用于检测请求的socket是否已经就绪，从而执行相关操作"""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">            r,w,e = select.select(self.conn,self.connection,self.conn,<span class="number">0.05</span>)</span><br><span class="line">            <span class="comment"># 设置了timeout，轮询完后阻塞timeout时间，返回列表</span></span><br><span class="line">            <span class="comment"># 监测socket连接上了，所以循环遍历w（如果是空列表是不会执行for循环内容的）</span></span><br><span class="line">			<span class="keyword">for</span> request <span class="keyword">in</span> w:</span><br><span class="line">                print(request.host,<span class="string">'连接成功...'</span>)</span><br><span class="line">                <span class="comment"># 只要能循环到，表示socket和服务器端已经连接成功</span></span><br><span class="line">                tpl = <span class="string">"GET %S HTTP/1.0\r\nHost:%s\r\n\r\n"</span>%(w.host)</span><br><span class="line">                request.socket.send(bytes(tpl,encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="comment"># 因为成功连接后没必要继续监听,so要把该socket从监测是否连接成功的列表中移除掉</span></span><br><span class="line">                self.connection.remove(request)</span><br><span class="line">             </span><br><span class="line">            <span class="comment"># 连接成功后我们就要看下连接成功的socket是否有数据传过来了，所以要遍历r</span></span><br><span class="line">            <span class="comment"># 如果是空列表（即没有socket有数据可读时r就是[]空的）是不会执行for循环内容的</span></span><br><span class="line">            	<span class="keyword">for</span> request <span class="keyword">in</span> r:</span><br><span class="line">                    <span class="comment"># request是HttpRequset对象,如果还没有数据返回,</span></span><br><span class="line">                    recv_data = bytes() <span class="comment"># 表示这个一个空的字节</span></span><br><span class="line">                	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                       	<span class="comment"># 因为服务端可能返回的数据大于我们指定接收的大小，所以要循环去收完</span></span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            <span class="comment"># 非阻塞socket没有接收到数据也会往下执行，报错</span></span><br><span class="line">                            <span class="comment"># 所以必须使用异常处理</span></span><br><span class="line">                        	chunck = request.socket.recv(<span class="number">8096</span>)</span><br><span class="line">                            recv_data += chunck</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                            <span class="comment"># 出异常表示数据接收完了或者数据为空</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">						response = HttpResonse(recv_data)  <span class="comment"># 把接收的http数据响应头响应体分割 </span></span><br><span class="line">                        request.callback(response) <span class="comment"># 让每个响应去执行相应的回调函数</span></span><br><span class="line">                        request.socket.close()</span><br><span class="line">                        self.conn,remove(r) <span class="comment">#接收完数据后，该sock就不需要继续被监听了</span></span><br><span class="line">            	</span><br><span class="line">                <span class="keyword">if</span> len(self.conn) == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment">#处理完所有的请求后我们要退出循环，否则select会一直监听</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                        </span><br><span class="line">                   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(<span class="string">'保存到文件'</span>,response.header_dict)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(<span class="string">'保存到数据库'</span>,response.header_dict)     </span><br><span class="line">    </span><br><span class="line">url_list=[</span><br><span class="line">    &#123;<span class="string">'host'</span>:<span class="string">'www.baidu.com'</span>,<span class="string">'callback'</span>:f1&#125;,</span><br><span class="line">    &#123;<span class="string">'host'</span>:<span class="string">'cn.bing.com'</span>,<span class="string">'callback'</span>:f1&#125;,</span><br><span class="line">    &#123;<span class="string">'host'</span>:<span class="string">'deehuang.github.io'</span>,,<span class="string">'callback'</span>:f1&#125;,</span><br><span class="line">]</span><br><span class="line">req = AsyncRequest()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> url_list:</span><br><span class="line">    req.add_request(item[<span class="string">'host'</span>],item[<span class="string">'callback'</span>])  <span class="comment"># 给每个请求创建socket并连接url所指的服务器</span></span><br><span class="line">req.run()</span><br></pre></td></tr></table></figure>

<p>案例中的我们使用一个死循环去执行<code>run()</code>。这个死循环其实就是我们的在上面介绍常用的<em>python</em>内置和第三方异步IO模块的时候所说到的<strong>事件循环</strong>。它的作用就是<u>检测请求的socket是否已经就绪，从而执行相关操作</u></p>
<p>补充知识点：所有和http相关的模块，包括我们的web框架，本质上对接收的到的http请求数据使用的分割请求头和请求体方法都是这样的<code>header,body = recv_data.split(b&#39;\r\n\r\n&#39;,1)</code>即从左到右对第一个双换行符进行分割（因为http的请求头和请求体就是用双换行符去分开标识的）。而对于每个请求头我们使用“/r/n”单换行符就可以进行分割<code>header_list = headers.split(b&#39;\r\n&#39;)</code>。对于请求头中的键和值和值是以<code>:</code>去分割的！我们案例中可以以同样的方法会分割和处理我们拿到的<strong>响应数据</strong>，案例专门使用<code>HttpReponse()</code>对象去处理响应数据</p>
<p>如果我们要想实现每个请求执行相关操作，需要在<code>url_list</code>中带上要执行的回调函数</p>
<hr>
<p>上面短短一百多行代码,就是实现了我们的异步IO模块了!<br>要注意的一点是，这个设计的异步框架对于框架本身不是异步的，我们只不过是让socket不阻塞，然后加上个循环一直去检测socket的状态。当这个模块在别人调用的时候才实现了异步！既对使用者来说才是异步的。</p>
<p>再思考一下：<br>select能做异步吗？selcet仅仅是io多路复用，它唯一的功能就是：<strong>同时监听多个socket对象！同时监听多个socket对象！同时监听多个socket对象！</strong>。它监听的这个过程本来就是同步的（不断去监听sock的状态），它自己<u>完成不了异步</u>的操作，<u>而我们利用它的特性可以去实现我们的异步IO模块</u><br>什么是异步IO？字面上看它首先是异步的，然后它是一个IO请求。所以异步IO的意思就是当我们遇到IO请求的时候，不再一边傻等，而是能去做别的事情（非阻塞socket）。等IO请求完成后内部<strong>自动完成回调</strong>(”利用“io多路复用去实现，ps:是<u>利用</u>不是使用，Io多路复用只能干什么？？看上面！！)去执行我指定的函数这样的一个过程<br>所以异步是啥东西？我简单的理解是：异步就是<strong>自动回调！自动回调！自动回调！</strong></p>
<p>So，通过非阻塞的socket+利用io多路复用 就可以实现我们的异步IO模块</p>
<p>总结异步IO模块的实现:</p>
<ol>
<li>设置非阻塞socket</li>
<li>select监听多个socket的状态（可以用我们自己定制的对象<em>fileno</em>方法+<code>return</code> <em>socket</em>描述符 <code>sk.fileno()</code>）</li>
<li>监测scoket状态变化调用对应的回调函数</li>
<li>事件循环，即然后重复上面2,3过程。实现不停请求socket状态并调用对应的回调函数 </li>
</ol>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程    </a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/">多进程    </a><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5IO/">异步IO    </a><a class="post-meta__tags" href="/tags/python%E7%88%AC%E8%99%AB%E6%80%A7%E8%83%BD/">python爬虫性能    </a></div><div class="post_share"><div class="social-share" data-image="/img/topimg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/10/30/Scrapy%E6%A1%86%E6%9E%B6/"><img class="prev_cover lozad" data-src="/img/scrapy入门_cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Scrapy框架入门</span></div></a></div><div class="next-post pull-right"><a href="/2019/10/24/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%8E%92%E5%9D%91/"><img class="next_cover lozad" data-src="/img/cover_default3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>hexo上传图片小坑</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzI1MC8yMzc1MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer style="background-image: url(/img/topimg.jpg)"><div id="footer"><div class="copyright">&copy;2019 - 2020 By Rhubarb C</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script color="0,0,255" opacity="0.7" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>