<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>python爬虫之如何实现并发 | RhubarbC的博客</title><meta name="description" content="在学习爬虫过程中，我发现使用并发的方案是必不可少的！实现并发的方式有很多，如多线程、多进程还有异步IO等等。在实际运用中，我也只是会各种调包实现并发，但是内部怎么实现的却是一点都不知道。奈何我有一颗好奇的心，这篇文章就是来写一下我学习实现并发的几个方案和python中实现并发的常用模块以及分析它们底层是怎么实现的！"><meta name="keywords" content="多线程,多进程,异步IO,python爬虫性能"><meta name="author" content="Rhubarb C"><meta name="copyright" content="Rhubarb C"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="python爬虫之如何实现并发"><meta name="twitter:description" content="在学习爬虫过程中，我发现使用并发的方案是必不可少的！实现并发的方式有很多，如多线程、多进程还有异步IO等等。在实际运用中，我也只是会各种调包实现并发，但是内部怎么实现的却是一点都不知道。奈何我有一颗好奇的心，这篇文章就是来写一下我学习实现并发的几个方案和python中实现并发的常用模块以及分析它们底层是怎么实现的！"><meta name="twitter:image" content="http://yoursite.com/img/topimg.jpg"><meta property="og:type" content="article"><meta property="og:title" content="python爬虫之如何实现并发"><meta property="og:url" content="http://yoursite.com/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/"><meta property="og:site_name" content="RhubarbC的博客"><meta property="og:description" content="在学习爬虫过程中，我发现使用并发的方案是必不可少的！实现并发的方式有很多，如多线程、多进程还有异步IO等等。在实际运用中，我也只是会各种调包实现并发，但是内部怎么实现的却是一点都不知道。奈何我有一颗好奇的心，这篇文章就是来写一下我学习实现并发的几个方案和python中实现并发的常用模块以及分析它们底层是怎么实现的！"><meta property="og:image" content="http://yoursite.com/img/topimg.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="hexo上传图片小坑" href="http://yoursite.com/2019/10/24/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%8E%92%E5%9D%91/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://deehuang.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: Rhubarb C","link":"链接: http://yoursite.com/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/","source":"来源: RhubarbC的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">RhubarbC的博客</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#爬虫性能相关"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">爬虫性能相关</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#参考文献"><span class="toc_mobile_items-number">1.0.1.</span> <span class="toc_mobile_items-text">参考文献</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#多线程实现并发请求"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">多线程实现并发请求</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#多进程实现并发请求"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">多进程实现并发请求</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#异步IO实现（伪）并发请求"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">异步IO实现（伪）并发请求</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#协程"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">协程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#异步IO"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">异步IO</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#异步IO模块的使用"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">异步IO模块的使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#asyncio-模块"><span class="toc_mobile_items-number">4.3.1.</span> <span class="toc_mobile_items-text">asyncio 模块</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#asyncio-aiohttp-模块"><span class="toc_mobile_items-number">4.3.1.1.</span> <span class="toc_mobile_items-text">asyncio+aiohttp 模块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#asyncio-requests-模块"><span class="toc_mobile_items-number">4.3.1.2.</span> <span class="toc_mobile_items-text">asyncio+requests 模块</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#gevent-模块"><span class="toc_mobile_items-number">4.3.2.</span> <span class="toc_mobile_items-text">gevent 模块</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#gevent-requests"><span class="toc_mobile_items-number">4.3.2.1.</span> <span class="toc_mobile_items-text">gevent+requests:</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#grequests-模块"><span class="toc_mobile_items-number">4.3.2.2.</span> <span class="toc_mobile_items-text">grequests 模块</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Twisted-模块"><span class="toc_mobile_items-number">4.3.3.</span> <span class="toc_mobile_items-text">Twisted 模块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Tornado-模块"><span class="toc_mobile_items-number">4.3.4.</span> <span class="toc_mobile_items-text">Tornado 模块</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#自定义异步IO模块"><span class="toc_mobile_items-number">4.3.5.</span> <span class="toc_mobile_items-text">自定义异步IO模块</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#非阻塞socket"><span class="toc_mobile_items-number">4.3.5.1.</span> <span class="toc_mobile_items-text">非阻塞socket</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#IO多路复用"><span class="toc_mobile_items-number">4.3.5.2.</span> <span class="toc_mobile_items-text">IO多路复用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#自定义异步IO模块开发"><span class="toc_mobile_items-number">4.3.5.3.</span> <span class="toc_mobile_items-text">自定义异步IO模块开发</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#爬虫性能相关"><span class="toc-number">1.</span> <span class="toc-text">爬虫性能相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文献"><span class="toc-number">1.0.1.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多线程实现并发请求"><span class="toc-number">2.</span> <span class="toc-text">多线程实现并发请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多进程实现并发请求"><span class="toc-number">3.</span> <span class="toc-text">多进程实现并发请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步IO实现（伪）并发请求"><span class="toc-number">4.</span> <span class="toc-text">异步IO实现（伪）并发请求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#协程"><span class="toc-number">4.1.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步IO"><span class="toc-number">4.2.</span> <span class="toc-text">异步IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步IO模块的使用"><span class="toc-number">4.3.</span> <span class="toc-text">异步IO模块的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#asyncio-模块"><span class="toc-number">4.3.1.</span> <span class="toc-text">asyncio 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-aiohttp-模块"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">asyncio+aiohttp 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-requests-模块"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">asyncio+requests 模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gevent-模块"><span class="toc-number">4.3.2.</span> <span class="toc-text">gevent 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gevent-requests"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">gevent+requests:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grequests-模块"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">grequests 模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Twisted-模块"><span class="toc-number">4.3.3.</span> <span class="toc-text">Twisted 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tornado-模块"><span class="toc-number">4.3.4.</span> <span class="toc-text">Tornado 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异步IO模块"><span class="toc-number">4.3.5.</span> <span class="toc-text">自定义异步IO模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#非阻塞socket"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">非阻塞socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO多路复用"><span class="toc-number">4.3.5.2.</span> <span class="toc-text">IO多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义异步IO模块开发"><span class="toc-number">4.3.5.3.</span> <span class="toc-text">自定义异步IO模块开发</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/topimg.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">python爬虫之如何实现并发</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-25<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-10-29</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/">python网络爬虫</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 21 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="爬虫性能相关"><a href="#爬虫性能相关" class="headerlink" title="爬虫性能相关"></a>爬虫性能相关</h1><p>在使用爬虫的时候，不难发现我们使用requests模块帮助我们来发请求，如果服务端没有返回响应，那么我们的程序就会像二愣子一样傻不愣登的死等下去（单线程方案）。</p>
<p>上面的方法显然效率是特别低的。我们所熟识的能够“同时”帮我们做操作，实现并发其实就是线程和进程。所以我觉得聪明的做法就是同时去发多个请求（开多线程或进程），某一请求完成后“告诉一下我”，我再去拿数据搞事情。<br>在学习过程中，不知道大家是否和我一样有这样的疑问，请求完成后是怎么“告诉我们”的？就是说在各种调包实现我们想要的并发效果的时候，这个“告诉我们”的回调过程是怎么实现的呢？  </p>
<p>下面是多线程、多进程和异步IO这三种实现并发的方案是怎么去实现并发和回调（接收到响应后执行相应的回调函数）过程的一些学习心得！</p>
<hr>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><a href="https://www.cnblogs.com/wupeiqi/articles/6229292.html" target="_blank" rel="noopener">参考文献</a></h3><h1 id="多线程实现并发请求"><a href="#多线程实现并发请求" class="headerlink" title="多线程实现并发请求"></a>多线程实现并发请求</h1><p>使用线程池开多线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    下载页面</span></span><br><span class="line"><span class="string">    为了方便区分我们这里把该函数叫做主体函数，主体函数执行完后会触发回调函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    print(url,response)</span><br><span class="line">    reuten response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">done</span><span class="params">(future,*args,**kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    回调函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(future,args,kwargs)  <span class="comment"># 回调函数不直接把response传入，而是封装成一个future对象</span></span><br><span class="line">    response = future.result()  <span class="comment"># 通过future对象的result方法可以取到我们的返回值</span></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">5</span>)</span><br><span class="line">url_list = [</span><br><span class="line">    <span class="string">'http://www.baidu,com'</span>,</span><br><span class="line">    <span class="string">'http://www.pianshen.com/article/292812067/'</span>,</span><br><span class="line">    <span class="string">'http://deehuang.github.io'</span>,</span><br><span class="line">    <span class="string">'http://www.zhihu.com'</span>,</span><br><span class="line">    <span class="string">'http://www.sina.com'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    v = pool.submit(task,url)  <span class="comment"># 使用线程池中的线程去执行task函数，把url作为实参传入</span></span><br><span class="line">    v.add_done_callback(done)  <span class="comment"># 添加回调函数，这里表示task执行完后执行done方法</span></span><br><span class="line">pool.shutdown(wait=<span class="literal">True</span>)  <span class="comment"># 关闭线程池，Wait是等待所有调度的线程执行完后再关闭</span></span><br></pre></td></tr></table></figure>

<p>如果我们希望线程执行完<code>task</code>函数后再执行一个回调函数，我们可以使用一个变量去接收<code>pool.sumit(task,url)</code>的返回值，然后给这个返回值可以添加一个回调函数<code>add_done_callback(done)</code><br>上面的例子中，我们执行完<code>task</code>后传入回调函数中的参数是一个<code>future</code>对象（这是<code>add_done_callback（）</code>帮我封装的，它除了封装了返回值还有别的东西），而不直接是<code>task</code>返回的<code>response</code>对象。通过<code>future.result()</code>就可以拿到我们的<code>requests</code>请求返回的<code>response</code>对象！<br>PS：实际运用中，我们也可以不使用回调函数，可以直接把所有的逻辑代码写到主体函数中，使用和不使用回调都是多线程方式，这两种多线程方式只不过编写方式不一样而已（使用回调函数代码耦合会低一些）。</p>
<p>这就是我们使用线程池实现多线程实现并发的发起请求操作的方法（有些小伙伴可能会”有开多线程难道非要用线程池?”的疑问。使用线程池是为了方便对线程的管理， 线程的创建和销毁的开销是巨大的，而通过线程池的重用大大减少了这些不必要的开销，当然既然少了这么多消费内存的开销，其线程执行速度也是突飞猛进的提升。 ）</p>
<h1 id="多进程实现并发请求"><a href="#多进程实现并发请求" class="headerlink" title="多进程实现并发请求"></a>多进程实现并发请求</h1><p>多进程实现并发方案跟多线程的实现的方案几乎是一模一样的。<br>只不过我们引入的是线程池了</p>
<p><code>from concurrent.futures import ProcessPoolExecutor</code><br><code>pool = processPoolExecutor(8)</code><br><code>v = pool.submit(task,url)  # 使用进程池中的线程去执行task函数，把url作为实参传入</code><br><code>v.add_done_callback(done)  # 添加回调函数，这里表示task执行完后执行done方法</code></p>
<hr>
<p>总结一下多线程和多进程实现并发的方案：</p>
<p>  1.优点：可以实现并发</p>
<p>  2.缺点：如果请求发出去后和等待返回响应的这段时间里（IO阻塞），这些被调度的线程（进程）就处于没事做的空闲状态。我觉得挺浪费的（因为开启线程就占用了资源），既然占用资源我就想让线程（进程）不断地帮我做事情，如果在阻塞的事件中可以让这些线程（进程）去做别的事情，那真是美滋滋（这大概是所有老板的心声吧~）</p>
<p>  3.编写方式：</p>
<ul>
<li><p>直接返回处理</p>
</li>
<li><p>通过回调函数处理</p>
<p>4.两种方案的对比（从对比线程和进程的区别去探讨这个问题）：</p>
</li>
</ul>
<ul>
<li>线程是cpu工作的最小单元，线程存在进程里边，”它是真实地工作者“</li>
<li>每开一个进程，该进程中的所有线程共享这个资源集里的资源  <em>头脑风暴</em>：进程就像是一个房子。这个房子里面人就是线程，该房子（线程）里的所有人共享这个房子的所有资源。通过这个例子不难想象，开进程是十分耗费资源的，相当于重搭一个房子。而使用多线程的方式就相当于在屋子里多放几个人而不用专门为每个人重搭一个房子</li>
<li>什么时候用多进程?什么时候用多进程？<br>  因为python的GIL锁的原因（<strong>同一时刻只允许一个进程中的一个线程被cpu调度</strong>），所以对于<strong>计算密集型</strong>的程序我们使用多进程的方案会好一些；对于<strong>io密集型</strong>的程序用多线程会更好（遇到io操作的时候不用跟cpu交互，因为遇到Io操作cpu就会切到别的线程去执行，所以就好像不受GIL的限制）</li>
</ul>
<h1 id="异步IO实现（伪）并发请求"><a href="#异步IO实现（伪）并发请求" class="headerlink" title="异步IO实现（伪）并发请求"></a>异步IO实现（伪）并发请求</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>学习异步IO模型，我们首先要理解<strong>协程</strong>的概念:</p>
<p>协程简单的理解为规定了让一个<strong>线程</strong>先执行一下一个<strong>函数1</strong>，执行到一半，再切换到另外一个<strong>函数2</strong>执行，然后又回去执行<strong>函数1</strong>（是从上次执行的状态继续往下执行）……。这样的过程就像是线程分片了（然线程先执行这个又执行下那个），所以它也被叫做微线程</p>
<p>实现上面过程的方式就是用我们的生成器函数，在函数中使用yield返回函数值，就是一个生成器函数。当函数遇到yield就会跳出函数并返回yield所带的值，再次执行该函数的时候会从上一次yield的地方继续往下执行（实现了保存上下文状态）。</p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><strong>协程</strong>仅仅提供的功能只是切换，它只能单纯的执行下这个函数又去执行下别的函数……这样的过程。利用协程可以并发的发送多个请求（实际上不是并发只不过速度非常快看似并发）。即是用<u>一个线程</u>就能把所有的请求（放到不同的生成器函数中）并发的发送过去。<u>但是单纯的它并不能帮我们完成任何的操作!</u></p>
<p><strong>异步IO</strong>的功能是发送的请求响应后<strong>接着</strong>执行下面的任务。</p>
<p>利用协程+异步IO就可以完成并发的发送请求并且一旦某一个请求的结果返回时，继续执行该请求函数下面的任务。因为是一个线程处理多个http请求，所以当同一时刻有多个http请求返回的时候也只能处理一个请求，所以我们称异步IO方案实现的<strong>伪</strong>并发请求</p>
<p>可能有的人还是有点不太理解上面是什么意思？不是协程自己就已经实现了并发的去发送请求吗？<br>我们所说的并发HTTP请求实际上是包括了两个部分的：发送请求+处理响应内容。不是说你只是发个请求后面的事情就不管了，我们请求的目的不是就是为了拿数据搞事情吗?多线程和多进程每个进程遇到io操作是同步操作，所以不用考虑回调的问题。（就是说线程/进程一直等到数据返回了才会往下执行，这期间该线程/进程会被一直挂起）<br>协程完成的只是切换功能（但是什么时候切换它是不知道，它不知道什么时候HTTP请求会返回，所以我们需要利用异步IO的功能）；而异步IO完成的是<strong>自动回调!</strong> <strong>自动回调!</strong> <strong>自动回调!</strong>(重要的事情说三遍)。所以协程+异步IO ==》 一个线程发送N个Http请求 </p>
<h2 id="异步IO模块的使用"><a href="#异步IO模块的使用" class="headerlink" title="异步IO模块的使用"></a>异步IO模块的使用</h2><p>Python作为一个”面向调包”的语言（调侃一下），这种单线程+异步IO来实现处理N多个请求的模块当然是必须存在的，我们慢慢的引入这些模块。</p>
<h3 id="asyncio-模块"><a href="#asyncio-模块" class="headerlink" title="asyncio 模块"></a>asyncio 模块</h3><p>python3的内置模块<code>asyncio</code>可以帮助我们完成上面的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">asyncio模块的固定用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'执行func1之前'</span>)</span><br><span class="line">	<span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">5</span>)   <span class="comment">#必须写的是yield form---&gt;固定写法</span></span><br><span class="line">	print(<span class="string">'执行func1结束'</span>)</span><br><span class="line">	</span><br><span class="line">tasks = [func1(),func1()]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>是不是把上述的代码改成<code>发送http请求,获取结果</code>不就实现了并发的发送处理http请求了呢？</p>
<p>很遗憾的是asynico模块不支持HTTP请求，支持TCP请求。我们知道HTTP是基于TCP做的，所以我们可以根据这个协议来对这个模块做一个改造</p>
<p>回顾一下HTTP和TCP请求：</p>
<p>  TCP：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client = socket()</span><br><span class="line">client.connect()</span><br><span class="line">client.send(b&apos;asdasdasdas&apos;)</span><br></pre></td></tr></table></figure>

<p>  HTTP:<br>  HTTP实际上内部也是用的TCP请求的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client = socket()</span><br><span class="line">client.connect()</span><br><span class="line">client.send(data)</span><br></pre></td></tr></table></figure>

<p>  只不过它在<code>send（）</code>中<code>data</code>内容是不一样的，就是说HTTP只是规定了一个<strong>数据格式</strong><br>  它的格式是这样的：<br><code>data = &quot;&quot;&quot;GET %S HTTP/1.0\r\nHost:%s\r\n\r\n&quot;&quot;&quot;%(url,host)</code><br>  其实就是我们所说的Http请求三部分：请求首行、请求头、请求体</p>
<p>PS:请求首行和请求头之间一个换行，请求头和请求头直接一个换行，请求头和请求体之间两个换行<br><img alt data-src="/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/1.jpg" class="lozad"></p>
<p>这样我们就可以通过自己构造http数据格式来通过asyncio模块去发HTTP请求了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">asyncio模块实现发送Http请求  ---&gt;固定用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(host,url=<span class="string">'/'</span>)</span>:</span></span><br><span class="line">	reader,writer = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.open_connection(host,<span class="number">80</span>)<span class="comment"># 创建连接，本质上就是通过socket创建一个连接</span></span><br><span class="line">    </span><br><span class="line">    request_headet_content = <span class="string">"""GET %S HTTP/1.0\r\nHost:%s\r\n\r\n"""</span>%(url,host)<span class="comment">#我们构造的http请求的格式</span></span><br><span class="line">    request_headet_content = bytes(request_header_content,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    </span><br><span class="line">    writer.write(request_header_content)  <span class="comment"># TCP的sent</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> writer.drain()</span><br><span class="line">    text = <span class="keyword">yield</span> <span class="keyword">from</span> reader.read()  <span class="comment"># Tcp的recv</span></span><br><span class="line">    print(host,utl,text)</span><br><span class="line">    writer.close()  <span class="comment"># 关闭socket</span></span><br><span class="line">	</span><br><span class="line">tasks = [task(<span class="string">'deehuang.github.io'</span>,<span class="string">'/link/'</span>), <span class="comment"># (host,url)</span></span><br><span class="line">         task(<span class="string">'deehuang.github.io'</span>,<span class="string">'/tags/'</span>)]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<h4 id="asyncio-aiohttp-模块"><a href="#asyncio-aiohttp-模块" class="headerlink" title="asyncio+aiohttp 模块"></a>asyncio+aiohttp 模块</h4><p><code>asyncio</code>模块可以实现异步IO的功能，但是对HTTP的不友好显然给我们带来了许多麻烦。我们每次都要自己去封装HTTP数据包，但是python作为”面向调包“的语言，它当然也有帮我们封装HTTP数据包的模块，就是我们的<code>aiohttp</code>模块（这不是一个内置模块，需要先安装pip install aiohttp再使用）</p>
<p><code>asynico+aiohttp</code>两者结合就方便地实现了使用异步IO发送HTTP请求了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">asyncio+aiohttp模块的搭配固定用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(url)</span>:</span></span><br><span class="line">	print(url)</span><br><span class="line">    response = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.reques(<span class="string">'GET'</span>,url) <span class="comment">#这一句代码就把上面我们自己封装Http数据包和创建socket连接,返回值就相当于是我们的socket链接对象</span></span><br><span class="line">    data = <span class="keyword">yield</span> form response.read()</span><br><span class="line">    print(url,response)</span><br><span class="line">    response.close()</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">tasks = [task(<span class="string">'http://deehuang.github.io/'</span>), <span class="comment"># (url)</span></span><br><span class="line">         task(<span class="string">'http://www.baidu.com/'</span>)]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>小总结：</p>
<p>  <em>asynico</em>里面帮助我们完成的是异步的功能<br>  <em>aiohttp</em>帮助我们完成的是封装Http数据包的功能和创建socket链接的功能<br>  这两个组件是配合使用的，<em>aiohttp</em>也是基于<em>asynico</em>去开发的</p>
<h4 id="asyncio-requests-模块"><a href="#asyncio-requests-模块" class="headerlink" title="asyncio+requests 模块"></a>asyncio+requests 模块</h4><p><em>asynico</em>除了可以搭配<em>aiohttp</em>模块使用，还能和requests模块搭配使用！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">asyncio+requests模块的搭配固定用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(func,*args)</span>:</span></span><br><span class="line">    print(func,args)</span><br><span class="line">	loop = asyncio.get_event_loop()</span><br><span class="line">    future = loop.run_in_executor(<span class="literal">None</span>,func,*args) <span class="comment"># 把args当作参数传入func中</span></span><br><span class="line">    response = <span class="keyword">yield</span> <span class="keyword">from</span> future</span><br><span class="line">    print(response.url,response.content)</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">tasks = [task(requests.get,<span class="string">'http://deehuang.github.io/'</span>), <span class="comment"># (func,url)</span></span><br><span class="line">         task(requests.get,<span class="string">'http://www.baidu.com/'</span>)]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>requests模块实际上在这里也是帮助我们封装Http数据包并且建立socket连接，然后通过socket发过去</p>
<h3 id="gevent-模块"><a href="#gevent-模块" class="headerlink" title="gevent 模块"></a>gevent 模块</h3><p>如今主流的一个帮助我们做网络请求提高并发的模块，它内部原理跟asyncio原理本质上是一样的！</p>
<p><strong>gevent</strong>内部依赖于<strong>greenlet</strong>模块，<em>greenlet</em>是一个协程的模块（复习一下协程，是一个微线程，是我们自己指定一个线程先执行什么再执行什么再执行什么……这样的一个过程）。<em>greenlet</em>只是做协程，处理网络请求我们没办法指定先执行什么然后执行什么，它是根据请求的响应来决定什么时候执行的。所以说<em>gevent</em>依赖于<em>greenlet</em>实现切换功能，而<em>gevent</em>内部也实现了异步IO的功能。两者结合起来去完成并发。</p>
<p><em>gevent</em>,<em>greenlet</em>都不是内置模块，所以需要去安装它们<br><code>pip install greenlet</code><br><code>pip install gevent</code></p>
<p><em>gevent</em>和<em>asyncio</em>一样，内部只是支持socket级别的操作，即只支持TCP，不支持HTTP。所以我们还是需要搭配其他的http封包模块去帮助我们发Http请求</p>
<h4 id="gevent-requests"><a href="#gevent-requests" class="headerlink" title="gevent+requests:"></a><em>gevent</em>+requests:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">gevent+requests实现并发  ----&gt;标准用法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()  <span class="comment">#这句不要忘记了，它内部会找到我们原来的所有的socket（原来socket中的io操作如sent,recv，connetion等等都是同步操作），都变成gevent帮我们封装成异步IO的socket </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(method,url,req_kwargs)</span>:</span></span><br><span class="line">    print(method,url,req_kwargs)</span><br><span class="line">    response = requests.request(method=method,url=url,**req_kwargs)</span><br><span class="line">    print(response.url,response.content)</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 发送请求 ####</span></span><br><span class="line">gevent.joinall([</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>如果我们需要同时并发的任务有特别多，例如有一百个请求需要发出去。我们一个线程处理的完吗？肯定效率是非常低的。所以gevent非常友好的给我们提供了协程池，来控制我们最多向远程发起请求的数量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### 发送请求（协程池控制最大携程数量） ####</span></span><br><span class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</span><br><span class="line">pool = Pool(<span class="number">5</span>) <span class="comment"># 最多调用五个协程切换任务</span></span><br><span class="line">gevent.joinall([</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">  gevent.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h4 id="grequests-模块"><a href="#grequests-模块" class="headerlink" title="grequests 模块"></a>grequests 模块</h4><p>再次感慨“面向调包”语言的强大，有人已经把上面的gevent和requests封装成一个模块供我们快速调用了。（其实我觉得是有点low的，因为上面也没几句代码……:sweat:)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> grequests</span><br><span class="line"></span><br><span class="line">request_list = &#123;</span><br><span class="line">	grequests.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">	grequests.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">	grequests.spawm(task,method=<span class="string">'get'</span>,url=<span class="string">'http://deehuang.github.io/'</span>,req_kwargs=&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 执行并获取响应列表 ####</span></span><br><span class="line">response_list = grequests.map(request_list,size=<span class="number">5</span>) <span class="comment">#size表示的协程池内协程数量</span></span><br><span class="line">print(response_list)</span><br></pre></td></tr></table></figure>

<h3 id="Twisted-模块"><a href="#Twisted-模块" class="headerlink" title="Twisted 模块"></a>Twisted 模块</h3><p>不是python的内置模块，所以需要安装 <code>pip install twisted</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.web.client <span class="keyword">import</span> getPage,defer</span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_done</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="string">"""每下载完一个页面就执行这个函数"""</span></span><br><span class="line">    print(arg)</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_done</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="string">"""所有页面下载完后执行这个函数"""</span></span><br><span class="line">    print(<span class="string">'done'</span>)</span><br><span class="line">    reactor.stop() <span class="comment"># 全部请求处理完后，终止循环</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">@defer.inlineCallbacks    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(url)</span>:</span></span><br><span class="line">    res = getPage(bytes(url,encoding=<span class="string">'utf-8'</span>))  <span class="comment"># 发送http请求</span></span><br><span class="line">    res.addCallback(one_done)  <span class="comment"># 添加回调函数，每下载完成一个页面后执行onde_done回调函数</span></span><br><span class="line">    <span class="keyword">yield</span> res</span><br><span class="line"></span><br><span class="line">url_list = [<span class="string">'http://deehuang.github.io/'</span>,</span><br><span class="line">            <span class="string">'http://www.baidu.com/'</span>]</span><br><span class="line"></span><br><span class="line">defer_list = []  <span class="comment"># 放的是已经向url发送请求的对象</span></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    v = task(url) <span class="comment"># 执行task函数，因为有defer_inlineCallbacks装饰器，当我们执行到getPage()后会立即返回!即把请求发过去不等请求回来,实现并发发请求。返回已经向url发送请求的对象</span></span><br><span class="line">    defer_list.append(v)   </span><br><span class="line">d = defer.DeferredList(defer_list)  <span class="comment"># 把已经向url发送请求的对象列表放到该特殊对象中</span></span><br><span class="line">d.addBoth(all_done)</span><br><span class="line"></span><br><span class="line">reactor.run() <span class="comment"># 这是一个死循环，它会“一直”去DeferredList中监听所有的请求状态，如某一请求返回后接着从原来返回的函数往下执行（该实例中每个请求返回后去执行one_done）。所有请求处理完后触发d.addBoth中添加的回调函数，即all_done，实现异步操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求全部处理完后，reacotor.run还是会傻傻的一直循环，要终止循环我们需要在all_done中去终止循环，</span></span><br></pre></td></tr></table></figure>

<p>上面例子中的<code>reactor.run()</code>死循环，我们有一个专业的名词叫做<strong>“事件循环”</strong><br>这个事件循环的作用就是帮助我们监测咱们发出去的<u>请求</u>，看它是否又没返回。<br>所以我们在使用所有的异步IO框架的时候要有一个概念：通过事件循环去监听每个请求的返回状态，当每个请求返回后通过回调执行相应的方法。所有的请求都返回处理完后，需要把整个事件循环终止掉！</p>
<p>PS: scrapy异步IO请求的实现是基于Twisted来完成的</p>
<h3 id="Tornado-模块"><a href="#Tornado-模块" class="headerlink" title="Tornado 模块"></a>Tornado 模块</h3><p>Tornado框架的异步功能用来做异步IO请求模块也是相当不错的，它的用法和Twisted十分相似。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> HTTPRequest</span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">0</span> <span class="comment"># 计数器，用于中止IO循环</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_response</span><span class="params">(response)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理返回值内容（需要维护计数器，来停止IO循环），调用 ioloop.IOLoop.current().stop()</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">global</span> COUNT</span><br><span class="line">    COUNT -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> response.error:</span><br><span class="line">        print(<span class="string">"Error:"</span>, response.error)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(response.body)</span><br><span class="line">	<span class="keyword">if</span> COUNT = <span class="number">0</span>: <span class="comment"># 终止事件循环</span></span><br><span class="line">        ioloop.IOLoop.current().stop()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">'http://www.baidu.com'</span>,</span><br><span class="line">        <span class="string">'http://www.bing.com'</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">global</span> COUNT</span><br><span class="line">    COUNT = len(url_list)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">        print(url)</span><br><span class="line">        http_client = AsyncHTTPClient() </span><br><span class="line">        http_client.fetch(HTTPRequest(url), handle_response) <span class="comment"># handle_response是回调函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ioloop.IOLoop.current().add_callback(func) <span class="comment"># </span></span><br><span class="line">ioloop.IOLoop.current().start()  <span class="comment"># 死循环  ---&gt; 事件循环</span></span><br></pre></td></tr></table></figure>

<p><em>Tornado</em>不像<em>Twisted</em>一样内部自动的维护一个计算器。每次计算我们要发送请求的数量（<code>url_list中的数量</code>），请求返回执行回调函数后该计数器自动减1。当计数器为0时应该终止事件循环函数<code>ioloop.IOLoop.current().stop()</code>。这个计数器在<em>Tornado</em>中需要我们手动的去设计<br>  而<em>Twisted</em>已经内部帮我们把计数器封装好了，当计数器值为0时在内部触发add.Both()添加的回调函数。</p>
<hr>
<p>对于上面的异步IO请求模块使用的优先级，我个人认为是这样的：<br>gevent &gt; Twisted &gt; Tornado &gt; asyncio  (这个比较标准纯粹是怎么方便怎么用…..)</p>
<h3 id="自定义异步IO模块"><a href="#自定义异步IO模块" class="headerlink" title="自定义异步IO模块"></a>自定义异步IO模块</h3><p>这些内置或第三方的异步IO请求模块，在日常生活中我们作为一个”<u>使用者</u>“掌握怎么去使用就足够了。对于内部很多细节的实现我们基本不用去深究。但是，作为一个充满好奇心的小白当然是不满足的！下面将摸索一下异步IO请求的底层原理及实现，以一个（小白）“<u>开发者</u>”的角度自己去写一个异步IO模块！</p>
<p>要自定义异步IO模块，我们首先要理解一些前戏：</p>
<h4 id="非阻塞socket"><a href="#非阻塞socket" class="headerlink" title="非阻塞socket"></a>非阻塞socket</h4><p>我们先来由浅入深的来看看一个Http请求的本质。我们知道HTTP是建立在TCP之上的协议，所以我们先来从讨论下sorket。<br>sorket有客户端和服务端。所有的web网站都是服务端，而我们的浏览器属于客户端。 </p>
<p>如图我们写了一个URL，回键一敲！ </p>
<p><img alt data-src="/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/2.jpg" class="lozad"><br>这就往这个URL地址发送了一个请求，它本质上就是把一些规定好格式的字符串通过<code>socket.sent(&quot;我是http数据包&quot;)</code>发到服务端去了。</p>
<p>上面的过程中，浏览器帮我做了两件事：1.创建socket对象与服务器连接。2.往url地址发送请求。<br>其实这里边有两个io操作，首先是建立“<u>连接</u>”，然后是“<u>发送</u>”数据。这两个过程都是比较耗时的。默认情况下“连接”和“发送”或者“接收数据”的时候是会<u>阻塞</u>住的，如果我们想让它不<u>阻塞</u>，我们可以在创建sorket的时候设置<code>setblocking(Fasle)</code>，要注意的一点是，不阻塞的情况下，程序无数据（连接无响应，数据未返回）就会报错（可以用异常处理来解决）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line"><span class="comment"># 设置非阻塞</span></span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 此时所有的socket操作都不会阻塞</span></span><br><span class="line"><span class="comment"># 设置了非阻塞后，客户端发送连接请求不会等待服务端响应就直接往下走</span></span><br></pre></td></tr></table></figure>

<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>上述在使用无阻塞socket时，我们说可以使用异常处理去处理无数据（连接无响应，数据未返回）的地方。异常处理的作用只能忽略、也可以说是跳过了它们。可是我们是希望在遇到IO阻塞的地方能不阻塞去执行别的任务，等阻塞的地方<strong>返回响应时</strong>，我们能<strong>马上发现</strong>并再去做<strong>相应的处理</strong>。</p>
<p>那么怎么使得阻塞的地方返回响应时我们能马上做相应处理呢？我们可以整一个死循环，去不断地监测多个socket对象。当某一socket对象有变化时（建立连接成功或接收到数据）,我们立即把这个socket对象拿出来做相应的处理。<br>上面这一想法有一个专业的术语，叫做<strong>Io多路复用</strong>，它的意思是“<strong>单个线程</strong>，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流” 。<br>不明白？从字面上理解就是多路网络复用一个io线程<br>不明白？我所理解的大白话就是用一个线程去监听多个socket对象的状态改变！<br>还不明白？看下图：</p>
<p><img alt data-src="/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/3.jpg" class="lozad"></p>
<p>图中可以明白：在同一个线程里面， 通过拨开关的方式，来同时传输多个I/O流 。现在市面上使用的io多路复用模块有<em>select</em>,<em>poll</em>和<em>epoll</em>。它们三个都是IO多路复用的具体的实现。<br>头脑风暴：你有N个不知道什么时候来水的水龙头需要接水，你根据某种信号一会儿拧这个龙头，一会儿拧那个龙头把水都接了就是多路复用（一个线程）。使用残像拳在每个水龙头前派一个你的分身蹲守就是Threaded IO（多线程）。其实后者也没啥不好，因为未来的内核会消除上下文切换的软硬件性能损耗<br>更多内容理解内容可以参考<a href="https://www.zhihu.com/question/32163005" target="_blank" rel="noopener">这里</a></p>
<p>这里我们只从客户端的角度去实现无阻塞socket+io多路复用的使用（这里使用的是python中io多路复用模块select模块的）。再次重复一下：使用IO多路复用模块的作用是帮助我们循环去监听哪个sock发送了变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这里的代码不可使用，主要是帮助理解</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">server = socket.socket()</span><br><span class="line"><span class="comment"># 设置非阻塞</span></span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    socket对象<span class="number">1.</span>connet()</span><br><span class="line">    socket对象<span class="number">2.</span>connet()</span><br><span class="line">    socket对象<span class="number">3.</span>connet()  <span class="comment"># 无阻塞，程序直接往下走，无数据报错</span></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">	<span class="keyword">pass</span>   <span class="comment"># 捕捉无数据异常</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    r,w,e = select.select([socket对象<span class="number">1</span>，socket对象<span class="number">2</span>，socket对象<span class="number">3</span>],</span><br><span class="line">                          [socket对象<span class="number">1</span>，socket对象<span class="number">2</span>，socket对象<span class="number">3</span>],</span><br><span class="line">                          [],</span><br><span class="line">                          <span class="number">0.05</span>)</span><br><span class="line"><span class="comment"># r 表示有人给我发数据，即当有数据发送过来后，就会把该socket对象放到r中：此时可以通过socket对象.recv去接收数据了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># w 表示我已经和别人创建连接成功，即当连接创建完成后（三次握手），就会把该socket对象放在w中：此时可以通过socket对象.sent('我是Http数据包')发送http请求了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#e 表示socket内部发生异常就会把该socket对象放在e中</span></span><br></pre></td></tr></table></figure>

<p>拓展：<code>r,w,e = select.select([],[],[],0.05)</code>里面的[]参数中，不仅可以放<em>socket</em>对象，只要一个对象提供<code>fileno</code>方法，并返回一个文件描述符，就可以被<em>select</em>监听!</p>
<p>所以<em>select</em>内部监听的其实是对象下的<code>fileno()</code>方法返回的文件描述符。<br>即我们自己写一个类，类中封装一个<code>fileno()</code>方法，因为我们没办法自己写文件描述符，所以我们直接调用socket对象的文件描述<code>socket().fileno()</code>在我们方法的最后返回。那么我们自定义的对象就可以放到<em>select</em>中去被监听！</p>
<p><img alt="select监听自定义对象" data-src="/2019/10/25/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/4.jpg" class="lozad"></p>
<h4 id="自定义异步IO模块开发"><a href="#自定义异步IO模块开发" class="headerlink" title="自定义异步IO模块开发"></a>自定义异步IO模块开发</h4><p>有了上面的前戏，我们不难理解 异步IO请求的本质则是【非阻塞Socket】+【IO多路复用】！<br>异步IO请求的本质则是【非阻塞Socket】+【IO多路复用】 ！<br>异步IO请求的本质则是【非阻塞Socket】+【IO多路复用】 ！ (重要的事情说三遍!!!)</p>
<p>​        </p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程    </a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/">多进程    </a><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5IO/">异步IO    </a><a class="post-meta__tags" href="/tags/python%E7%88%AC%E8%99%AB%E6%80%A7%E8%83%BD/">python爬虫性能    </a></div><div class="post_share"><div class="social-share" data-image="/img/topimg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/10/24/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%8E%92%E5%9D%91/"><img class="next_cover lozad" data-src="/img/cover_default3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>hexo上传图片小坑</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzI1MC8yMzc1MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer style="background-image: url(/img/topimg.jpg)"><div id="footer"><div class="copyright">&copy;2019 By Rhubarb C</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script color="0,0,255" opacity="0.7" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>