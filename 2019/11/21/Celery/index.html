<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Celery | RhubarbC的博客</title><meta name="description" content="关于分布式任务队列celery的个人学习心得！"><meta name="keywords" content="python,分布式任务队列,celery"><meta name="author" content="Rhubarb C"><meta name="copyright" content="Rhubarb C"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/11/21/Celery/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Celery"><meta name="twitter:description" content="关于分布式任务队列celery的个人学习心得！"><meta name="twitter:image" content="http://yoursite.com/img/cover_default2.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Celery"><meta property="og:url" content="http://yoursite.com/2019/11/21/Celery/"><meta property="og:site_name" content="RhubarbC的博客"><meta property="og:description" content="关于分布式任务队列celery的个人学习心得！"><meta property="og:image" content="http://yoursite.com/img/cover_default2.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="JavaSE基础篇" href="http://yoursite.com/2019/11/23/Java%E5%85%A5%E9%97%A8/"><link rel="next" title="缓存数据库Redis" href="http://yoursite.com/2019/11/21/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93Redis/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://deehuang.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: Rhubarb C","link":"链接: http://yoursite.com/2019/11/21/Celery/","source":"来源: RhubarbC的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">RhubarbC的博客</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#什么是celery"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">什么是celery</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#celery的基本使用"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">celery的基本使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#安装"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">安装</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#基本使用"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">基本使用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#celery在项目中的使用"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">celery在项目中的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#celery定时任务"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">celery定时任务</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#结语"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">结语</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是celery"><span class="toc-number">1.</span> <span class="toc-text">什么是celery</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#celery的基本使用"><span class="toc-number">2.</span> <span class="toc-text">celery的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装"><span class="toc-number">2.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本使用"><span class="toc-number">2.2.</span> <span class="toc-text">基本使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#celery在项目中的使用"><span class="toc-number">3.</span> <span class="toc-text">celery在项目中的使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#celery定时任务"><span class="toc-number">4.</span> <span class="toc-text">celery定时任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结语"><span class="toc-number">5.</span> <span class="toc-text">结语</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/cover_default2.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Celery</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-21<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-23</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python/">python</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2k</span><span class="post-meta__separator">|</span><span>阅读时长: 7 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="什么是celery"><a href="#什么是celery" class="headerlink" title="什么是celery"></a>什么是celery</h1><p>Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理， 如果你的业务场景中需要用到异步任务，就可以考虑使用celery 。</p>
<p>它有什么用？<br>如果有一个任务在一台机器上处理要花上十分钟，那如果我们把这个任务分成几个小任务放到几个机器上去处理，然后再把小任务归总那这样处理的效率就大大增加了。<br>上述说的把任务分成几个小任务进行处理再归总的方式就是常听到的分布式任务运算。而celery就是可以帮助我们实现分布式的任务运算。<br>除了进行分布式任务运算，celery还能进行异步的任务处理：</p>
<ul>
<li><p>你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回 一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果， 在任务执行ing进行时，你可以继续做其它的事情。 </p>
</li>
<li><p>你想做一个定时任务，比如每天检测一下你们所有客户的资料，如果发现今天 是客户的生日，就给他发个短信祝福</p>
</li>
</ul>
<p><strong>Celery有以下优点：</strong></p>
<ol>
<li>简单：一单熟悉了celery的工作流程后，配置和使用还是比较简单的</li>
<li>高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务</li>
<li>快速：一个单进程的celery每分钟可处理上百万个任务</li>
<li>灵活： 几乎celery的各个组件都可以被扩展及自定制</li>
</ol>
<h1 id="celery的基本使用"><a href="#celery的基本使用" class="headerlink" title="celery的基本使用"></a>celery的基本使用</h1><p>celery基本工作流程图</p>
<p><img alt data-src="/2019/11/21/Celery/1.jpg" class="lozad"></p>
<p>userapp就是负责发布任务消息，worker负责根据接收到的消息去执行任务，而消息发送接收的和任务执行结果的存储由broker负责</p>
<p>Celery 在执行任务时需要通过一个消息中间件（broker）来接收和发送任务消息，以及存储任务结果， 一般使用rabbitMQ 或 Redis</p>
<p>Celery之所以能异步处理，是因为app发送的任务到队列后会返回一个task id。过一段时间只需要拿着这个任务id就可以拿到任务执行结果。但是实际上app并非直接发送任务到RabbitMQ或redis中，因为RabbitMQ和Redis并没有返回给app信息的功能。所以任务实际上是先发到celery的某个组件，这个组件再把任务发到消息队列中然后给app返回一个任务id。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p> Celery的默认broker是RabbitMQ, 仅需配置一行就可以 </p>
<p>安装celery模块：<br><code>pip install celery</code> </p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p> <strong>创建一个celery application用来定义你的任务列表</strong> </p>
<p> 创建一个任务文件，这里叫celery_test.py </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"> </span><br><span class="line">app = Celery(<span class="string">'tasks'</span>,  <span class="comment">#app的名字</span></span><br><span class="line">             broker=<span class="string">'redis://:password@localhost'</span>,    <span class="comment">#连接本机的redis</span></span><br><span class="line">             backend=<span class="string">'redis://:password@localhost'</span>)  <span class="comment">#任务执行的结果存储队列,这里也用redis</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="string">"""这是worker可以执行的一个任务"""</span></span><br><span class="line">    print(<span class="string">"running..."</span>,x,y)</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure>

<p><strong>启动Celery Worker来开始监听并执行任务 ：</strong><br>打开worker终端执行：  <code>celery -A 模块名(不加.py) 角色</code><br>如：<code>celery -A celery_test worker -l info</code></p>
<p><strong>调用任务</strong><br>再打开一个终端， 进行命令行模式，调用任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$python</span><br><span class="line">&gt;&gt;&gt;from celery_test import add   </span><br><span class="line">&gt;&gt;&gt;add.delay(4, 4)  #把任务交给远程worker执行</span><br></pre></td></tr></table></figure>

<p> 看你的worker终端会显示收到 一个任务，此时你想看任务结果的话，需要在调用 任务时　赋值个变量<br><code>result = add.delay(4, 4) #把任务交给远程worker执行</code><br><code>result.get() #拿到执行结果</code> </p>
<p><em>ps:如果有多个worker的话会抢app发送的任务消息去执行任务，而不是平均分的形式！</em></p>
<p>如果任务没有处理完，而我们又调用了<code>result.get()</code>那么进程就会阻塞住直到任务结果返回。这显然不是我们想要的，我们可以给get方法设置超时时间，就可以解决阻塞的问题：<br><code>result.get(timeout=1)</code>如果结果一秒内没有返回，则抛出任务没有执行完成的异常！<br>如果我们不想让它抛出异常可以使用<code>result.ready()</code>方法来判断任务是否有没执行完。待返回True再去取就好了</p>
<h1 id="celery在项目中的使用"><a href="#celery在项目中的使用" class="headerlink" title="celery在项目中的使用"></a>celery在项目中的使用</h1><p>可以把celery配置成一个应用</p>
<p>目录格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proj/__init__.py</span><br><span class="line">    /celery.py</span><br><span class="line">    /tasks.py</span><br></pre></td></tr></table></figure>

<p>proj/celery.py内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置默认首先从python包里导入模块（不设置的话默认会先从当前文件的执行目录下先找）</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals </span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"> </span><br><span class="line">app = Celery(<span class="string">'proj'</span>,</span><br><span class="line">             broker=<span class="string">'redis://:password@localhost'</span>, </span><br><span class="line">             backend=<span class="string">'redis://:password@localhost'</span>, <span class="comment">#任务执行结果存储后台</span></span><br><span class="line">             include=[<span class="string">'proj.tasks'</span>])  <span class="comment">#要执行的任务文件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Optional configuration, see the application app guide.</span></span><br><span class="line">app.conf.update(</span><br><span class="line">    result_expires=<span class="number">3600</span>,   <span class="comment">#给app发送的任务消息设置生命周期，如果超时则把消息丢了</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.start()</span><br></pre></td></tr></table></figure>

<p>proj/tasks.py中的内容（放要执行的任务）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xsum</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(numbers)</span><br></pre></td></tr></table></figure>

<p> <strong>启动worker</strong>：回到proj的上级目录执行命令<br><code>$ celery -A proj worker -l info</code></p>
<p>上面的worker启动方式会阻塞住进程，一直在监听celery的boker中的任务消息。如果我们想要进程不阻塞，让worker在后台启动的话可以使用下面的方法：</p>
<p><code>$ celery multi start w1 -A proj -l info</code>   #multi是后台启动worker的命令，它支持启动多个worker，但是需要给worker配置名字让后台能分辨管理，所以w1就是该worker的名字<br>关闭后台worker <code>celery multi stop w1 -A proj -l info</code> 如果后台的任务还没有执行完的话也会强制关闭<br>为了确保后台的任务执行完毕再关闭worker可以使用命令：<code>celery multi stopwait w1 -A proj -l info</code></p>
<p><strong>分布任务</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> proj <span class="keyword">import</span> tasks</span><br><span class="line"></span><br><span class="line">t1 = tasks.add.delay(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">t2 = tasks.mul.dealy(<span class="number">8</span>,<span class="number">8</span>)</span><br><span class="line">t3 = tasks.xsum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">t1.get()</span><br><span class="line">t2.get()</span><br><span class="line">t3.get()</span><br></pre></td></tr></table></figure>

<h1 id="celery定时任务"><a href="#celery定时任务" class="headerlink" title="celery定时任务"></a>celery定时任务</h1><p>  celery支持定时任务，设定好任务的执行时间，celery就会定时自动帮你执行， 这个定时任务模块叫celery beat<br><img alt data-src="/2019/11/21/Celery/2.jpg" class="lozad"></p>
<p> 写一个脚本 叫periodic_task.py  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"> </span><br><span class="line">app = Celery(<span class="string">'periodic_task'</span>,</span><br><span class="line">             broker=<span class="string">'redis://:password@localhost'</span>, </span><br><span class="line">             backend=<span class="string">'redis://:password@localhost'</span>, <span class="comment">#任务执行结果存储后台</span></span><br><span class="line">             include=[<span class="string">'periodic_task'</span>])</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.on_after_configure.connect</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_periodic_tasks</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 每过10秒执行task函数  .s()是所要传的参数  name是任务名</span></span><br><span class="line">    sender.add_periodic_task(<span class="number">10.0</span>, test.s(<span class="string">'hello'</span>), name=<span class="string">'add every 10'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Calls test('world') every 30 seconds，expires是任务的结果保存10秒 </span></span><br><span class="line">    sender.add_periodic_task(<span class="number">30.0</span>, test.s(<span class="string">'world'</span>), expires=<span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Executes every Monday morning at 7:30 a.m.</span></span><br><span class="line">    sender.add_periodic_task(</span><br><span class="line">        crontab(hour=<span class="number">7</span>, minute=<span class="number">30</span>, day_of_week=<span class="number">1</span>),</span><br><span class="line">        test.s(<span class="string">'Happy Mondays!'</span>),</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(arg)</span><br></pre></td></tr></table></figure>

<p> add_periodic_task 会添加一条定时任务 </p>
<p> 上面是通过调用函数添加定时任务，也可以像写配置文件 一样的形式添加， 下面是每30s执行的任务 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.conf.beat_schedule = &#123;</span><br><span class="line">    <span class="string">'add-every-30-seconds'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">'tasks.add'</span>,</span><br><span class="line">        <span class="string">'schedule'</span>: <span class="number">30.0</span>,  <span class="comment">#'schedule': crontab(hour=7, minute=30, day_of_week=1)，</span></span><br><span class="line">        <span class="string">'args'</span>: (<span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">app.conf.timezone = <span class="string">'UTC'</span></span><br></pre></td></tr></table></figure>

<p> 任务添加好了，需要让celery单独启动一个进程来定时发起这些任务， 注意， 这里是发起任务，不是执行，这个进程只会不断的去检查你的任务计划， 每发现有任务需要执行了，就发起一个任务调用消息，交给celery worker去执行 </p>
<p> 启动任务调度器 celery beat :<br><code>$ celery -A periodic_task beat</code><br>还要启动worker去监听任务的发布并执行：<br><code>$  celery -A periodic_task worker</code></p>
<p>更复杂的定时配置：<br>crontab功能，跟<a href="http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html" target="_blank" rel="noopener">linux自带的crontab</a>功能是一样的，可以个性化定制任务执行时间！</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上是个人学习之路，如有误，欢迎指正！<a href="https://www.cnblogs.com/alex3714/p/6351797.html" target="_blank" rel="noopener">参考文献</a></p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python    </a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/">分布式任务队列    </a><a class="post-meta__tags" href="/tags/celery/">celery    </a></div><div class="post_share"><div class="social-share" data-image="/img/cover_default2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/11/23/Java%E5%85%A5%E9%97%A8/"><img class="prev_cover lozad" data-src="/img/cover_default2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>JavaSE基础篇</span></div></a></div><div class="next-post pull-right"><a href="/2019/11/21/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93Redis/"><img class="next_cover lozad" data-src="/img/cover_default3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>缓存数据库Redis</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/19/Tornado框架进阶/" title="Tornado框架进阶"><img class="relatedPosts_cover lozad"data-src="/img/tornado_cover.jpg"><div class="relatedPosts_title">Tornado框架进阶</div></a></div><div class="relatedPosts_item"><a href="/2019/11/16/Tornado框架入门/" title="Tornado框架入门"><img class="relatedPosts_cover lozad"data-src="/img/tornado_cover.jpg"><div class="relatedPosts_title">Tornado框架入门</div></a></div><div class="relatedPosts_item"><a href="/2019/11/21/缓存数据库Redis/" title="缓存数据库Redis"><img class="relatedPosts_cover lozad"data-src="/img/cover_default3.jpg"><div class="relatedPosts_title">缓存数据库Redis</div></a></div><div class="relatedPosts_item"><a href="/2019/11/18/WebSocket/" title="WebSocket"><img class="relatedPosts_cover lozad"data-src="/img/cover_default3.jpg"><div class="relatedPosts_title">WebSocket</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzI1MC8yMzc1MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer style="background-image: url(/img/cover_default2.jpg)"><div id="footer"><div class="copyright">&copy;2019 - 2020 By Rhubarb C</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script color="0,0,255" opacity="0.7" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>