<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>JavaSE之面向对象 | RhubarbC的博客</title><meta name="description" content="关于Java的个人学习之路！本文将介绍Java语言的最最最核心内容——“面向对象”的知识点！"><meta name="keywords" content="JavaSE,java,基础,面向对象"><meta name="author" content="Rhubarb C"><meta name="copyright" content="Rhubarb C"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="JavaSE之面向对象"><meta name="twitter:description" content="关于Java的个人学习之路！本文将介绍Java语言的最最最核心内容——“面向对象”的知识点！"><meta name="twitter:image" content="http://yoursite.com/img/cover_default3.jpg"><meta property="og:type" content="article"><meta property="og:title" content="JavaSE之面向对象"><meta property="og:url" content="http://yoursite.com/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><meta property="og:site_name" content="RhubarbC的博客"><meta property="og:description" content="关于Java的个人学习之路！本文将介绍Java语言的最最最核心内容——“面向对象”的知识点！"><meta property="og:image" content="http://yoursite.com/img/cover_default3.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="JavaSE之异常处理" href="http://yoursite.com/2019/12/24/JavaSE%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"><link rel="next" title="JavaSE基础篇" href="http://yoursite.com/2019/11/23/Java%E5%85%A5%E9%97%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://deehuang.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: Rhubarb C","link":"链接: http://yoursite.com/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","source":"来源: RhubarbC的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">RhubarbC的博客</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#面向对象思想概述"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">面向对象思想概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#类和对象"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">类和对象</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的结构"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">类的结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#对象"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">对象</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建类的对象："><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">创建类的对象：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类与多个对象的关系"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">类与多个对象的关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#对象的内存解析"><span class="toc_mobile_items-number">2.2.3.</span> <span class="toc_mobile_items-text">对象的内存解析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#拓展：对象数组和匿名对象的使用"><span class="toc_mobile_items-number">2.2.4.</span> <span class="toc_mobile_items-text">拓展：对象数组和匿名对象的使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#对象数组"><span class="toc_mobile_items-number">2.2.4.1.</span> <span class="toc_mobile_items-text">对象数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#匿名对象"><span class="toc_mobile_items-number">2.2.4.2.</span> <span class="toc_mobile_items-text">匿名对象</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#类的成员"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">类的成员</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的成员之一：属性"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">类的成员之一：属性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的成员之二：方法"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">类的成员之二：方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法的声明与使用"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">方法的声明与使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法的重载"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">方法的重载</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#可变个数的形参的方法"><span class="toc_mobile_items-number">3.2.3.</span> <span class="toc_mobile_items-text">可变个数的形参的方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法参数的值传递机制"><span class="toc_mobile_items-number">3.2.4.</span> <span class="toc_mobile_items-text">方法参数的值传递机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#递归方法"><span class="toc_mobile_items-number">3.2.5.</span> <span class="toc_mobile_items-text">递归方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#面向对象特性之一：封装性"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">面向对象特性之一：封装性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是封装与隐藏"><span class="toc_mobile_items-number">3.3.1.</span> <span class="toc_mobile_items-text">什么是封装与隐藏</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#四种权限修饰符"><span class="toc_mobile_items-number">3.3.2.</span> <span class="toc_mobile_items-text">四种权限修饰符</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的成员之三：构造器（或构造方法）"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">类的成员之三：构造器（或构造方法）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#构造器"><span class="toc_mobile_items-number">3.4.1.</span> <span class="toc_mobile_items-text">构造器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#属性的赋值过程"><span class="toc_mobile_items-number">3.4.2.</span> <span class="toc_mobile_items-text">属性的赋值过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#拓展：JavaBean和UML类图"><span class="toc_mobile_items-number">3.4.3.</span> <span class="toc_mobile_items-text">拓展：JavaBean和UML类图</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#JavaBean"><span class="toc_mobile_items-number">3.4.3.1.</span> <span class="toc_mobile_items-text">JavaBean</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#UML类图"><span class="toc_mobile_items-number">3.4.3.2.</span> <span class="toc_mobile_items-text">UML类图</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关键字：this的使用"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">关键字：this的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关键字：package、import的使用"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">关键字：package、import的使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#package"><span class="toc_mobile_items-number">3.6.1.</span> <span class="toc_mobile_items-text">package</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#包的使用与作用"><span class="toc_mobile_items-number">3.6.1.1.</span> <span class="toc_mobile_items-text">包的使用与作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#MVC设计模式"><span class="toc_mobile_items-number">3.6.1.2.</span> <span class="toc_mobile_items-text">MVC设计模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#import"><span class="toc_mobile_items-number">3.6.2.</span> <span class="toc_mobile_items-text">import</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#面向对象三大特性"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">面向对象三大特性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#面向对象特性之二：继承性"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">面向对象特性之二：继承性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#继承性"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">继承性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#继承的作用"><span class="toc_mobile_items-number">4.1.2.</span> <span class="toc_mobile_items-text">继承的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#继承性的使用"><span class="toc_mobile_items-number">4.1.3.</span> <span class="toc_mobile_items-text">继承性的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java关于继承性的规定："><span class="toc_mobile_items-number">4.1.4.</span> <span class="toc_mobile_items-text">Java关于继承性的规定：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#拓展：初探Object类"><span class="toc_mobile_items-number">4.1.5.</span> <span class="toc_mobile_items-text">拓展：初探Object类</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#方法的重写"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">方法的重写</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#再看4种权限修饰符"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">再看4种权限修饰符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关键字：super"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">关键字：super</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#super的使用"><span class="toc_mobile_items-number">4.4.1.</span> <span class="toc_mobile_items-text">super的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#子类对象实例化过程"><span class="toc_mobile_items-number">4.4.2.</span> <span class="toc_mobile_items-text">子类对象实例化过程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#面向对象特性之三：多态性"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">面向对象特性之三：多态性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多态性"><span class="toc_mobile_items-number">4.5.1.</span> <span class="toc_mobile_items-text">多态性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#虚拟方法调用"><span class="toc_mobile_items-number">4.5.2.</span> <span class="toc_mobile_items-text">虚拟方法调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#向下转型的使用"><span class="toc_mobile_items-number">4.5.3.</span> <span class="toc_mobile_items-text">向下转型的使用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Object类的使用"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">Object类的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#包装类-wrapper-的使用"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">包装类(wrapper)的使用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#其他关键字及类的成员补充"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">其他关键字及类的成员补充</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#static关键字"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">static关键字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#static关键字的使用"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">static关键字的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类变量和实例变量的内存解析"><span class="toc_mobile_items-number">5.1.2.</span> <span class="toc_mobile_items-text">类变量和实例变量的内存解析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#理解main（）方法的语法"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">理解main（）方法的语法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的成员之四：代码块"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">类的成员之四：代码块</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码块的使用"><span class="toc_mobile_items-number">5.3.1.</span> <span class="toc_mobile_items-text">代码块的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#属性赋值的先后顺序"><span class="toc_mobile_items-number">5.3.2.</span> <span class="toc_mobile_items-text">属性赋值的先后顺序</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关键字：final"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">关键字：final</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关键字：abstract—抽象类与方法"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text">关键字：abstract—抽象类与方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关键字：interface—接口"><span class="toc_mobile_items-number">5.6.</span> <span class="toc_mobile_items-text">关键字：interface—接口</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是接口"><span class="toc_mobile_items-number">5.6.1.</span> <span class="toc_mobile_items-text">什么是接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#接口的使用"><span class="toc_mobile_items-number">5.6.2.</span> <span class="toc_mobile_items-text">接口的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#抽象类和接口的区别"><span class="toc_mobile_items-number">5.6.3.</span> <span class="toc_mobile_items-text">抽象类和接口的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java8中接口的新特性"><span class="toc_mobile_items-number">5.6.4.</span> <span class="toc_mobile_items-text">Java8中接口的新特性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的成员之五：内部类"><span class="toc_mobile_items-number">5.7.</span> <span class="toc_mobile_items-text">类的成员之五：内部类</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象思想概述"><span class="toc-number">1.</span> <span class="toc-text">面向对象思想概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和对象"><span class="toc-number">2.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类的结构"><span class="toc-number">2.1.</span> <span class="toc-text">类的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-number">2.2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建类的对象："><span class="toc-number">2.2.1.</span> <span class="toc-text">创建类的对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类与多个对象的关系"><span class="toc-number">2.2.2.</span> <span class="toc-text">类与多个对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的内存解析"><span class="toc-number">2.2.3.</span> <span class="toc-text">对象的内存解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展：对象数组和匿名对象的使用"><span class="toc-number">2.2.4.</span> <span class="toc-text">拓展：对象数组和匿名对象的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对象数组"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名对象"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">匿名对象</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类的成员"><span class="toc-number">3.</span> <span class="toc-text">类的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类的成员之一：属性"><span class="toc-number">3.1.</span> <span class="toc-text">类的成员之一：属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的成员之二：方法"><span class="toc-number">3.2.</span> <span class="toc-text">类的成员之二：方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法的声明与使用"><span class="toc-number">3.2.1.</span> <span class="toc-text">方法的声明与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法的重载"><span class="toc-number">3.2.2.</span> <span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变个数的形参的方法"><span class="toc-number">3.2.3.</span> <span class="toc-text">可变个数的形参的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法参数的值传递机制"><span class="toc-number">3.2.4.</span> <span class="toc-text">方法参数的值传递机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归方法"><span class="toc-number">3.2.5.</span> <span class="toc-text">递归方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象特性之一：封装性"><span class="toc-number">3.3.</span> <span class="toc-text">面向对象特性之一：封装性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是封装与隐藏"><span class="toc-number">3.3.1.</span> <span class="toc-text">什么是封装与隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四种权限修饰符"><span class="toc-number">3.3.2.</span> <span class="toc-text">四种权限修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的成员之三：构造器（或构造方法）"><span class="toc-number">3.4.</span> <span class="toc-text">类的成员之三：构造器（或构造方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造器"><span class="toc-number">3.4.1.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性的赋值过程"><span class="toc-number">3.4.2.</span> <span class="toc-text">属性的赋值过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展：JavaBean和UML类图"><span class="toc-number">3.4.3.</span> <span class="toc-text">拓展：JavaBean和UML类图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaBean"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML类图"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">UML类图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字：this的使用"><span class="toc-number">3.5.</span> <span class="toc-text">关键字：this的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字：package、import的使用"><span class="toc-number">3.6.</span> <span class="toc-text">关键字：package、import的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#package"><span class="toc-number">3.6.1.</span> <span class="toc-text">package</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#包的使用与作用"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">包的使用与作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC设计模式"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">MVC设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-number">3.6.2.</span> <span class="toc-text">import</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象三大特性"><span class="toc-number">4.</span> <span class="toc-text">面向对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象特性之二：继承性"><span class="toc-number">4.1.</span> <span class="toc-text">面向对象特性之二：继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承性"><span class="toc-number">4.1.1.</span> <span class="toc-text">继承性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承的作用"><span class="toc-number">4.1.2.</span> <span class="toc-text">继承的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承性的使用"><span class="toc-number">4.1.3.</span> <span class="toc-text">继承性的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java关于继承性的规定："><span class="toc-number">4.1.4.</span> <span class="toc-text">Java关于继承性的规定：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展：初探Object类"><span class="toc-number">4.1.5.</span> <span class="toc-text">拓展：初探Object类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法的重写"><span class="toc-number">4.2.</span> <span class="toc-text">方法的重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#再看4种权限修饰符"><span class="toc-number">4.3.</span> <span class="toc-text">再看4种权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字：super"><span class="toc-number">4.4.</span> <span class="toc-text">关键字：super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super的使用"><span class="toc-number">4.4.1.</span> <span class="toc-text">super的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子类对象实例化过程"><span class="toc-number">4.4.2.</span> <span class="toc-text">子类对象实例化过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象特性之三：多态性"><span class="toc-number">4.5.</span> <span class="toc-text">面向对象特性之三：多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多态性"><span class="toc-number">4.5.1.</span> <span class="toc-text">多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟方法调用"><span class="toc-number">4.5.2.</span> <span class="toc-text">虚拟方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向下转型的使用"><span class="toc-number">4.5.3.</span> <span class="toc-text">向下转型的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object类的使用"><span class="toc-number">4.6.</span> <span class="toc-text">Object类的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包装类-wrapper-的使用"><span class="toc-number">4.7.</span> <span class="toc-text">包装类(wrapper)的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他关键字及类的成员补充"><span class="toc-number">5.</span> <span class="toc-text">其他关键字及类的成员补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#static关键字"><span class="toc-number">5.1.</span> <span class="toc-text">static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static关键字的使用"><span class="toc-number">5.1.1.</span> <span class="toc-text">static关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类变量和实例变量的内存解析"><span class="toc-number">5.1.2.</span> <span class="toc-text">类变量和实例变量的内存解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解main（）方法的语法"><span class="toc-number">5.2.</span> <span class="toc-text">理解main（）方法的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的成员之四：代码块"><span class="toc-number">5.3.</span> <span class="toc-text">类的成员之四：代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码块的使用"><span class="toc-number">5.3.1.</span> <span class="toc-text">代码块的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性赋值的先后顺序"><span class="toc-number">5.3.2.</span> <span class="toc-text">属性赋值的先后顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字：final"><span class="toc-number">5.4.</span> <span class="toc-text">关键字：final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字：abstract—抽象类与方法"><span class="toc-number">5.5.</span> <span class="toc-text">关键字：abstract—抽象类与方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字：interface—接口"><span class="toc-number">5.6.</span> <span class="toc-text">关键字：interface—接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是接口"><span class="toc-number">5.6.1.</span> <span class="toc-text">什么是接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口的使用"><span class="toc-number">5.6.2.</span> <span class="toc-text">接口的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类和接口的区别"><span class="toc-number">5.6.3.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8中接口的新特性"><span class="toc-number">5.6.4.</span> <span class="toc-text">Java8中接口的新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的成员之五：内部类"><span class="toc-number">5.7.</span> <span class="toc-text">类的成员之五：内部类</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/cover_default3.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">JavaSE之面向对象</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-25<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-25</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/JavaSE/">JavaSE</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">34.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 120 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p><strong>写在前面：</strong></p>
<p>Java是面向对象的语言，面向对象也是java最最最重要的内容，可以说无对象不java。而面向对象的知识点其实是十分之多且繁杂的。为了避免学习的时候摸不着东西南北，所以在学习之前我们应该先在脑海中理清一些学习主线。<br>本篇把Java面向对象的学习主要分成三条主线，每条主线包含的内容如下：</p>
<ol>
<li>Java类及类的成员：属性、方法、构造器；代码块、内部类</li>
<li>面向对象的三大特征：封装性、继承性、多态性、（抽象性）</li>
<li>其他关键字：this、super、static、final、abstract、interface、package、import等（上面两条主线的内容已经涉及了一些关键字的使用，这条主线主要是学习一些其他关键字的使用）</li>
</ol>
<p>本文并非是按串行的方式把三条主线的内容介绍，而是并行的方式去介绍这些内容，因为他们彼此之间是有许多关系的（就是说在学习中这些主线中的内容会相互有所杂糅）。列出学习主线只是把面向对象的知识点在脑海中树立起一个框架，把知识点归类起来，而不会感觉这学一点那学一点最终整个人是懵的！如果在下面的学习中感觉有点懵，请和我一起回来再看看这个学习主线！你就知道自己在面向对象中已经掌握了什么知识了！</p>
<p>可能有人会问？你说说什么是面向对象编程的思想？其实思想是一个挺虚无缥缈的东西。我们重点在这里主要关注的是思想的体现，编程思想的体现就是落实到代码设计（你的代码是怎么写的，把想法落实到代码中这就是编程思想的体现），所以本文主要以代码去落实面向对象编程的知识（把代码整明白了就会渐悟理解面向对象的思想到底是做什么的），而非纸上谈兵只是空谈思想！所以在学习中如果跟我一样对概念的东西感觉无法消化，不要纠结~代码敲起来吧！</p>
<h1 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h1><p>高级语言有两个过渡的阶段，一个是面向过程，一个是面对对象，来让我们看下他们的区别：</p>
<p><strong>面向过程(POP)与面向对象(OOP)</strong> </p>
<ul>
<li>二者都是一种<strong>思想</strong>，面向对象是相对于面向过程而言的。<br>面向过程，强调的是<u>功能行为，以<strong>函数</strong>为最小单位，考虑怎么做</u>。<br>面向对象，将功能封装进对象，<u>强调具备了功能的对象，以<strong>类/对象</strong>为最小单位，考虑谁来做</u>。</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。 </li>
</ul>
<p>有些童鞋看了这段是不是想吐槽:这又画下划线的又把字体加粗就能让人懂了吗?让我举起我的栗子！(简单体会一下，不用太纠结!)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"人把大象装进冰箱" 用面向过程的思想去设计和面向对象的思想去设计：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</span></span><br><span class="line"><span class="comment"> 1）把冰箱门打开</span></span><br><span class="line"><span class="comment"> 2）抬起大象，塞进冰箱</span></span><br><span class="line"><span class="comment"> 3）把冰箱门关闭</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。（就是把功能封装到主体中，可以把名词做成类，把动词做成方法放到类中进行刻画，这里使用主体&#123;功能&#125;的形式去表述）:</span></span><br><span class="line"><span class="comment">  人&#123;</span></span><br><span class="line"><span class="comment">  		打开(冰箱)&#123;</span></span><br><span class="line"><span class="comment">  			冰箱.打开();</span></span><br><span class="line"><span class="comment">  		&#125;</span></span><br><span class="line"><span class="comment">  		</span></span><br><span class="line"><span class="comment">  		抬起(大象)&#123;</span></span><br><span class="line"><span class="comment">  			大象.进入(冰箱);</span></span><br><span class="line"><span class="comment">  		&#125;</span></span><br><span class="line"><span class="comment">  		</span></span><br><span class="line"><span class="comment">  		关闭(冰箱)&#123;</span></span><br><span class="line"><span class="comment">  			冰箱.闭合();</span></span><br><span class="line"><span class="comment">  		&#125;</span></span><br><span class="line"><span class="comment">  		</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  冰箱&#123;</span></span><br><span class="line"><span class="comment">  		打开()&#123;&#125;</span></span><br><span class="line"><span class="comment">  		闭合()&#123;&#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  大象&#123;</span></span><br><span class="line"><span class="comment">  		进入(冰箱)&#123;&#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了</span></span><br><span class="line"><span class="comment">	面向对象是把构成问题事物分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	面向过程像是人自己去做事情，把事情按步骤慢慢去完成</span></span><br><span class="line"><span class="comment">	而面向过程像是上帝视角去指导人去做事情，什么人能解决这个问题就让这个人做，没人能做就造人去做。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>其实我觉得面向过程到面向对象的过度可以理解为一个企业发展的过程：一开始的时候公司就几个人，这几个人不会明显分工各自做什么事，有任务来了就一起去做，这样会高效一些，这就是面向过程的思想。<br>当企业发展壮大上千上百人的时候，如果还是面向过程的做事情而不给这群人划分一下部门和职责的话那就显得特别混乱了，此时把公司分为几个部门如市场部、开发组、财务部（分类）等等给每个部门设计自己的部门职责和制度（部门的属性和功能），每个部门各司其职相互帮助。如果某个任务需要加一些别的功能需求，只需要在特定的部门添加上这些功能就完事了。这样整体就看上去非常的清晰、干净有流程了，这就是面向对象的设计思想</p>
<p>用面向对象的思想完成一个项目（或功能的思路）：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.jpg" class="lozad"></p>
<p><strong>面向对象的三大特征：</strong></p>
<ul>
<li>封装 (Encapsulation) </li>
<li>继承 (Inheritance) </li>
<li>多态 (Polymorphism) </li>
</ul>
<p><strong>面向对象有两个要素</strong>：类和对象，它们是面向对象的核心概念，核心概念，核心概念！</p>
<p>下面我们正式的进入面向对象的学习。</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>面向对象思想的体现之一就是类和对象的使用：</p>
<p>类和对象的使用其实就是面向对象思想落地的实现，它大体上分成三步</p>
<ol>
<li><p><strong>创建类，设计类的成员（重点）</strong></p>
</li>
<li><p>创建类的对象</p>
</li>
<li><p>通过“对象.属性” 或 “对象.方法”调用对象的结构</p>
</li>
</ol>
<p><strong>类</strong>：对一类事物的描述，是抽象的、概念上的定义</p>
<p><strong>对象</strong>：是实际存在的该类事物的每个个体，因而也称为实例(instance)</p>
<ul>
<li><p>面向对象程序设计的重点是类的设计</p>
<ul>
<li>设计类，就是设计类的成员。</li>
</ul>
</li>
</ul>
<p>通过下面的图应该很容易理解：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.jpg" class="lozad"></p>
<p><strong>简单理解类和对象与类和对象的关系：</strong></p>
<ul>
<li>类：抽象的、概念上的内容</li>
<li>对象：实实在在的一个个体（在java程序中的体现就是new出来的东西，在内存中是真正的创建这个对象并占据了一定的内存空间）</li>
<li>对象是由类派生出来的（new出来的）</li>
</ul>
<p><strong>理解：万事万物皆对象！（面试装逼技能）</strong></p>
<p>实际上完整的表述是万事万物皆是类的对象！</p>
<ol>
<li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构，如：<ul>
<li>Scanner,String等</li>
<li>文件：File</li>
<li>网络资源：URL</li>
</ul>
</li>
<li>涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</li>
</ol>
<h2 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h2><p>上面简单理解了类，那么java中创建类的语法格式是什么？</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.jpg" class="lozad"></p>
<p>知道类是怎么回事后，接下来了解下类的成员：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.jpg" class="lozad"></p>
<p>实际上，设计类，其实就是<strong>设计类的成员</strong>。类的成员除了有属性和方法外还有构造器；代码块、内部类。这里我们主要先简单讲讲常用到的类的成员：属性和方法。后面的内容中需要用到其他成员变量的时候我们再慢慢引入！循序渐进的去学习！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.jpg" class="lozad"></p>
<p>生活中描述事务无非就是描述事物的属性和行为。如：人有身高，体重等属性，有说话，游泳等行为。</p>
<p>属性和方法在现实中有许多种叫法，我们在这里做个统一化：</p>
<ul>
<li>属性 = 成员变量 = field = 域、字段</li>
<li>方法 = 成员方法 = 函数 = method</li>
</ul>
<p>老规矩，我们尽量把东西放到代码去说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、设计类，其实就是设计类的成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  属性 = 成员变量 = field = 域、字段</span></span><br><span class="line"><span class="comment"> *  方法 = 成员方法 = 函数 = method </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age =<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：具备的一些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"说话，使用的是"</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>类可以比作是一张设计的图纸，在上面我们设计了人类及它的成员变量即设计好了一个类，但是这个类只是个图纸写着这是个什么东西有什么功能而已，如果不去使用它，即按图纸创建制造东西那这个类就显得毫无意义。</p>
<p>那么怎么去使用java类呢？<br>使用java类其实就是创建一个个具体的对象去做事情。而我们把创建类的对象这个过程就叫做<strong>类的实例化或实例化类过程</strong></p>
<h3 id="创建类的对象："><a href="#创建类的对象：" class="headerlink" title="创建类的对象："></a>创建类的对象：</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.jpg" class="lozad"></p>
<p>还是用上面人类的例子，代码说话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、设计类，其实就是设计类的成员</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  属性 = 成员变量 = field = 域、字段</span></span><br><span class="line"><span class="comment"> *  方法 = 成员方法 = 函数 = method </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  创建类的对象 = 类的实例化 = 实例化类</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  二、类和对象的使用（面向对象思想落地的实现） //重要所以不断强调</span></span><br><span class="line"><span class="comment"> *       1.创建类，设计类的成员</span></span><br><span class="line"><span class="comment"> *       2.创建类的对象</span></span><br><span class="line"><span class="comment"> *       3.通过“对象.属性” 或 “对象.方法”调用对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Person类的对象</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用对象的结构：属性、方法</span></span><br><span class="line">        <span class="comment">//调用属性：“对象.属性”</span></span><br><span class="line">        p1.name = <span class="string">"deehuang"</span>;</span><br><span class="line">        p1.isMale = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(p1.name);<span class="comment">//deehuang</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用方法：“对象.方法”</span></span><br><span class="line">        p1.eat();</span><br><span class="line">        p1.sleep();</span><br><span class="line">        p1.talk(<span class="string">"Chinese"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age =<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：具备的一些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"说话，使用的是"</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一开始说到，本文重点学习的是面向对象思想编程的体现，落地到代码中去学习面向对象编程的思想。所以为了方便学习，下面的内容我就像上面代码示例一样都把知识点尽量放到代码块中去说明演示并简单阐述。在不断的学习代码中会有渐悟甚至顿悟的过程，读者在看到一些概念性的东西无须停下来死扣。我认为入门学习面向对象知识最好的学习方式理解代码！理解代码！理解代码！</p>
</blockquote>
<h3 id="类与多个对象的关系"><a href="#类与多个对象的关系" class="headerlink" title="类与多个对象的关系"></a>类与多个对象的关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、设计类，其实就是设计类的成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  属性 = 成员变量 = field = 域、字段</span></span><br><span class="line"><span class="comment"> *  方法 = 成员方法 = 函数 = method </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  创建类的对象 = 类的实例化 = 实例化类</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  二、类和对象的使用（面向对象思想落地的实现）</span></span><br><span class="line"><span class="comment"> *       1.创建类，设计类的成员</span></span><br><span class="line"><span class="comment"> *       2.创建类的对象</span></span><br><span class="line"><span class="comment"> *       3.通过“对象.属性” 或 “对象.方法”调用对象的结果</span></span><br><span class="line"><span class="comment"> *       </span></span><br><span class="line"><span class="comment"> *  三、如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static）</span></span><br><span class="line"><span class="comment"> *      意味着：如果我们修改一个对象的属性a，则不影响另一个对象属性a的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Person类的对象</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用对象的结构：属性、方法</span></span><br><span class="line">        <span class="comment">//调用属性：“对象.属性”</span></span><br><span class="line">        p1.name = <span class="string">"Tom"</span>;</span><br><span class="line">        p1.isMale = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(p1.name);<span class="comment">//deehuang</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用方法：“对象.方法”</span></span><br><span class="line">        p1.eat();</span><br><span class="line">        p1.sleep();</span><br><span class="line">        p1.talk(<span class="string">"Chinese"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//***********************</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(p2.isMale);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//***********************</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把p1变量保存的对象地址值赋值给p3，导致p1和p3指向堆空间中的同一个对象实体</span></span><br><span class="line">        Person p3 = p1;</span><br><span class="line">        System.out.println(p3.name);<span class="comment">//deehuang </span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age =<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：具备的一些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"说话，使用的是"</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的内存解析"><a href="#对象的内存解析" class="headerlink" title="对象的内存解析"></a>对象的内存解析</h3><p>如果上面关于多个对象和类的关系有点难理解挺正常，这涉及了它底层的内存解析。我们来瞅瞅在JVM中对象的内存是怎么分配的：</p>
<p>先让我们来看下java虚拟机结构的图示：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.jpg" class="lozad"></p>
<p>java程序执行的过程：编译完源程序以后，生成一个或多个字节码文件。我们是使用JVM中的类的加载器（或装载器）和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中(一个字节码文件对应一个类)，这就涉及到内存解析（类与类的成员在内存中怎么分配调度）。</p>
<p>而我们对内存解析主要关注的是内存区域中的运行时数据区的方法区、堆和虚拟机栈的东西！</p>
<p>虚拟机栈：即为平时提到的栈结构。我们将<code>局部变量存储在栈结构中</code><br>堆：我们将<code>new出来的结构（比如：数组、对象）加载到堆空间中</code>。补充：对象的属性(非static)加载到堆空间中<br>方法区：类的加载信息、常量池、静态域</p>
<p>首先要明确一个前提：我们上面写的代码一般都是定义在main方法里面的，而我们说：方法中的变量都是局部变量。这意味着它们都存储在需虚拟机栈中！</p>
<p>我们还是通过一组代码加图解去看看对象的内存解析：</p>
<p>我们定义了一个人类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age =<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    <span class="comment">//方法：具备的一些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"说话，使用的是"</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/10.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/11.jpg" class="lozad"></p>
<p>如此详细明了的图解，已经不用多其他的了！ </p>
<h3 id="拓展：对象数组和匿名对象的使用"><a href="#拓展：对象数组和匿名对象的使用" class="headerlink" title="拓展：对象数组和匿名对象的使用"></a>拓展：对象数组和匿名对象的使用</h3><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *对象数组题目：</span></span><br><span class="line"><span class="comment">定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。</span></span><br><span class="line"><span class="comment"> 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</span></span><br><span class="line"><span class="comment">问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line"><span class="comment">问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1) 生成随机数：Math.random()，返回值类型double;  </span></span><br><span class="line"><span class="comment">2) 四舍五入取整：Math.round(double d)，返回值类型long。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建20个学生对象</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s2 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s3 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s4 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s5 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s6 = new Student();</span></span><br><span class="line">        <span class="comment">//一个个new也太low了！我们采用对象数组的方式快速创建20个Student对象</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//声明Student类型的数组</span></span><br><span class="line">		Student[] stus = <span class="keyword">new</span> Student[<span class="number">20</span>];  <span class="comment">//String[] arr = new String[10];</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length;i++)&#123;</span><br><span class="line">			<span class="comment">//给数组元素赋值</span></span><br><span class="line">			stus[i] = <span class="keyword">new</span> Student();</span><br><span class="line">			<span class="comment">//给Student对象的属性赋值</span></span><br><span class="line">			stus[i].number = (i + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//年级：[1,6]</span></span><br><span class="line">			stus[i].state = (<span class="keyword">int</span>)(Math.random() * (<span class="number">6</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//成绩：[0,100]</span></span><br><span class="line">			stus[i].score = (<span class="keyword">int</span>)(Math.random() * (<span class="number">100</span> - <span class="number">0</span> + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++)&#123;</span><br><span class="line"><span class="comment">//			System.out.println(stus[i].number + "," + stus[i].state </span></span><br><span class="line"><span class="comment">//					+ "," + stus[i].score);</span></span><br><span class="line">			</span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(stus[i].state == <span class="number">3</span>)&#123;</span><br><span class="line">				System.out.println(stus[i].info());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; stus.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(stus[j].score &gt; stus[j + <span class="number">1</span>].score)&#123;</span><br><span class="line">					<span class="comment">//如果需要换序，交换的是数组的元素：Student对象！！！</span></span><br><span class="line">					Student temp = stus[j];</span><br><span class="line">					stus[j] = stus[j + <span class="number">1</span>];</span><br><span class="line">					stus[j + <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++)&#123;</span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//学号</span></span><br><span class="line">	<span class="keyword">int</span> state;<span class="comment">//年级</span></span><br><span class="line">	<span class="keyword">int</span> score;<span class="comment">//成绩</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示学生信息的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"学号："</span> + number + <span class="string">",年级："</span> + state + <span class="string">",成绩："</span> + score;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对象数组内存解析</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/17.jpg" class="lozad"></p>
<p><strong>对象数组内存解析需要注意</strong>:</p>
<ul>
<li>引用类型的变量，只可能存储两类值：null 或 地址值(含变量类型)</li>
</ul>
<h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匿名对象的使用</span></span><br><span class="line"><span class="comment"> * 1. 理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象</span></span><br><span class="line"><span class="comment"> * 2. 特征：匿名对象只能调用一次</span></span><br><span class="line"><span class="comment"> * 3. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();<span class="comment">//p就是对象的变量名，我们称这个对象是有名的</span></span><br><span class="line">        p.sendEmail();</span><br><span class="line">        p.playGame();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line">        <span class="keyword">new</span> Phone().playGame();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Phone().price = <span class="number">199</span>;</span><br><span class="line">        <span class="keyword">new</span> Phone().showPrice();<span class="comment">//0.0</span></span><br><span class="line">        <span class="comment">//说明匿名对象只能调用一次，每次调用都是一个 新的对象，互不影响</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名对象的使用</span></span><br><span class="line">        PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line">        mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">        <span class="comment">//此时实际上是把对象赋值给了形参，所以在方法里面可以多次调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//外面的匿名对象赋值给了形参phone，所以对象在这里就变有名了</span></span><br><span class="line">        <span class="comment">//可以多次调用，如下所示拿它调了两次方法</span></span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发邮箱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩游戏"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(price);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h1><p>到此我们就对类和对象的使用有了初步的了解了。再次总结上面的对类和对象的使用实际上就是三个步骤的事情：</p>
<p>类和对象的使用（面向对象思想落地的实现）</p>
<ul>
<li>1.<strong>创建类，设计类的成员</strong></li>
<li>2.创建类的对象</li>
<li>3.通过“对象.属性” 或 “对象.方法”调用对象的结构</li>
</ul>
<p>这三步我认为也是贯穿整个java开发的核心步骤。后面的学习也是基于这三步不断去强化的</p>
<p>接下来要回归正题：其中类的设计是OOP的重点，而类的设计实际上就是设计类的成员，故类的成员这块知识点你说重不重要！所以下面将对类的成员内容进行详细介绍。(有一部分成员在后面的内容在引入，因为需要和其他知识点搭配起来理解)</p>
<h2 id="类的成员之一：属性"><a href="#类的成员之一：属性" class="headerlink" title="类的成员之一：属性"></a>类的成员之一：属性</h2><p>先通过图大致的了解一下属性基本结构</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/13.jpg" class="lozad"></p>
<p>还是通过结合代码理解知识，在前面对对象的内存解析中我们提到了<strong>局部变量</strong>的概念，在代码中也会解决一些童鞋的疑惑：<strong>属性</strong>与<strong>局部变量</strong>的区别是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类中属性的使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 属性：是类中定义的变量，描述类具有的特点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 属性(成员变量)  vs  局部变量</span></span><br><span class="line"><span class="comment"> * 1.相同点：</span></span><br><span class="line"><span class="comment"> * 	1.1 定义变量的格式：数据类型 变量名 = 变量值</span></span><br><span class="line"><span class="comment"> *	1.2 先声明，后使用</span></span><br><span class="line"><span class="comment"> *	1.3 变量都有其对应的作用域(这三点是所有变量的共性)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.不同点：</span></span><br><span class="line"><span class="comment"> *	2.1 在类中声明的位置不同：</span></span><br><span class="line"><span class="comment"> *		属性：直接定义在类的一堆&#123;&#125;内</span></span><br><span class="line"><span class="comment"> *      局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> *	2.2.关于权限修饰符的不同（权限修饰符详细内容在类的封装性去讲） </span></span><br><span class="line"><span class="comment"> *		常用的权限修饰符：private、public、缺省(变量声明前面没有修饰符)、protected</span></span><br><span class="line"><span class="comment"> *	如： private Sting name;   public int age;根据修饰符不同就赋予了变量不同的权限</span></span><br><span class="line"><span class="comment"> *               </span></span><br><span class="line"><span class="comment"> * 		属性：可以在声明属性时，指明权限，使用权限修饰符</span></span><br><span class="line"><span class="comment"> * 			 目前，大家声明属性时，都使用缺省就可以了</span></span><br><span class="line"><span class="comment"> *		局部变量：不可以使用权限修饰符</span></span><br><span class="line"><span class="comment"> *          </span></span><br><span class="line"><span class="comment"> *	2.3 默认初始化值的情况</span></span><br><span class="line"><span class="comment"> *	当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外</span></span><br><span class="line"><span class="comment"> *量类型都是引用类型。</span></span><br><span class="line"><span class="comment"> *		属性：类的属性，根据其类型，都有默认初始化值</span></span><br><span class="line"><span class="comment"> *           整型(byte、short、int、long) --&gt; 0</span></span><br><span class="line"><span class="comment"> *           浮点型(float、double) --&gt; 0.0</span></span><br><span class="line"><span class="comment"> *           字符型(char) --&gt; 0（或'\u0000'）</span></span><br><span class="line"><span class="comment"> *           布尔型(boolean) --&gt; false</span></span><br><span class="line"><span class="comment"> *           引用数据类型(类、数组、接口、String) --&gt; null</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> *		局部变量：没有初始化值。</span></span><br><span class="line"><span class="comment"> * 				意味着我们在的调局部变量之前，一定要显式赋值</span></span><br><span class="line"><span class="comment"> *              特别的：形参在调用时，我们再赋值即可 </span></span><br><span class="line"><span class="comment"> *          </span></span><br><span class="line"><span class="comment"> *	2.4 在内存中加载的位置：</span></span><br><span class="line"><span class="comment"> *		属性：加载到堆空间(非static)</span></span><br><span class="line"><span class="comment"> *      局部变量：加载到栈空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//属性的默认初始化值</span></span><br><span class="line">        System.out.println(u1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(u1.age);<span class="comment">//0</span></span><br><span class="line">        System.out.println(u1.isMale);<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 局部变量没有初始化值：特别的：形参在调用时，我们再赋值即可 </span></span><br><span class="line">        u1.talk(<span class="string">"中文"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性(或成员变量)</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age; <span class="comment">//可以添加权限修饰符（了解）</span></span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;<span class="comment">//language:形参，也是局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"我们使用"</span> + language + <span class="string">"进行交流"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//局部变量没有初始化，报错</span></span><br><span class="line">        <span class="comment">//String food;//The local variable food may not have been initialized</span></span><br><span class="line">        </span><br><span class="line">        String food = <span class="string">"煎饼果子"</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"南方人爱吃："</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你细品，细细地品！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/12.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/14.jpg" class="lozad"></p>
<p>成员变量和成员变量在内存的位置：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/16.jpg" class="lozad"></p>
<h2 id="类的成员之二：方法"><a href="#类的成员之二：方法" class="headerlink" title="类的成员之二：方法"></a>类的成员之二：方法</h2><h3 id="方法的声明与使用"><a href="#方法的声明与使用" class="headerlink" title="方法的声明与使用"></a>方法的声明与使用</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15.jpg" class="lozad"></p>
<p>不多说，直奔主题：类中方法的声明和使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类中方法的声明和使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 方法：描述类应该具有的功能</span></span><br><span class="line"><span class="comment"> * 比如：Math类：sqrt()开方操作、random()[0,1)的随机数、...</span></span><br><span class="line"><span class="comment"> *          Scanner类：nextXxx()用于从键盘获取数据 ...</span></span><br><span class="line"><span class="comment"> *          Arrays类：sort() \ binarySearch() \ toString() \ equals()\ ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 举例几类方法的声明：</span></span><br><span class="line"><span class="comment"> * public void eat()&#123;&#125; //无形参，void表示声明的方法没有返回值</span></span><br><span class="line"><span class="comment"> * public void sleep(int hour)&#123;&#125; //有形参</span></span><br><span class="line"><span class="comment"> * public String getName()&#123;&#125; //无形参，类型 + 方法名表示有返回值(return)的方法</span></span><br><span class="line"><span class="comment"> * public String getNation(String nation)&#123;&#125;//有形参</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  2. 方法的声明：</span></span><br><span class="line"><span class="comment"> *		权限修饰符 返回值类型 方法名(形参列表)&#123;</span></span><br><span class="line"><span class="comment"> *			方法体；</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *      注意:static、final、abstract 来修饰的方法，后面再讲</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> * 3. 说明：</span></span><br><span class="line"><span class="comment"> *  3.1 关于权限修饰符：默认方法的权限修饰符都使用publicJava规定的4种权限修饰符：</span></span><br><span class="line"><span class="comment"> *private、public、缺省、protected --&gt;封装性来细说</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  3.2 返回值类型：有返回值 vs 没有返回值</span></span><br><span class="line"><span class="comment"> *      3.2.1 </span></span><br><span class="line"><span class="comment"> *			如果方法有返回值，则必须在方法声明时，指定返回值的类型，同时，方法中return关键字</span></span><br><span class="line"><span class="comment"> *来返回指定类型的变量或者常量："return 数据"。</span></span><br><span class="line"><span class="comment"> *          如果方法没有返回值，则方法声明时，使用void来表示。就不使用return。但是如果使用</span></span><br><span class="line"><span class="comment"> *的话，只能"return"，表示结束此方法的意思</span></span><br><span class="line"><span class="comment"> *       </span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      3.2.2 思考：我们定义方法该不该有返回值？</span></span><br><span class="line"><span class="comment"> *          ① 看题目要求</span></span><br><span class="line"><span class="comment"> *          ② 凭经验</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  3.3 方法名：属于标识符，遵循标识符的规则和规范：”见名知意“</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  3.4 形参列表：方法可以声明0个，1个，或多个形参</span></span><br><span class="line"><span class="comment"> *  	3.4.1 格式：数据类型1 形参1, 数据类型2 形参2,... </span></span><br><span class="line"><span class="comment"> *          </span></span><br><span class="line"><span class="comment"> *  	3.4.2 思考：我们定义方法时，该不该定义形参？</span></span><br><span class="line"><span class="comment"> *       	① 题目要求</span></span><br><span class="line"><span class="comment"> *          ② 凭经验</span></span><br><span class="line"><span class="comment"> *                  </span></span><br><span class="line"><span class="comment"> *  3.5 方法体：方法功能的体现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * return关键字的使用：</span></span><br><span class="line"><span class="comment"> * 		1.使用范围</span></span><br><span class="line"><span class="comment"> *		2.作用：①结束方法 ②针对有返回值类型的方法使用'return 数据'方式返回所要的数据</span></span><br><span class="line"><span class="comment"> *		3.注意点：return关键字的后面不可以声明执行语句</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. 方法的使用中，可以调用当前类的属性或方法</span></span><br><span class="line"><span class="comment"> *          	 特殊：方法A中又调用了方法A：递归方法	</span></span><br><span class="line"><span class="comment"> *          	 方法中不能定义别的方法！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer cust  = <span class="keyword">new</span> Customer();</span><br><span class="line">        cust.eat();</span><br><span class="line">        cust.sleep(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"客户吃饭"</span>);</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//void方法中使用return的意义是结束方法</span></span><br><span class="line">        <span class="comment">//return后不可以加表达式</span></span><br><span class="line">        <span class="comment">//System.out.println("HEOLL");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"休息了"</span> + hour + <span class="string">" 个小时"</span>);</span><br><span class="line">        eat();<span class="comment">//方法的使用中可以调用当前类的方法</span></span><br><span class="line">        <span class="comment">//sleep(10);//递归法，没有终止条件会抛stackoverflowError</span></span><br><span class="line">        <span class="comment">//因为不断调用方法不断给声明形参会在栈中不断创建变量空间最终导致栈溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;<span class="comment">//方法的使用中可以调用当前类的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getNation</span><span class="params">(String nation)</span> </span>&#123;</span><br><span class="line">        String info = <span class="string">"我的国籍是"</span> + nation;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//public void play() &#123;&#125; //方法中不能定义另一个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>方法的重载是比较偏概念性的东西。<br>总结一下构成重载的条件： “两同一不同”</p>
<ul>
<li><p>同一个类、相同方法名</p>
<ul>
<li>参数列表不同：参数个数不同，参数类型不同</li>
</ul>
</li>
</ul>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/18.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/19.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法的重载（overload）  loading...</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</span></span><br><span class="line"><span class="comment"> * 	</span></span><br><span class="line"><span class="comment"> *  "两同一不同":同一个类、相同方法名</span></span><br><span class="line"><span class="comment"> *            参数列表不同：参数个数不同，参数类型不同</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 举例：</span></span><br><span class="line"><span class="comment"> *    Arrays类中重载的sort() / binarySearch()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.判断是否是重载：</span></span><br><span class="line"><span class="comment"> *    跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * 4. 在通过对象调用方法时，如何确定某一个指定的方法：</span></span><br><span class="line"><span class="comment"> *      方法名 ---&gt; 参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		OverLoadTest test = <span class="keyword">new</span> OverLoadTest();</span><br><span class="line">		test.getSum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如下的4个方法构成了重载</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">double</span> d1,<span class="keyword">double</span> d2)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(String s ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如下的3个方法不能与上述4个方法构成重载：因为参数列表相同（只与个数和类型有关）</span></span><br><span class="line"><span class="comment">//	public int getSum(int i,int j)&#123;//跟返回值类型无关</span></span><br><span class="line"><span class="comment">//		return 0;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void getSum(int m,int n)&#123;//参数名不能作为标准，只看类型和个数</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	private void getSum(int i,int j)&#123;//跟修饰符无关</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 重载概念的引入就是为了告诉我们在通过对象调用方法时，如何确定某一个指定的方法：<strong>方法名+ 参数列表</strong></p>
<h3 id="可变个数的形参的方法"><a href="#可变个数的形参的方法" class="headerlink" title="可变个数的形参的方法"></a>可变个数的形参的方法</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/20.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 可变个数形参的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.jdk 5.0新增的内容</span></span><br><span class="line"><span class="comment"> * 2.具体使用：</span></span><br><span class="line"><span class="comment"> *   2.1 可变个数形参的格式：数据类型 ... 变量名</span></span><br><span class="line"><span class="comment"> *   2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个...</span></span><br><span class="line"><span class="comment"> *   2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</span></span><br><span class="line"><span class="comment"> *   2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</span></span><br><span class="line"><span class="comment"> *   2.5 可变个数形参在方法的形参中，必须声明在末尾</span></span><br><span class="line"><span class="comment"> * 	 2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参（由于2.5自然的就有了2.6）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodArgsTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		MethodArgsTest test = <span class="keyword">new</span> MethodArgsTest();</span><br><span class="line">		test.show(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//		test.show("hello");</span></span><br><span class="line"><span class="comment">//		test.show("hello","world");</span></span><br><span class="line"><span class="comment">//		test.show();</span></span><br><span class="line">		</span><br><span class="line">		test.show(<span class="keyword">new</span> String[]&#123;<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"CC"</span>&#125;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"show(String)"</span>);</span><br><span class="line">	&#125;<span class="comment">//只传一个参数的话会优先匹配此方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String ... strs)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"show(String ... strs)"</span>);</span><br><span class="line">		<span class="comment">//想要获取传入的每个参数，要使用循环遍历的方式取到，实际上strs就是一个数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">			System.out.println(strs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//	public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;//5.0以前是使用数组的来定义可变个数形参的方法，所以会跟上面的方法重载冲突</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//The variable argument type String of the method show must be the last parameter</span></span><br><span class="line">    <span class="comment">//意思就是可变个数参数在方法形参中必须声明在最后末尾</span></span><br><span class="line"><span class="comment">//	public void show(String ...strs,int i)&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/21.jpg" class="lozad"></p>
<p>理解上面的内容其实需要明白java关于变量赋值的特性：</p>
<ul>
<li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值</li>
<li>如果变量是引用，此时赋值的是变量所保存的地址值</li>
</ul>
<p>而方法形参的值传递机制其实和变量赋值就是一样的！</p>
<p>我们针对<strong>从形参是基本数据类型</strong>来看一下值传递机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法的形参的传递机制：值传递</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 形参：方法定义时，声明的小括号内的参数</span></span><br><span class="line"><span class="comment">   实参：方法调用时，实际传递给形参的数据</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">2. 值传递机制：</span></span><br><span class="line"><span class="comment">	如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"m = "</span> + m + <span class="string">" , n = "</span> + n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换两个变量的值的方法</span></span><br><span class="line"><span class="comment">//        int temp = m;</span></span><br><span class="line"><span class="comment">//        m = n;</span></span><br><span class="line"><span class="comment">//        n = temp;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把它封装到方法里去实现</span></span><br><span class="line">        ValueTransferTest test = <span class="keyword">new</span> ValueTransferTest();</span><br><span class="line">        test.swap(m, n);<span class="comment">//这里的m和n就是实参</span></span><br><span class="line">        System.out.println(<span class="string">"m = "</span> + m + <span class="string">" , n = "</span> + n);</span><br><span class="line">        <span class="comment">//发现输出的是没有交换的结果？？这是怎么回事？</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//这里的m和n是实参</span></span><br><span class="line">        <span class="comment">//交换两个变量的值的方法</span></span><br><span class="line">        <span class="keyword">int</span> temp = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释上面的问题就需要从内存解析去下手了：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/22.jpg" class="lozad"></p>
<p>swap方法执行完后，它里面的变量的作用域消失，那栈中属于swap的局部变量就相继出栈。从始至终main方法中的局部变量m和n都没有变动。所以就出现了没有交换成功的现象</p>
<hr>
<p>针对<strong>实参是引用数据类型</strong>来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法的形参的传递机制：值传递</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 形参：方法定义时，声明的小括号内的参数</span></span><br><span class="line"><span class="comment">   实参：方法调用时，实际传递给形参的数据</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">2. 值传递机制：</span></span><br><span class="line"><span class="comment">	如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</span></span><br><span class="line"><span class="comment">	如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值(含变量的数据类型)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	思考:</span></span><br><span class="line"><span class="comment">	Person p1 = new Person();</span></span><br><span class="line"><span class="comment">	User u1 = p1;//编译不通过为什么？</span></span><br><span class="line"><span class="comment">	变量赋值要满足两点中的一点：类型一致、满足自动类型提升（不考虑强转的情况）</span></span><br><span class="line"><span class="comment">	而这里就是因为引用类型变量存储的不单是地址值，还包括了变量的数据类型。u1的数据类型已经声明了是User类型了，而p1存的是Person类型+地址值。类型不一致故编译不通过。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        </span><br><span class="line">        data.m = <span class="number">10</span>;</span><br><span class="line">        data.n = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"m = "</span> + m + <span class="string">" , n = "</span> + n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换m和n的值,这种方式是可以成功的</span></span><br><span class="line"><span class="comment">//        int temp = data.m;</span></span><br><span class="line"><span class="comment">//        data.m = data.n;</span></span><br><span class="line"><span class="comment">//        data.n = temp;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果我们想把交换值的代码封装到方法中</span></span><br><span class="line">        ValueTransferTest test = <span class="keyword">new</span> ValueTransferTest();</span><br><span class="line">        test.swap(data);<span class="comment">//data是引用据类型，这里传递的是实参</span></span><br><span class="line">        System.out.println(<span class="string">"m = "</span> + m + <span class="string">" , n = "</span> + n);</span><br><span class="line">        <span class="comment">//交换成功！</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pubilc <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Data data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//交换m和n的值的方法</span></span><br><span class="line">        <span class="keyword">int</span> temp = data.m;</span><br><span class="line">        data.m = data.n;</span><br><span class="line">        data.n = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面如果传递值是引用数据类型，则可以成功，这是为什么呢？还是需要通过内存解析去解释：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/23.jpg" class="lozad"></p>
<p>对于参数是引用数据类型的方法，此时实参赋给形参的是实参存储数据的地址值。所以它们操作的是同一个对象实体故能成功交互值</p>
<p>到此已经画了不少内存图了，可想而知它的重要性，它对我们分析程序的运行有极大的帮助，在画内存图的过程中只要时刻谨记两个点，就不会出错：</p>
<ol>
<li>内存结构：<ul>
<li>栈：局部变量</li>
<li>堆：new出来的结构（非static）、成员变量、数组</li>
</ul>
</li>
<li>变量：成员变量 vs 局部变量(方法内、方法形参、构造器内、构造器形参、代码块内)</li>
</ol>
<p><em>PS：String类型在上面代码事例中会有特殊情况，这是因为它在内存中是存储在常量池中的，而非堆，关于String类型和方法区的内容我们以后再讲到。这里只要记住值传递机制的两个结论而不要去记上面的代码：</em></p>
<ul>
<li><em>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</em></li>
<li><em>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值(含变量的数据类型)</em></li>
</ul>
<p><strong>简单记就是变量里存的是什么就传的是什么！</strong></p>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/24.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归方法的使用（了解）</span></span><br><span class="line"><span class="comment"> * 1.递归方法：一个方法体内调用它自身。</span></span><br><span class="line"><span class="comment"> * 2. 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制(不用自己写for和While)。</span></span><br><span class="line"><span class="comment"> * 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 例1：计算1-100之间所有自然数的和</span></span><br><span class="line">		<span class="comment">// 方式一：</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		<span class="comment">// 方式二：</span></span><br><span class="line">		RecursionTest test = <span class="keyword">new</span> RecursionTest();</span><br><span class="line">		<span class="keyword">int</span> sum1 = test.getSum(<span class="number">100</span>);</span><br><span class="line">		System.out.println(sum1);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"*****************"</span>);</span><br><span class="line">		<span class="keyword">int</span> value = test.f(<span class="number">10</span>);</span><br><span class="line">		System.out.println(value);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 例1：计算1-n之间所有自然数的和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 例2：计算1-n之间所有自然数的乘积:n!</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//例3：已知有一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line">	<span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//			return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象特性之一：封装性"><a href="#面向对象特性之一：封装性" class="headerlink" title="面向对象特性之一：封装性"></a>面向对象特性之一：封装性</h2><blockquote>
<p>为什么在这里引入封装性的学习？因为我们要引出权限修饰符去介绍类与类的结构！前面已经说到，知识点并非死板的按主线去介绍。里面的许多知识点是相辅相成相互依赖的，根本没办法个说个的，本文主提倡的是循序渐进的方式去总结知识点和博主我的学习心得~所以读者看到这里突然冒出的封装性！不要懵！不要懵！不要懵！</p>
</blockquote>
<h3 id="什么是封装与隐藏"><a href="#什么是封装与隐藏" class="headerlink" title="什么是封装与隐藏"></a>什么是封装与隐藏</h3><p>为什么要封装？</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/25.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/26.jpg" class="lozad"></p>
<p>还是落地到代码去理解知识点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 面向对象的特征一：封装与隐藏</span></span><br><span class="line"><span class="comment"> * 一、 问题的引入：</span></span><br><span class="line"><span class="comment"> *	当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是在实际问题中，我们往往要给属性赋值加入额外的限制条件。这个限制条件就不能在属性声明时体现，我们只能通过方法进行限制条件添加（如:setLegs）同时，我们要避免用户再使用"对象.属性"的方式对属性进行赋值，则需要将属性声明为私有的(private)--&gt;此时，针对于属性就体现了"封装性"。(把它隐藏起来了)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、封装性的体现：</span></span><br><span class="line"><span class="comment"> *	我们将类的属性xxx私有化(private)，同时提供公共的(pubilc)方法来获取(getXxx)和设置(setXxx)此属性的值</span></span><br><span class="line"><span class="comment"> *	PS：这只是封装性的体现，上述不能说等同于封装性，封装性包括了很多体现!!!比如说一个人是好人，在公车上给老人让座只是好人的一个体现而已...还有很多事情体现了这是个好像人（请细品）</span></span><br><span class="line"><span class="comment"> *	拓展：封装性的体现：① 如上  ② 不对外暴露的私有的方法  ③ 单例模式   ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 三、封装性的体现，需要权限修饰来配合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        a.name = <span class="string">"大黄"</span>;</span><br><span class="line">        a.age = <span class="number">6</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//      a.legs = -4;//-4只腿？？？</span></span><br><span class="line">        <span class="comment">//这明显不合理，所以应该将legs属性保护起来，防止乱用。</span></span><br><span class="line">        <span class="comment">//我们要加限制腿数的条件，只能把属性封装成方法去设置</span></span><br><span class="line">        <span class="comment">//并且为了避免外界通过”对象.属性“的方式直接赋值，还要把属性声明为私有的(private)</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置了限定方法，就不允许外界直接去通过调属性a.legs操作</span></span><br><span class="line"><span class="comment">//      a.legs = 4;//The field Animal.legs is not visible</span></span><br><span class="line">        a.setLegs(<span class="number">6</span>);</span><br><span class="line">        a.show();</span><br><span class="line">        a.setLegs(<span class="number">6</span>);</span><br><span class="line">        a.show();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//既然legs属性隐藏起来然后提供设置legs的方法，当然还需要提供获取legs的方法</span></span><br><span class="line">        <span class="keyword">int</span> l = a.getLegs();</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> legs;<span class="comment">//腿的个数，设置成私有权限，让外界不能直接调</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对属性的设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLegs</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//限制腿的个数只能是正数并且是以对数存在</span></span><br><span class="line">        <span class="keyword">if</span>(l &gt;= <span class="number">0</span> &amp;&amp; l % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            legs = l;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            legs = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对属性的获取</span></span><br><span class="line">    <span class="function">pubilc <span class="keyword">int</span> <span class="title">getLegs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> legs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物吃东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name = "</span> + name + <span class="string">", age = "</span> + age + <span class="string">", legs = "</span> + legs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码示例中我们简单体会了下封装性其中一个体现，不难看出要将封装性体现出来需要<strong>权限修饰符</strong>的配合！所以下面让我们看看常用的四种权限修饰符的理解：</p>
<h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/27.jpg" class="lozad"></p>
<p>在这里我们只介绍三种权限：public、缺省和private，因为protected涉及了面向对象的继承性，所以留到学习继承性中去介绍会有更深的体会！</p>
<p>这里我们新建一个包名为<code>io.deehuang.github.java1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">封装性的体现，需要权限修饰来配合。</span></span><br><span class="line"><span class="comment">1.Java规定的4种权限：(从小到大排列)：private、缺省(啥也不写)、protected、public</span></span><br><span class="line"><span class="comment">2.4种权限可以用来修饰“类及类的内部”结构：属性、方法、构造器、内部类</span></span><br><span class="line"><span class="comment">3.具体的，4种权限都可以用来修饰”类的内部“结构：属性、方法、构造器、内部类</span></span><br><span class="line"><span class="comment">	修饰类的话，只能使用：缺省、public</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> orderPrivate;<span class="comment">//私有</span></span><br><span class="line">    <span class="keyword">int</span> orderDefault;<span class="comment">//缺省</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> orderPublic;<span class="comment">//公有</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> orderPrivate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> orderDefault = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> orderPublic = <span class="number">3</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缺省</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> orderPrivate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> orderDefault = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> orderPublic = <span class="number">3</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> orderPrivate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> orderDefault = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> orderPublic = <span class="number">3</span>;  </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里再新建一个class文件写测试类，因为同一个文件下只能有一个public类</span></span><br><span class="line"><span class="comment">//The public type OderTest must be defined in its own file</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Order order = <span class="keyword">new</span> Order();</span><br><span class="line">		</span><br><span class="line">		order.orderDefault = <span class="number">1</span>;</span><br><span class="line">		order.orderPublic = <span class="number">2</span>;</span><br><span class="line">		<span class="comment">//出了Order类之后，私有的结构就不可以调用了</span></span><br><span class="line"><span class="comment">//		order.orderPrivate = 3;//The field Order.orderPrivate is not visible</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		order.methodDefault();</span><br><span class="line">		order.methodPublic();</span><br><span class="line">		<span class="comment">//出了Order类之后，私有的结构就不可以调用了</span></span><br><span class="line"><span class="comment">//		order.methodPrivate();//The method methodPrivate() from the type Order is not visible</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们再新建一个包名为<code>io.deehuang.github.java2</code>进行试图调Java1包的类结构去测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">封装性的体现，需要权限修饰来配合。</span></span><br><span class="line"><span class="comment">1.Java规定的4种权限：(从小到大排列)：private、缺省(啥也不写)、protected、public</span></span><br><span class="line"><span class="comment">2.4种权限可以用来修饰“类及类的内部”结构：属性、方法、构造器、内部类</span></span><br><span class="line"><span class="comment">3.具体的，4种权限都可以用来修饰”类的内部“结构：属性、方法、构造器、内部类</span></span><br><span class="line"><span class="comment">	修饰类的话，只能使用：缺省、public</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> io.deehuang.github.java1.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;<span class="comment">//不同包下的类名可以一样</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Order order = <span class="keyword">new</span> Order();</span><br><span class="line"></span><br><span class="line">		order.orderPublic = <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// 出了Order类所属的包之后，私有的结构、缺省声明的结构就不可以调用了</span></span><br><span class="line"><span class="comment">//		order.orderDefault = 1;</span></span><br><span class="line">		<span class="comment">// order.orderPrivate = 3;//The field Order.orderPrivate is not visible</span></span><br><span class="line"></span><br><span class="line">		order.methodPublic();</span><br><span class="line">		<span class="comment">// 出了Order类所属的包之后，私有的结构、缺省声明的结构就不可以调用了</span></span><br><span class="line"><span class="comment">//		order.methodDefault();</span></span><br><span class="line">		<span class="comment">// order.methodPrivate();//The method methodPrivate() from the type Order is not visible</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以形象点理解四个权限：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/28.jpg" class="lozad"></p>
<p><strong>总结封装性</strong>:</p>
<ul>
<li><p>Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</p>
</li>
<li><p><strong>封装性的体现：</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/40.jpg" class="lozad"></p>
</li>
</ul>
<p>了解了封装性后，我们又回到主题，继续介绍回类的成员!</p>
<h2 id="类的成员之三：构造器（或构造方法）"><a href="#类的成员之三：构造器（或构造方法）" class="headerlink" title="类的成员之三：构造器（或构造方法）"></a>类的成员之三：构造器（或构造方法）</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>任何一个类，都有构造器！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/29.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/30.jpg" class="lozad"></p>
<p>根据参数不同，构造器可以分为如下两类： </p>
<ul>
<li>隐式无参构造器（系统默认提供） </li>
<li>显式定义一个或多个构造器（无参、有参）</li>
</ul>
<p><strong>构造器的使用与说明</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类的结构之三：构造器（或构造方法、constructor）的使用</span></span><br><span class="line"><span class="comment"> * construct：建设、建造。  construction:CCB（中国建设银行）  constructor:建设者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、构造器的作用：</span></span><br><span class="line"><span class="comment"> * 1.创建对象</span></span><br><span class="line"><span class="comment"> * 2.初始化对象的信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、说明：</span></span><br><span class="line"><span class="comment"> * 1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器</span></span><br><span class="line"><span class="comment"> * 2.定义构造器的格式：权限修饰符  类名(形参列表)&#123;&#125;</span></span><br><span class="line"><span class="comment"> * 3.一个类中定义的多个构造器，彼此构成重载</span></span><br><span class="line"><span class="comment"> * 4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</span></span><br><span class="line"><span class="comment"> * 5.一个类中，至少会有一个构造器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.deehuang.github.java1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建类的对象:new + 构造器</span></span><br><span class="line">        <span class="comment">//如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();<span class="comment">//我们将Person()这个结构就叫构造器 </span></span><br><span class="line">        p.eat();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在造对象的同时，给对象的属性赋值</span></span><br><span class="line">        <span class="comment">//初始化对象的属性</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"DeeHuang"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发现把空参构造器注释掉后，下面写了不是空参的构造器，创建对象的时候编译失败</span></span><br><span class="line">    <span class="comment">//这是因为一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以有多个构造器，但是形参列表要不同：构造器的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在造对象的同时，给对象的属性赋值</span></span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以有多个构造器，但是形参列表要不同：构造器的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在造对象的同时，给对象的属性赋值</span></span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面通过构造器可以给属性赋值，我们前面说的通过<code>对象.属性</code>的方式也可以赋值或封装属性方法来给属性赋值甚至属性一开始还有默认初始化值或者显式初始化值(直接声明+赋值属性)。不知道各位童鞋是否有疑问：TM这么多值什么这跟什么%￥@！&amp;*……？它们赋值的顺序和过程是怎么样的？莫浮躁~下面就简单介绍属性的赋值过程</p>
</blockquote>
<h3 id="属性的赋值过程"><a href="#属性的赋值过程" class="headerlink" title="属性的赋值过程"></a><strong>属性的赋值过程</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 总结：属性赋值的先后顺序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * ① 默认初始化</span></span><br><span class="line"><span class="comment"> * ② 显式初始化</span></span><br><span class="line"><span class="comment"> * ③ 构造器中初始化</span></span><br><span class="line"><span class="comment"> * ps:上面三个赋值都是对象创建之前的操作，所以就叫初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ④ 通过"对象.方法" 或 "对象.属性"的方式，赋值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 以上操作的先后顺序：① - ② - ③ - ④  </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		</span><br><span class="line">		System.out.println(u.age);<span class="comment">//1 说明显式赋值在默认初始化后面</span></span><br><span class="line">		</span><br><span class="line">		User u1 = <span class="keyword">new</span> User(<span class="number">2</span>);</span><br><span class="line">		System.out.println(u1.age);<span class="comment">//2 说明构造器初始化在显式赋值的后面</span></span><br><span class="line">        </span><br><span class="line">		u1.setAge(<span class="number">3</span>);</span><br><span class="line">		u1.setAge(<span class="number">5</span>);</span><br><span class="line">		System.out.println(u1.age);<span class="comment">//3 说明“对象.方法”方式赋值在构造器初始化后面</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展：JavaBean和UML类图"><a href="#拓展：JavaBean和UML类图" class="headerlink" title="拓展：JavaBean和UML类图"></a>拓展：JavaBean和UML类图</h3><p>了解一下JavaBean和UML图(随意看看就好，基础篇里用不着)</p>
<h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/31.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JavaBean是一种Java语言写成的可重用组件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	所谓JavaBean，是指符合如下标准的Java类：</span></span><br><span class="line"><span class="comment">		&gt;类是公共的</span></span><br><span class="line"><span class="comment">		&gt;有一个无参的公共的构造器</span></span><br><span class="line"><span class="comment">		&gt;有属性，且有对应的get、set方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		id = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/32.jpg" class="lozad"></p>
<p>有什么用？经常会看到题目或者需求就是用UML类图表示的！</p>
<h2 id="关键字：this的使用"><a href="#关键字：this的使用" class="headerlink" title="关键字：this的使用"></a>关键字：this的使用</h2><blockquote>
<p>跟封装性的知识点一样，引入在这里是为了能为后面的知识点学习铺垫！</p>
</blockquote>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/33.jpg" class="lozad"></p>
<p>还是落实到代码去理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this关键字的使用：</span></span><br><span class="line"><span class="comment"> * 1.this可以用来修饰、调用：属性、方法、构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.this修饰属性和方法：</span></span><br><span class="line"><span class="comment"> *   this理解为：当前对象  或 当前正在创建的对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  2.1  在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是，</span></span><br><span class="line"><span class="comment"> *   通常情况下，我们都选择省略"this."。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式</span></span><br><span class="line"><span class="comment"> *   的使用"this.变量"的方式，表明此变量是属性，而非形参。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  2.2 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方</span></span><br><span class="line"><span class="comment"> *	法。但是，通常情况下，我们都选择省略"this."。特殊情况下，如果构造器的形参和类的属性同名时，我们必</span></span><br><span class="line"><span class="comment"> *	须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. this调用构造器</span></span><br><span class="line"><span class="comment"> *    ① 我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器</span></span><br><span class="line"><span class="comment"> *    ② 构造器中不能通过"this(形参列表)"方式调用自己</span></span><br><span class="line"><span class="comment"> *    ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了"this(形参列表)"</span></span><br><span class="line"><span class="comment"> *    ④ 规定："this(形参列表)"必须声明在当前构造器的首行</span></span><br><span class="line"><span class="comment"> *    ⑤ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        p1.setAge(<span class="number">1</span>);<span class="comment">//0</span></span><br><span class="line">        System.out.println(p1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通常情况下，我们都选择省略"this."。</span></span><br><span class="line">    <span class="comment">//特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eat();<span class="comment">//this也可以调方法</span></span><br><span class="line">        <span class="comment">//假如Person初始化时需要考虑40行代码（下面处省略四十行）</span></span><br><span class="line">        <span class="comment">//那彼此构成重载的构造器都要重复写40行(代码冗余了)?low实在是low。</span></span><br><span class="line">        <span class="comment">//此时可以使用this调用构造器(看下面的重载方法)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();<span class="comment">//调用空参的构造器，防止代码冗余！</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//构造器是正在创建的对象进行初始化,这里的this表示当前正在创建的对象</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        this();//Constructor call must be the first statement in a constructor</span></span><br><span class="line">        <span class="comment">//规定："this(形参列表)"必须声明在当前构造器的首行</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        name = name;//编译器会就近原则的找name 这里就是形参自己赋值给自己</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//关键字this表示当前对象，就会去找对象的同名属性去了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人吃饭"</span>);</span><br><span class="line">        <span class="keyword">this</span>.study();  <span class="comment">//this可以调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字：package、import的使用"><a href="#关键字：package、import的使用" class="headerlink" title="关键字：package、import的使用"></a>关键字：package、import的使用</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><h4 id="包的使用与作用"><a href="#包的使用与作用" class="headerlink" title="包的使用与作用"></a>包的使用与作用</h4><p>为什么要引入包的概念呢？是为了更好的实现项目中类的管理，所以提供了包的概念</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/34.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/35.jpg" class="lozad"></p>
<p>落实代码中创建一个包和class来看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.deehuang.github.java1;<span class="comment">//package声明类或接口所属的包，声明在源文件的首行</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、package关键字的使用</span></span><br><span class="line"><span class="comment"> *  1.为了更好的实现项目中类的管理，提供包的概念</span></span><br><span class="line"><span class="comment"> *  2.使用package声明类或接口所属的包，声明在源文件的首行</span></span><br><span class="line"><span class="comment"> *  3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)：”见名知意“</span></span><br><span class="line"><span class="comment"> *  4.每”.“一次，就代表一层文件目录</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  补充：同一个包下，不能命名同名的接口、类</span></span><br><span class="line"><span class="comment"> *              不同的包下，可以命名同名的接口、类</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageImportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是jdk中常用的一些包的介绍：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/38.jpg" class="lozad"></p>
<h4 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h4><p>在包的作用中有介绍到MVC设计模式，这里就简单了解一下（这是javaWeb的知识点，感兴趣的先简单了解一下就可了！莫纠结）</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/36.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/37.jpg" class="lozad"></p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/39.jpg" class="lozad"></p>
<p>直接落实代码中理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.deehuang.github.practice;<span class="comment">//package声明类或接口所属的包，声明在源文件的首行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//导入util下的所有结构</span></span><br><span class="line"><span class="keyword">import</span> io.deehuang.github.java1.PackageImportTest;<span class="comment">//导入不同包的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.deehuang.github.java.Person;<span class="comment">//导入不同包的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;<span class="comment">//lang包的子包内结构需要显方导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、package关键字的使用</span></span><br><span class="line"><span class="comment"> *  1.为了更好的实现项目中类的管理，提供包的概念</span></span><br><span class="line"><span class="comment"> *  2.使用package声明类或接口所属的包，声明在源文件的首行</span></span><br><span class="line"><span class="comment"> *  3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)：”见名知意“</span></span><br><span class="line"><span class="comment"> *  4.每”.“一次，就代表一层文件目录</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  补充：同一个包下，不能命名同名的接口、类</span></span><br><span class="line"><span class="comment"> *              不同的包下，可以命名同名的接口、类</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> * 二、import关键字的使用</span></span><br><span class="line"><span class="comment"> *  import：导入</span></span><br><span class="line"><span class="comment"> *  1. 在源文件中显式的使用import结构导入指定包下的类、接口</span></span><br><span class="line"><span class="comment"> *  2. 声明在包的声明和类的声明之间</span></span><br><span class="line"><span class="comment"> *  3. 如果需要导入多个结构，则并列的写出即可</span></span><br><span class="line"><span class="comment"> *  4. 可以使用"xxx.*"的方式，表示可以导入xxx包下所有的结构(不包括子包)</span></span><br><span class="line"><span class="comment"> *  5. 如果使用的类或接口是java.lang包下定义的，可以省略import结构</span></span><br><span class="line"><span class="comment"> *  6.如果使用的类或接口是本包下定义的，则可以省略import结构</span></span><br><span class="line"><span class="comment"> *  7. 如果在源文件中，使用不同报下的同名的类，则必须至少有一个类需要以全类名的方式显示</span></span><br><span class="line"><span class="comment"> *  8.使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包(包里创建的包)下的结构，则仍需要显式导入</span></span><br><span class="line"><span class="comment"> *  9.import static:导入类或接口中的静态结构：属性或方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String info = Arrays.toString(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);<span class="comment">//导入Arrays才能使用</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//需要导入util包下的ArrayList</span></span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();<span class="comment">//也需要导入util包下的HashMap类</span></span><br><span class="line">        <span class="comment">//像这种用到同一个包下多个结构的情况，不需要重复写import，可用" * "号导入</span></span><br><span class="line">       </span><br><span class="line">        PackageImportTest pi = <span class="keyword">new</span> PackageImportTest();<span class="comment">//使用不同包的类需要导入</span></span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">"123"</span>;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//像String和system属于Java的核心包，定义在lang下。不需要导入，可以直接使用</span></span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="comment">//如果在源文件中，使用不同报下的同名的类，则必须至少有一个类需要以全类名的方式显示</span></span><br><span class="line">        <span class="comment">//假设有两个包下都有名为Person类，而我都想在这里用，着就会冲突！</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();<span class="comment">//导入import io.deehuang.github.java1.Person;</span></span><br><span class="line">        <span class="comment">//此时我还想导入java1包里的Person：使用全类名方式显示</span></span><br><span class="line">        io.deehuang.github.java2.Person p1 = <span class="keyword">new</span> io.deehuang.github.java2.Person();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包(包里创建的包)下的结构，则仍需要显式导入</span></span><br><span class="line">        Field field = <span class="keyword">null</span>; <span class="comment">//Field类是lang包下reflect包里的结构。因为是子包所以需要显式import,不可省略</span></span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//import static:导入类或接口中的静态结构：属性或方法</span></span><br><span class="line">        out.println();<span class="comment">//out静态结构在前面被导入后可以直接用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的成员在本模块里只介绍了三个，本模块的内容至此也先告一段落了。其他成员如内部类和代码块因为需要引入继承等知识的概念才能更好的上手掌握，所有需要先进入到下一个模块的学习再在其中插入介绍。还是那句话学习是循序渐进的过程，知识点的杂糅是希望有承上启下的作用。所以后面的模块中突然介绍到别的类的成员的时候莫懵逼！建议各位童鞋可以多回去看看写在开头的话~</p>
<hr>
<h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><blockquote>
<p>面向对象的三大特性有：封装、继承、多态。<br>封装性的知识点在上面的类与类的结构模块中已经提到，所以这里主要介绍的是继承与多态，以及引入一些与之紧密联系的知识点（包括未介绍完的类的成员以及一些关键字的使用）</p>
</blockquote>
<h2 id="面向对象特性之二：继承性"><a href="#面向对象特性之二：继承性" class="headerlink" title="面向对象特性之二：继承性"></a>面向对象特性之二：继承性</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/41.jpg" class="lozad"></p>
<p>继承性其实是一个非常好理解的知识点。首先看下面两个UML类图：</p>
<p>为描述和处理个人信息，定义Person类：</p>
<img style="zoom: 67%;" data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/42.jpg" class="lozad">



<p>为描述和处理学生信息，定义Student类：</p>
<img style="zoom: 67%;" data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/43.jpg" class="lozad">

<p>我们发现，Student类里面除了<code>school</code>属性外，其他的属性和方法都在Person类中定义过了。如果还有其他的比如Teacher类、Waiter类等等类需要定义相同的属性和行为的时，那我们这些方法都要重复的写一遍。这不仅十分麻烦而且会让我们的代码显得臃肿，这时候我们可能会想到能否有一种方式，让两个类“发生关系”，使得Student类去复用一下Person类的代码？Yes！这种方式就是继承。使用继承的方式去设计代码，可以减少代码冗余、大大提高代码的复用性！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/44.jpg" class="lozad"></p>
<p>在这里我们把继承的Person叫做Student的父类，而自然而然的Student就是Person的子类了。</p>
<h3 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h3><ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。 </li>
<li>继承的出现，更有利于功能的扩展。 </li>
<li>继承的出现让类与类之间产生了关系，为之后多态性的使用提供了前提</li>
</ul>
<p><em>注意：不要仅为了获取其他类中某个功能而去继承</em></p>
<h3 id="继承性的使用"><a href="#继承性的使用" class="headerlink" title="继承性的使用"></a>继承性的使用</h3><p>终究要回归代码层面去看看继承性是怎么回事</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 面向对象的特征之二：继承性    why?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、继承性的好处：</span></span><br><span class="line"><span class="comment"> * ① 减少了代码的冗余，提高了代码的复用性</span></span><br><span class="line"><span class="comment"> * ② 便于功能的扩展</span></span><br><span class="line"><span class="comment"> * ③ 为之后多态性的使用，提供了前提</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、继承性的格式： class A extends B&#123;&#125;</span></span><br><span class="line"><span class="comment"> *  A：子类、派生类、subclass</span></span><br><span class="line"><span class="comment"> *  B：父类、超类、基类、superclass</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  2.1 体现：一旦子类A继承父类B以后，子类A就获取了父类B中声明的所有属性、方法</span></span><br><span class="line"><span class="comment"> *      特别的：父类声明为private的属性和方法，子类继承父类以后，仍然认为获取父类中私有的结构。</span></span><br><span class="line"><span class="comment"> *  只是因为封装性的影响，使得子类不能直接调用父类的结构而已</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展</span></span><br><span class="line"><span class="comment"> *  子类和父类的关系，不同于子集和集合的关系</span></span><br><span class="line"><span class="comment"> *  extends是延展、拓展的意思</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//父类声明为private的属性和方法，子类继承父类以后，仍然认为获取父类中私有的结构</span></span><br><span class="line">        <span class="comment">//只是因为封装性的影响，使得子类不能直接调用父类的结构而已</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//        s1.age = 1; //父类的私有属性，出了类不能调。这是因为封装性的影响</span></span><br><span class="line">        s1.eat();</span><br><span class="line">        s1.name = <span class="string">"deehuang"</span>;</span><br><span class="line">        s1.setAge(<span class="number">10</span>);</span><br><span class="line">       <span class="comment">//如果没有继承过来即s1对象中不会有age属性，那么调用getAge()方法也会找不到age而报错</span></span><br><span class="line">        <span class="comment">//能通过getAge方法获取private属性age说明子类会把父类声明private的属性也继承过来</span></span><br><span class="line">        System.out.println(s1.getAge());<span class="comment">//10 说明是继承过来了</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继承父类的属性不用自己重复写了</span></span><br><span class="line"><span class="comment">//    String name;</span></span><br><span class="line"><span class="comment">//    int age;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子类继承父类以后，还可以声明自己的属性或方法：实现功能的拓展</span></span><br><span class="line">    String major;<span class="comment">//年级---声明自己的属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, String major)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="comment">//        this.age = age;//父类的私有属性子类不能调了！</span></span><br><span class="line">        <span class="keyword">this</span>.getAge();</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//继承父类的方法不用自己重复写了</span></span><br><span class="line"><span class="comment">//    public void eat() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("恰饭");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    public void sleep() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("睡觉");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子类可与声明自己的属性或方法,实现功能的拓展</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java关于继承性的规定："><a href="#Java关于继承性的规定：" class="headerlink" title="Java关于继承性的规定："></a>Java关于继承性的规定：</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/45.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/46.jpg" class="lozad"></p>
<ol>
<li>一个类可以被多个子类继承</li>
<li>Java中类的单继承性：一个类只能有一个父类</li>
<li>子父类是相对的概念：一个子类也有可能是别的类的父类</li>
<li>子类直接继承的父类，称为：直接父类。间接继承的父类成为：间接父类</li>
<li>子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</li>
</ol>
<hr>
<p>讲到直接和间接的继承关系，就不得不提到Java中默认被所有类所有类直接或间接继承的类!</p>
<h3 id="拓展：初探Object类"><a href="#拓展：初探Object类" class="headerlink" title="拓展：初探Object类"></a><strong>拓展：初探Object类</strong></h3><p>我们随便声明一个Person类，里面没有任何结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中new一个Person类的对象，通过”.”的方式发现Eclipse给我列出了一些不知从何而来的方法？并且说明了它们来自Object类！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/47.jpg" class="lozad"></p>
<p>这说明如果我们没有显式的声明一个类的父类的话，则此类继承于<code>java.lang.Object</code>类</p>
<p>上面我们说到子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法的结论：可以推导出：<br>所有的java类（除j<code>ava.lang.Object</code>类之外）都直接或间接地继承于<code>Java.lang.Object</code>类。<br>也就意味着，所有的java类具有<code>java.lang.Obeject</code>类声明的功能</p>
<p>所以Object也叫做根父类，它是所有类的父类！</p>
<hr>
<blockquote>
<p>这里的只是简单的引入下Object类，具体Object类的使用我们后面的另外起模块讲解！ </p>
<p>了解了继承性之后我们就可以在此基础上学习更多主线中的知识点了</p>
</blockquote>
<h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/48.jpg" class="lozad"></p>
<p>方法的重写这块知识点其实并不难，老规矩，东西都写在代码块中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 方法的重写(override / overwrite)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. 重写的规定：</span></span><br><span class="line"><span class="comment"> *          方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型&#123;</span></span><br><span class="line"><span class="comment"> *                      //方法体</span></span><br><span class="line"><span class="comment"> *                  &#125;</span></span><br><span class="line"><span class="comment"> *          约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      ① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同	</span></span><br><span class="line"><span class="comment"> *      ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符（可以大于）</span></span><br><span class="line"><span class="comment"> *          &gt;特殊情况：子类不能重写父类中声明为private权限的方法</span></span><br><span class="line"><span class="comment"> *      ③ 返回值类型：</span></span><br><span class="line"><span class="comment"> *          &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</span></span><br><span class="line"><span class="comment"> *          &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</span></span><br><span class="line"><span class="comment"> *          &gt;父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</span></span><br><span class="line"><span class="comment"> *      ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到JavaSE高级篇去说）</span></span><br><span class="line"><span class="comment"> *  **********************************************************************</span></span><br><span class="line"><span class="comment"> *      子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。 具体放在static关键字模块中再去介绍   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">"IT"</span>);</span><br><span class="line">        s.walk(<span class="number">10</span>);<span class="comment">//输出的了Person类中的show引证了3.②的结论</span></span><br><span class="line">        s.study();</span><br><span class="line">        </span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">      <span class="comment">//重写以后，当创建子类对象后，通过子类对象调用父类中的同名同参数的方法时，实际执行的是子类重写父类的方法</span></span><br><span class="line">        s.eat();</span><br><span class="line">        p.eat();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"走路：走了"</span> + distance + <span class="string">"公里"</span>);</span><br><span class="line">        show();<span class="comment">//private无法重写，所以调用的是父类的show</span></span><br><span class="line">        eat();<span class="comment">//eat方法被重写，所以调用的是子类的eat()</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子类不能重写父类中声明为private权限的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一个人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String major;<span class="comment">// 专业</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String major)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习：专业是"</span> + major);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对父类中的eat方法进行了重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生在学生饭堂恰鸡腿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</span></span><br><span class="line">    <span class="comment">// 父类是Public，此时编译报错</span></span><br><span class="line"><span class="comment">//    void eat() &#123;</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 子类不能重写父类中声明为private权限的方法（这里就没有构成重写了）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一个学生"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="再看4种权限修饰符"><a href="#再看4种权限修饰符" class="headerlink" title="再看4种权限修饰符"></a>再看4种权限修饰符</h2><blockquote>
<p>4种权限修饰符是Java面向对象中三大特性中的封装性的实现前提，我们使用4种权限修饰符来对类及类的结构设置对于外界可见度的大小实现封装。</p>
<p>对在封装性的模块中我们介绍到了4种权限修饰符的三种：pulibc、缺省和private。还有一种权限修饰符protected没有介绍，因为它的内容需要涉及到子类父类即类与类的继承关系的概念。所以放到这里再次引入。希望能在这里对四种权限修饰进一步体会。</p>
</blockquote>
<p>再次回归一下四种权限修饰符：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/49.jpg" class="lozad"></p>
<p>在代码中体会4种不同的权限修饰</p>
<p>在同一个包中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.deehuang.java1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 体会4种不同的权限修饰</span></span><br><span class="line"><span class="comment"> * 用不同的修饰符修饰类中的属性和方法，变量的名见名知意</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Order order = <span class="keyword">new</span> Order();</span><br><span class="line">		</span><br><span class="line">		order.orderDefault = <span class="number">1</span>;</span><br><span class="line">		order.orderProtected = <span class="number">2</span>;</span><br><span class="line">		order.orderPublic = <span class="number">3</span>;</span><br><span class="line">		</span><br><span class="line">		order.methodDefault();</span><br><span class="line">		order.methodProtected();</span><br><span class="line">		order.methodPublic();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//同一个包中的其他类，不可以调用Order类中私有的属性、方法</span></span><br><span class="line"><span class="comment">//		order.orderPrivate = 4;//编译失败</span></span><br><span class="line"><span class="comment">//		order.methodPrivate();//编译失败</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> orderPrivate;</span><br><span class="line">	<span class="keyword">int</span> orderDefault;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> orderProtected;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> orderPublic;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//在同一个类中，四种修饰符修饰的类的成员都可以随意调用</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		orderPrivate = <span class="number">1</span>;</span><br><span class="line">		orderDefault = <span class="number">2</span>;</span><br><span class="line">		orderProtected = <span class="number">3</span>;</span><br><span class="line">		orderPublic = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">		orderPrivate = <span class="number">1</span>;</span><br><span class="line">		orderDefault = <span class="number">2</span>;</span><br><span class="line">		orderProtected = <span class="number">3</span>;</span><br><span class="line">		orderPublic = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">methodProtected</span><span class="params">()</span></span>&#123;</span><br><span class="line">		orderPrivate = <span class="number">1</span>;</span><br><span class="line">		orderDefault = <span class="number">2</span>;</span><br><span class="line">		orderProtected = <span class="number">3</span>;</span><br><span class="line">		orderPublic = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line">		orderPrivate = <span class="number">1</span>;</span><br><span class="line">		orderDefault = <span class="number">2</span>;</span><br><span class="line">		orderProtected = <span class="number">3</span>;</span><br><span class="line">		orderPublic = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同的包中，声明一个SubOder类继承上面不同包下的Order类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.deehuang.java2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">package</span> io.github.deehuang.java1.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOrder</span> <span class="keyword">extends</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		orderProtected = <span class="number">1</span>;</span><br><span class="line">		orderPublic = <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		methodProtected();</span><br><span class="line">		methodPublic();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法</span></span><br><span class="line"><span class="comment">//		orderDefault = 3;//编译失败</span></span><br><span class="line"><span class="comment">//		orderPrivate = 4;//编译失败</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		methodDefault();//编译失败</span></span><br><span class="line"><span class="comment">//		methodPrivate();//编译失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同的包声明一个与Order没有关系的OderTest类再进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.deehuang.java2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.deehuang.java1.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Order order = <span class="keyword">new</span> Order();</span><br><span class="line">		order.orderPublic = <span class="number">1</span>;</span><br><span class="line">		order.methodPublic();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//不同包下的普通类（非子类）要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法</span></span><br><span class="line"><span class="comment">//		order.orderPrivate = 2;//编译失败</span></span><br><span class="line"><span class="comment">//		order.orderDefault = 3;//编译失败</span></span><br><span class="line"><span class="comment">//		order.orderProtected = 4;//编译失败</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		order.methodPrivate();//编译失败</span></span><br><span class="line"><span class="comment">//		order.methodDefault();//编译失败</span></span><br><span class="line"><span class="comment">//		order.methodProtected();//编译失败</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在别的地方使用调对象.方法的形式去调对象.属性or方法也是如此</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">		order.orderPublic = <span class="number">1</span>;</span><br><span class="line">		order.methodPublic();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//不同包下的普通类（非子类）要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法</span></span><br><span class="line"><span class="comment">//		order.orderPrivate = 2;//编译失败</span></span><br><span class="line"><span class="comment">//		order.orderDefault = 3;//编译失败</span></span><br><span class="line"><span class="comment">//		order.orderProtected = 4;//编译失败</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		order.methodPrivate();//编译失败</span></span><br><span class="line"><span class="comment">//		order.methodDefault();//编译失败</span></span><br><span class="line"><span class="comment">//		order.methodProtected();//编译失败</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发中，一般不是用最小(private)就是用最大(public)的权限修饰符，所以也不用花太多时间在这上边去搞清楚各种花样的调取方式。</p>
<h2 id="关键字：super"><a href="#关键字：super" class="headerlink" title="关键字：super"></a>关键字：super</h2><h3 id="super的使用"><a href="#super的使用" class="headerlink" title="super的使用"></a>super的使用</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/50.jpg" class="lozad"></p>
<p><strong>this表示本类对象的引用，super代表父类的内存空间的标识</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/51.jpg" class="lozad"></p>
<p>老规矩，在代码块中叙述知识点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * super关键字的使用</span></span><br><span class="line"><span class="comment"> * 1.super理解为：父类的</span></span><br><span class="line"><span class="comment"> * 2.super可以用来调用：属性、方法、构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.super的使用：调用属性和方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   3.1 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用</span></span><br><span class="line"><span class="comment"> *   父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."</span></span><br><span class="line"><span class="comment"> *   3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的</span></span><br><span class="line"><span class="comment"> *   使用"super.属性"的方式，表明调用的是父类中声明的属性。</span></span><br><span class="line"><span class="comment"> *   3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。 </span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.super调用构造器</span></span><br><span class="line"><span class="comment"> * 	 4.1  我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器</span></span><br><span class="line"><span class="comment"> *   4.2 "super(形参列表)"的使用，必须声明在子类构造器的首行！</span></span><br><span class="line"><span class="comment"> *   4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现</span></span><br><span class="line"><span class="comment"> *   4.4 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()</span></span><br><span class="line"><span class="comment"> *   4.5 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Student s = <span class="keyword">new</span> Student();</span><br><span class="line">		s.show();</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		s.study();</span><br><span class="line">		</span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student(<span class="string">"deehuang"</span>, <span class="number">18</span>, <span class="string">"IT"</span>);</span><br><span class="line">		s1.show();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"************"</span>);</span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">1001</span>;<span class="comment">//身份证号</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()</span></span><br><span class="line">		System.out.println(<span class="string">"我无处不在！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"人：吃饭"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"人：走路"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	String major;</span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">1002</span>;<span class="comment">//学号 ps:属性不存在覆盖一说，故内存空间就有两个id变量了</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造器里即使什么都没写默认调的就是super();</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String major)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();<span class="comment">//调用父类的空参构造器，</span></span><br><span class="line">		<span class="keyword">this</span>.major = major;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age,String major)</span></span>&#123;</span><br><span class="line">        <span class="comment">//"super(形参列表)"的使用，必须声明在子类构造器的首行！</span></span><br><span class="line"><span class="comment">//		this.name = name;</span></span><br><span class="line"><span class="comment">//		this.age = age;</span></span><br><span class="line">		<span class="keyword">super</span>(name,age);</span><br><span class="line">		<span class="keyword">this</span>.major = major;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"学生：多吃有营养的食物"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"学生：学习知识"</span>);</span><br><span class="line">		<span class="keyword">this</span>.eat();<span class="comment">//在子类去找</span></span><br><span class="line">		<span class="keyword">super</span>.eat();<span class="comment">//在父类去找</span></span><br><span class="line">		walk();<span class="comment">//默认是this,现在自己这里找，找不到再去父类找</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"name = "</span> + name + <span class="string">", age = "</span> + age);</span><br><span class="line">        System.out.println(<span class="string">"id = "</span> + id);<span class="comment">//子类对象默认会调自己的属性，这里结果等于this.id</span></span><br><span class="line">		System.out.println(<span class="string">"id = "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">		System.out.println(<span class="string">"id = "</span> + <span class="keyword">super</span>.id);<span class="comment">//还想调父类的同名属性的话就需要使用super了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考一个问题：</p>
<p>为什么我们的子类能过用父类的属性和方法还有构造器？</p>
<p>这需要让我看去聊下我们子类对象实例化的过程是怎么样的了：</p>
<h3 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/59.jpg" class="lozad"></p>
<ol>
<li>从结果上来看（继承性）：<ul>
<li>子类继承父类以后，就获取了父类中声明的属性或方法</li>
<li>创建子类的对象，在堆空间中，就会加载所有父类声明的属性</li>
</ul>
</li>
<li>从过程上来看：<ul>
<li>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用其父类的构造器(必定有一个构造器会调用<code>super()</code>或者不写默认调的也是<code>super()</code> )，进而调用父类的构造器…….直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类的结构，子类对象才可以考虑调用。<br>看一组图：<img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/52.jpg" class="lozad">)<img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/58.jpg" class="lozad"></li>
</ul>
</li>
</ol>
<p>虽然！！！我们在内存中加载过所有父类的构造器，但是要明确一点的是，在内存中到底造了几个对象？？？<br>一个！一个！一个！只是造了我们new出来的一个对象！只有new构造器才能说造了一个对象。</p>
<p>明确：虽然创建子类对象时，调用了父类的构造器。但是自始至终就创建了一个对象，即new的子类对象。</p>
<p>思考：为什么super(…)或this(…)调用语句只能作为构造器的第一句出现？<br>    无论通过哪个构造器创建子对象，需要保证先初始化父类。目的:当子类继承父类后，“继承”父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化(所以优先加载父类)</p>
<h2 id="面向对象特性之三：多态性"><a href="#面向对象特性之三：多态性" class="headerlink" title="面向对象特性之三：多态性"></a>面向对象特性之三：多态性</h2><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/53.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/54.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 面向对象特征之三：多态性</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.理解多态性：可以理解为一个事物的多种形态。</span></span><br><span class="line"><span class="comment"> * 2.何为多态性：</span></span><br><span class="line"><span class="comment"> *   对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> * 3. 多态的使用：虚拟方法调用</span></span><br><span class="line"><span class="comment"> *   有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</span></span><br><span class="line"><span class="comment"> *   总结：编译，看左边；运行，看右边。</span></span><br><span class="line"><span class="comment"> *	 注意: 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> * 4.多态性的使用前提：  ① 类的继承关系  ② 方法的重写</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5.对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">//之前我們是正常的創建一個對象并把它賦給相應類型的引用</span></span><br><span class="line">		Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">		p1.eat();<span class="comment">//正常的方法调用</span></span><br><span class="line">		</span><br><span class="line">		Man man = <span class="keyword">new</span> Man();</span><br><span class="line">		man.eat();<span class="comment">//正常的方法调用</span></span><br><span class="line">		man.age = <span class="number">25</span>;</span><br><span class="line">		man.earnMoney();<span class="comment">//正常的方法调用</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//*************************************************</span></span><br><span class="line">		<span class="comment">//理解多态性：可以理解为一个事物的多种形态。</span></span><br><span class="line">		System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//对象的多态性：父类的引用指向子类的对象</span></span><br><span class="line">		Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="comment">//		Person p3 = new Woman();</span></span><br><span class="line">		<span class="comment">//多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法 ---虚拟方法调用</span></span><br><span class="line">		p2.eat();</span><br><span class="line">		p2.walk();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//编译时子类只能调用父类中声明过的方法，因为编译的时候看的是变量声明的类型(左边)中是否有你要的类的结构</span></span><br><span class="line">		<span class="comment">//当正在执行的时候才会发现子类的重写方法(右边)从而调用</span></span><br><span class="line"><span class="comment">//		p2.earnMoney();//编译失败</span></span><br><span class="line">        <span class="comment">//属性是在编译时确定的，编译时p2为Person类型，没有earnMoney成员变量，因而编译错误。</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(p2.id);<span class="comment">//1001?1002？</span></span><br><span class="line">        <span class="comment">//答案是1001！说明对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span> isSmoking;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">1002</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earnMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"男人负责挣钱养家"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"男人多吃肉，长肌肉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"男人霸气的走路"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span> isBeauty;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShopping</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"女人喜欢购物"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"女人少吃，为了减肥"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"女人窈窕的走路"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要有多态呢？多态的使用最明显的好处就是不用频繁的去写重载方法了！这一点很好理解，可以在后面开发中慢慢体会。</p>
<h3 id="虚拟方法调用"><a href="#虚拟方法调用" class="headerlink" title="虚拟方法调用"></a>虚拟方法调用</h3><p>这里还要再多讲讲<strong>虚拟方法调用</strong>，因为它是多态的重点！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/55.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/56.jpg" class="lozad"></p>
<p>上面提到动态绑定的概念：我们来从编译的角度看看重载和重写的不同来认识动态绑定和静态绑定：</p>
<p>重载不表现为多态性（编译和运行调用的都是父类的）</p>
<p>重写表现为多态性（编译认为调用是父类，执行的是子类对象—虚拟方法调用）</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/57.jpg" class="lozad"></p>
<h3 id="向下转型的使用"><a href="#向下转型的使用" class="headerlink" title="向下转型的使用"></a>向下转型的使用</h3><p>有了对象的多态性以后，内存中实际是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p>
<p>既然内存中是有子类的属性和方法的那就说明它肯定是可以调用的，只是在编译的时候认为是没有罢了。那么我们怎么才能调用子类特有的属性和方法？这就需要使用向下转型了—使用强制类型转换符！</p>
<p>它和我们基本数据类型的类型转换有点相似，来看看它们的区别：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/62.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/60.jpg" class="lozad"></p>
<p>强转类型是可能失败的，转换只能是多态的情况下把父类变量强行转换成子类变量让我们可以调用子类对象的方法。试想如果你把一个男人类强行转换成女人类…这明显就不合理了！所以如果我们硬是转非多态情况下的引用类型，运行就会报错！（编译是可以通过的）。<br>为了避免这种运行错误的发生，我们要只能防范于未然，在开发中我们使用instanceof操作符来验证一个一个对象是否是一个类的对象。它的返回值是boolean型</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/61.jpg" class="lozad"></p>
<p>还是用上面的Person与Man和Woman类举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">		<span class="comment">//对象的多态性：父类的引用指向子类的对象</span></span><br><span class="line">		Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="comment">//		Person p3 = new Woman();</span></span><br><span class="line">		<span class="comment">//多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法 ---虚拟方法调用</span></span><br><span class="line">		p2.eat();</span><br><span class="line">		p2.walk();</span><br><span class="line">		System.out.println(<span class="string">"****************************"</span>);</span><br><span class="line">		<span class="comment">//不能调用子类所特有的方法、属性：编译时，p2是Person类型。</span></span><br><span class="line">		p2.name = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="comment">//		p2.earnMoney();</span></span><br><span class="line"><span class="comment">//		p2.isSmoking = true;</span></span><br><span class="line">		<span class="comment">//有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致</span></span><br><span class="line">		<span class="comment">//编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如何才能调用子类特有的属性和方法？</span></span><br><span class="line">		<span class="comment">//向下转型：使用强制类型转换符。</span></span><br><span class="line">		Man m1 = (Man)p2;</span><br><span class="line">		m1.earnMoney();</span><br><span class="line">		m1.isSmoking = <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用强转时，可能出现ClassCastException的异常。</span></span><br><span class="line"><span class="comment">//		Woman w1 = (Woman)p2;</span></span><br><span class="line"><span class="comment">//		w1.goShopping();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * instanceof关键字的使用</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 *  使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先</span></span><br><span class="line"><span class="comment">		 *  进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 *  如果 a instanceof A返回true,则 a instanceof B也返回true.</span></span><br><span class="line"><span class="comment">		 *  其中，类B是类A的父类。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Woman)&#123;</span><br><span class="line">			Woman w1 = (Woman)p2;</span><br><span class="line">			w1.goShopping();</span><br><span class="line">			System.out.println(<span class="string">"******Woman******"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Man)&#123;</span><br><span class="line">			Man m2 = (Man)p2;</span><br><span class="line">			m2.earnMoney();</span><br><span class="line">			System.out.println(<span class="string">"******Man******"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果 a instanceof A返回true,则 a instanceof B也返回true.</span></span><br><span class="line">		<span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">			System.out.println(<span class="string">"******Person******"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Object)&#123;</span><br><span class="line">			System.out.println(<span class="string">"******Object******"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		if(p2 instanceof String)&#123;</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//练习：</span></span><br><span class="line">		<span class="comment">//问题一：编译时通过，运行时不通过</span></span><br><span class="line">		<span class="comment">//举例一：</span></span><br><span class="line"><span class="comment">//		Person p3 = new Woman();</span></span><br><span class="line"><span class="comment">//		Man m3 = (Man)p3;//编译认为P3是Person，使用向下转型符合要求。运行发现p3是Women，两个类没有继承关系，报类型转换错误。</span></span><br><span class="line">		<span class="comment">//举例二：</span></span><br><span class="line"><span class="comment">//		Person p4 = new Person();//非多态</span></span><br><span class="line"><span class="comment">//		Man m4 = (Man)p4;//使用向下转型不通过，连向上转型的前提都没有是不可以通过向下转型转回去的</span></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题二：编译通过，运行时也通过</span></span><br><span class="line"><span class="comment">//		Object obj = new Woman();</span></span><br><span class="line"><span class="comment">//		Person p = (Person)obj;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题三：编译不通过</span></span><br><span class="line"><span class="comment">//		Man m5 = new Woman();</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		String str = new Date();</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		Object o = new Date();//能骗过编译器，但是运行时不能过</span></span><br><span class="line"><span class="comment">//		String str1 = (String)o;</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span> isSmoking;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">1002</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earnMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"男人负责挣钱养家"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"男人多吃肉，长肌肉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"男人霸气的走路"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span> isBeauty;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goShopping</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"女人喜欢购物"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"女人少吃，为了减肥"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"女人窈窕的走路"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So,怎么理解多态性?（有些知识还没有讲到，这里可以先粗略的了解一下）</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/70.jpg" class="lozad"></p>
<hr>
<blockquote>
<p>至此面向对象的三大特性的知识点就介绍结束了。下面会对知识点做一些补充，例如继承中提到的所有类的父类Object类的使用，以及包装类（java的面向对象是针对类来讲的，基本数据类型用不了，为了完善面向对象，java对基本数据类型进行封装，就是我们引入的包装类）和其他关键字的使用。这两个常用类的使用知识点实际上与面向对象的主线无关，它们是我们开发中常用到的类，所以简单介绍一下</p>
</blockquote>
<h2 id="Object类的使用"><a href="#Object类的使用" class="headerlink" title="Object类的使用"></a>Object类的使用</h2><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/63.jpg" class="lozad"></p>
<p>Object类是所有类的根父类，所以其中的功能(属性和方法)就具有通用性。学习Object类的使用实际上就是学习它提供给我们的功能方法的使用,这里只介绍一些我们目前接触到的知识点的功能去说(因为有一些方法涉及到多进程多线程还有集合反射等知识)：</p>
<ul>
<li><p>Object类声明了一个空参的构造器</p>
</li>
<li><p><code>clone()</code>：复制一个对象，创建并返回一个对象的复制品(注意返回的是Object类型的对象)</p>
</li>
<li><p><code>finalize()</code>：垃圾回收方法，当没有任何的引用指向一个对象的时候，垃圾收集器就会在在回收对象前调用当前对象的finalize方法。(通常我们不主动去调，这个方法是垃圾回收器自己会去调用的)</p>
</li>
<li><p><code>getClass()</code>：获取当前对象的所属类</p>
</li>
<li><p><code>hashcode()</code>返回当前对象的哈希值</p>
</li>
<li><p><code>equals(Object obj)</code>：比较两个对象是否相等<br>== 和 equals的区别:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 面试题： == 和 equals() 区别</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、回顾 == 的使用：</span></span><br><span class="line"><span class="comment"> * == ：运算符</span></span><br><span class="line"><span class="comment"> * 1. 可以使用在基本数据类型变量和引用数据类型变量中</span></span><br><span class="line"><span class="comment"> * 2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</span></span><br><span class="line"><span class="comment"> *    如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</span></span><br><span class="line"><span class="comment"> * 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、equals()方法的使用：</span></span><br><span class="line"><span class="comment"> * 1. 是一个方法，而非运算符</span></span><br><span class="line"><span class="comment"> * 2. 只能适用于引用数据类型</span></span><br><span class="line"><span class="comment"> * 3. Object类中equals()的定义：</span></span><br><span class="line"><span class="comment"> *    public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">	        return (this == obj);</span></span><br><span class="line"><span class="comment">	  &#125;</span></span><br><span class="line"><span class="comment"> *    说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4. 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * 5. 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们就需要对Object类中的equals()进行重写.</span></span><br><span class="line"><span class="comment"> *    重写的原则：比较两个对象的实体内容是否相同.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//基本数据类型</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">double</span> d = <span class="number">10.0</span>;</span><br><span class="line">		System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line">		System.out.println(i == d);<span class="comment">//true，做运算：自动类型提升</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//		System.out.println(i == b);//基本数据类型之间运算不包括boolean型</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> c = <span class="number">10</span>;<span class="comment">//字符码值10与数字10是一样的</span></span><br><span class="line">		System.out.println(i == c);<span class="comment">//true</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br><span class="line">		<span class="keyword">char</span> c2 = <span class="number">65</span>;</span><br><span class="line">		System.out.println(c1 == c2);<span class="comment">//true，char参与运算自动类型提升为Int</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//引用类型</span></span><br><span class="line">		Customer cust1 = <span class="keyword">new</span> Customer(<span class="string">"Tom"</span>,<span class="number">21</span>);</span><br><span class="line">		Customer cust2 = <span class="keyword">new</span> Customer(<span class="string">"Tom"</span>,<span class="number">21</span>);</span><br><span class="line">		System.out.println(cust1 == cust2);<span class="comment">//false</span></span><br><span class="line">		<span class="comment">//比较的是两个对象的地址是否相同，即两个引用（变量名）是否指向同一个对象的实体</span></span><br><span class="line">		</span><br><span class="line">		String str1 = <span class="keyword">new</span> String(<span class="string">"deehuang"</span>);</span><br><span class="line">		String str2 = <span class="keyword">new</span> String(<span class="string">"deehuang"</span>);</span><br><span class="line">		System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"****************************"</span>);</span><br><span class="line">		System.out.println(cust1.equals(cust2));<span class="comment">//false---&gt;true</span></span><br><span class="line">		<span class="comment">//Object类中的equals()和==的作用是相同的，比较两个引用是否指向同一个实体</span></span><br><span class="line">		<span class="comment">//像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。</span></span><br><span class="line">		System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line">		<span class="comment">//String的euals方法进行过重写，所以不会按Object的方法进行声明了，String比较的是字符串是否相同</span></span><br><span class="line">		</span><br><span class="line">		Date date1 = <span class="keyword">new</span> Date(<span class="number">32432525324L</span>);</span><br><span class="line">		Date date2 = <span class="keyword">new</span> Date(<span class="number">32432525324L</span>);</span><br><span class="line">		System.out.println(date1.equals(date2));<span class="comment">//true</span></span><br><span class="line">		<span class="comment">//Date的euals方法进行过重写，所以不会按Object的方法进行声明了，Date比较的是时间戳(毫秒数)是否相同</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> name;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.name = name;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> age;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.age = age;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">super</span>();</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">super</span>();</span><br><span class="line">  		<span class="keyword">this</span>.name = name;</span><br><span class="line">  		<span class="keyword">this</span>.age = age;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//自动生成的equals()，eclipse中的source中的generate equals()</span></span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  		<span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  		Customer other = (Customer) obj;</span><br><span class="line">  		<span class="keyword">if</span> (age != other.age)</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  		<span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">  				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//重写的原则：比较两个对象的实体内容(即：name和age)是否相同</span></span><br><span class="line">  	<span class="comment">//手动实现equals()的重写</span></span><br><span class="line">  <span class="comment">//	@Override</span></span><br><span class="line">  <span class="comment">//	public boolean equals(Object obj) &#123;</span></span><br><span class="line">  <span class="comment">//		</span></span><br><span class="line">  <span class="comment">////		System.out.println("Customer equals()....");</span></span><br><span class="line">  <span class="comment">//		if (this == obj) &#123;</span></span><br><span class="line">  <span class="comment">//            return true;</span></span><br><span class="line">  <span class="comment">//        &#125;</span></span><br><span class="line">  <span class="comment">//		</span></span><br><span class="line">  <span class="comment">//		if(obj instanceof Customer)&#123;</span></span><br><span class="line">  <span class="comment">//			Customer cust = (Customer)obj;</span></span><br><span class="line">  <span class="comment">//			//比较两个对象的每个属性是否都相同</span></span><br><span class="line">  <span class="comment">////			if(this.age == cust.age &amp;&amp; this.name.equals(cust.name))&#123;</span></span><br><span class="line">  <span class="comment">////				return true;</span></span><br><span class="line">  <span class="comment">////			&#125;else&#123;</span></span><br><span class="line">  <span class="comment">////				return false;</span></span><br><span class="line">  <span class="comment">////			&#125;</span></span><br><span class="line">  <span class="comment">//			</span></span><br><span class="line">  <span class="comment">//			//或</span></span><br><span class="line">  <span class="comment">//			return this.age == cust.age &amp;&amp; this.name.equals(cust.name);</span></span><br><span class="line">  <span class="comment">//		&#125;else&#123;</span></span><br><span class="line">  <span class="comment">//			return false;</span></span><br><span class="line">  <span class="comment">//			</span></span><br><span class="line">  <span class="comment">//		&#125;</span></span><br><span class="line">  <span class="comment">//		</span></span><br><span class="line">  <span class="comment">//	&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>总结：<img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/64.jpg" class="lozad"></p>
<ul>
<li><p><code>toString()</code>：使用<code>system.out.pirnt()</code>方法就是在调对象的<code>toString()</code>方法，它的作用就是输出字符串值</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/65.jpg" class="lozad"></p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object类中toString()的使用：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. Object类中toString()的定义：</span></span><br><span class="line"><span class="comment"> *   public String toString() &#123;</span></span><br><span class="line"><span class="comment">        return getClass().getName() + "@" + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. 像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回"实体内容"信息</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * 4. 自定义类也可以重写toString()方法，当调用此方法时，返回对象的"实体内容"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Customer cust1 = <span class="keyword">new</span> Customer(<span class="string">"Tom"</span>,<span class="number">21</span>);</span><br><span class="line">		System.out.println(cust1.toString());<span class="comment">//io.github.deehuang.java1.Customer@15db9742</span></span><br><span class="line">		System.out.println(cust1);<span class="comment">//cio.github.deehuang.java1.Customer@15db9742</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回"实体内容"信息</span></span><br><span class="line">		String str = <span class="keyword">new</span> String(<span class="string">"MM"</span>);</span><br><span class="line">		System.out.println(str);<span class="comment">//MM</span></span><br><span class="line">        <span class="comment">//String里面重写了toString所以输出的不是地址值</span></span><br><span class="line">		</span><br><span class="line">		Date date = <span class="keyword">new</span> Date(<span class="number">4534534534543L</span>);</span><br><span class="line">		System.out.println(date.toString());<span class="comment">//Mon Sep 11 08:55:34 CST 2113</span></span><br><span class="line">        <span class="comment">//Date里面重写了toString所以输出的不是地址值</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动实现</span></span><br><span class="line"><span class="comment">//	@Override</span></span><br><span class="line"><span class="comment">//	public String toString() &#123;</span></span><br><span class="line"><span class="comment">//		return "Customer[name = " + name + ",age = " + age + "]"; </span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//自动实现eclipse中的source中的generate toString()</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Customer [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包装类-wrapper-的使用"><a href="#包装类-wrapper-的使用" class="headerlink" title="包装类(wrapper)的使用"></a>包装类(wrapper)的使用</h2><blockquote>
<p>我们希望Java中的基本数据类型变量也具有面向对象的特征和功能，所以我们给每个基本数据类型进行封装，对基本数据类型封装的类就是我们的包装类</p>
</blockquote>
<p><strong>java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征:</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/66.jpg" class="lozad"></p>
<p>​    JDK5.0加入了自动装箱和拆箱的新特性，使得我们的基本数据类型能赋给包装类型的变量(自动装箱)或把包装类对象赋值给基本数据类型变量(自动拆箱)但前提是类型必须匹配！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/67.jpg" class="lozad"></p>
<p><strong>基本数据类型、包装类、String三者之间的相互转换:</strong><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/68.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/69.jpg" class="lozad"></p>
<p>还是通过代码去学习理解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 包装类的使用:</span></span><br><span class="line"><span class="comment"> * 1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.掌握的：基本数据类型、包装类、String三者之间的相互转换</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">//基本数据类型 ---&gt;包装类：调用包装类的构造器</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//		System.out.println(num1.toString());</span></span><br><span class="line">		Integer in1 = <span class="keyword">new</span> Integer(num1);<span class="comment">//调用包装类的构造器</span></span><br><span class="line">		System.out.println(in1.toString());</span><br><span class="line">		<span class="comment">//包装类重写了ToString方法，输出的是实体内容，而不是地址值</span></span><br><span class="line">		</span><br><span class="line">		Integer in2 = <span class="keyword">new</span> Integer(<span class="string">"123"</span>);<span class="comment">//还可以放String</span></span><br><span class="line">		System.out.println(in2.toString());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//报异常,abc不是数</span></span><br><span class="line"><span class="comment">//		Integer in3 = new Integer("123abc");</span></span><br><span class="line"><span class="comment">//		System.out.println(in3.toString());</span></span><br><span class="line">		</span><br><span class="line">		Float f1 = <span class="keyword">new</span> Float(<span class="number">12.3f</span>);</span><br><span class="line">		Float f2 = <span class="keyword">new</span> Float(<span class="string">"12.3"</span>);</span><br><span class="line">		System.out.println(f1);</span><br><span class="line">		System.out.println(f2);</span><br><span class="line">		</span><br><span class="line">		Boolean b1 = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line">		Boolean b2 = <span class="keyword">new</span> Boolean(<span class="string">"TrUe"</span>);<span class="comment">//忽略大小写</span></span><br><span class="line">		System.out.println(b2);<span class="comment">//true</span></span><br><span class="line">		Boolean b3 = <span class="keyword">new</span> Boolean(<span class="string">"true123"</span>);</span><br><span class="line">		System.out.println(b3);<span class="comment">//false</span></span><br><span class="line">		<span class="comment">//只要不是true传入其他实参都会被当做是false</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Order order = <span class="keyword">new</span> Order();</span><br><span class="line">		System.out.println(order.isMale);<span class="comment">//false</span></span><br><span class="line">		System.out.println(order.isFemale);<span class="comment">//null,已经是个类了</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//包装类---&gt;基本数据类型:调用包装类Xxx的xxxValue()</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Integer in1 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">		<span class="keyword">int</span> i1 = in1.intValue();</span><br><span class="line">		System.out.println(i1 + <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Float f1 = <span class="keyword">new</span> Float(<span class="number">12.3</span>);</span><br><span class="line">		<span class="keyword">float</span> f2 = f1.floatValue();</span><br><span class="line">		System.out.println(f2 + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * JDK 5.0 新特性：自动装箱 与自动拆箱</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//		int num1 = 10;</span></span><br><span class="line"><span class="comment">//		//基本数据类型--&gt;包装类的对象</span></span><br><span class="line"><span class="comment">//		method(num1);//基本数据类型没法丢到需要接收实参是引用类型的方法中</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//自动装箱：基本数据类型 ---&gt;包装类</span></span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">		Integer in1 = num2;<span class="comment">//自动装箱</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">		Boolean b2 = b1;<span class="comment">//自动装箱</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//自动拆箱：包装类---&gt;基本数据类型</span></span><br><span class="line">		System.out.println(in1.toString());</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> num3 = in1;<span class="comment">//自动拆箱</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//基本数据类型、包装类---&gt;String类型：调用String重载的valueOf(Xxx xxx)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">		<span class="comment">//方式1：连接运算</span></span><br><span class="line">		String str1 = num1 + <span class="string">""</span>;</span><br><span class="line">		<span class="comment">//方式2：调用String的valueOf(Xxx xxx)</span></span><br><span class="line">		<span class="keyword">float</span> f1 = <span class="number">12.3f</span>;</span><br><span class="line">		String str2 = String.valueOf(f1);<span class="comment">//"12.3"</span></span><br><span class="line">		</span><br><span class="line">		Double d1 = <span class="keyword">new</span> Double(<span class="number">12.4</span>);</span><br><span class="line">		String str3 = String.valueOf(d1);</span><br><span class="line">		System.out.println(str2);</span><br><span class="line">		System.out.println(str3);<span class="comment">//"12.4"</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//String类型 ---&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String str1 = <span class="string">"123"</span>;</span><br><span class="line">		<span class="comment">//错误的情况：</span></span><br><span class="line">        <span class="comment">//两个没有子父类关系的类型进行强转编译报错</span></span><br><span class="line"><span class="comment">//		int num1 = (int)str1;</span></span><br><span class="line"><span class="comment">//		Integer in1 = (Integer)str1;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可能会报NumberFormatException</span></span><br><span class="line">        <span class="comment">//str1 = "123a"/ /a?? 报NumberFormatException,要确保数值是可以转换的！</span></span><br><span class="line">		<span class="keyword">int</span> num2 = Integer.parseInt(str1);</span><br><span class="line">		System.out.println(num2 + <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		String str2 = <span class="string">"true1"</span>;</span><br><span class="line">		<span class="keyword">boolean</span> b1 = Boolean.parseBoolean(str2);</span><br><span class="line">		System.out.println(b1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span> isMale;</span><br><span class="line">	Boolean isFemale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看三个包装类常见的面试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关于包装类使用的面试题</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(o1);<span class="comment">// 1.0</span></span><br><span class="line">        <span class="comment">//因为三元运算符在编译的时候会要求两个结构的类型是同一类型，所以会对进行自动类型提升，故结果就变成了1.0</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object o2;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">true</span>)</span><br><span class="line">			o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(o2);<span class="comment">// 1</span></span><br><span class="line">        <span class="comment">//这里就没有要求自动类型提升了所以是1</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],</span></span><br><span class="line">		<span class="comment">//保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在</span></span><br><span class="line">		<span class="comment">//-128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率</span></span><br><span class="line">		</span><br><span class="line">		Integer m = <span class="number">1</span>;<span class="comment">//引用指向的是缓存数组里拿Integer对象</span></span><br><span class="line">		Integer n = <span class="number">1</span>;<span class="comment">//引用指向的是缓存数组Integer对象</span></span><br><span class="line">		System.out.println(m == n);<span class="comment">//true，因为指向的是同一个对象</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//超过了缓存数值的范围</span></span><br><span class="line">		Integer x = <span class="number">128</span>;<span class="comment">//相当于new了一个Integer对象</span></span><br><span class="line">		Integer y = <span class="number">128</span>;<span class="comment">//相当于new了一个Integer对象</span></span><br><span class="line">		System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他关键字及类的成员补充"><a href="#其他关键字及类的成员补充" class="headerlink" title="其他关键字及类的成员补充"></a>其他关键字及类的成员补充</h1><blockquote>
<p>有了前面的基础后就可以更好学习理解其他关键字和剩余两个类的成员了！</p>
</blockquote>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>到目前为止，当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过<code>new</code>关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。<br>我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下， <strong>某些特定的数据在内存空间里只有一份</strong>。例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。<br><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/71.jpg" class="lozad"><br>图中可以看到，因为中国是全部中国人公有的属性，这样的属性是没必要给每个实例对象分配单独的内存空间了（单独分配实在太浪费），这个时候我们就可以把这样的属性或者方法使用<code>Static</code>关键字声明为<strong>类属性（静态属性）</strong>或者<strong>类方法（静态方法）</strong>，这样这些属性和方法就实现类被所有对象所共享了！<br><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/72.jpg" class="lozad"></p>
<p>类属性和类方法的设计思想:</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/73.jpg" class="lozad"></p>
<h3 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h3><p>下面还是通过代码来看看static关键字的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * static关键字的使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.static:静态的</span></span><br><span class="line"><span class="comment"> * 2.static可以用来修饰：属性、方法、代码块、内部类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.使用static修饰属性：静态变量（或类变量）</span></span><br><span class="line"><span class="comment"> * 		3.1 属性，按是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)</span></span><br><span class="line"><span class="comment"> * 		   实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。           </span></span><br><span class="line"><span class="comment"> *         静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。             </span></span><br><span class="line"><span class="comment"> * 		3.2 static修饰属性的其他说明：</span></span><br><span class="line"><span class="comment"> * 			① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用</span></span><br><span class="line"><span class="comment"> *          ② 静态变量的加载要早于对象的创建。</span></span><br><span class="line"><span class="comment"> *          ③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</span></span><br><span class="line"><span class="comment"> *          ④ 类和对象能否调用类变量和实例变量：</span></span><br><span class="line"><span class="comment"> *          		类变量	实例变量</span></span><br><span class="line"><span class="comment"> *          类		yes		no</span></span><br><span class="line"><span class="comment"> *          对象	   yes	   yes</span></span><br><span class="line"><span class="comment"> *          </span></span><br><span class="line"><span class="comment"> *      3.3 静态属性举例：System.out; Math.PI;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.使用static修饰方法：静态方法</span></span><br><span class="line"><span class="comment"> * 		① 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用</span></span><br><span class="line"><span class="comment"> * 		②			静态方法	非静态方法</span></span><br><span class="line"><span class="comment"> *          类		 yes		 no</span></span><br><span class="line"><span class="comment"> *          对象		yes		    yes</span></span><br><span class="line"><span class="comment"> * 		③ 静态方法中，只能调用静态的方法或属性</span></span><br><span class="line"><span class="comment"> *        非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5. static注意点：</span></span><br><span class="line"><span class="comment"> *    5.1 在静态的方法内，不能使用this关键字、super关键字</span></span><br><span class="line"><span class="comment"> *		当你点击编译按钮时，也就是类加载时静态方法就被加载到了内存区，静态方法被优先执行，而此时对象都没被加载呢。this是当前类的对象，可想而知在静态方法执行的时候它还不存在呢，因此在静态方法中通过this调用其他任何东西都是扯淡。所以当然不能在静态方法区中使用this,super也是同理。</span></span><br><span class="line"><span class="comment"> *    5.2 关于静态属性和静态方法的使用，大家都从生命周期（类和对象的生命周期）的角度去理解。</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * 6. 开发中，如何确定一个属性是否要声明为static的？</span></span><br><span class="line"><span class="comment"> * 		&gt; 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</span></span><br><span class="line"><span class="comment"> * 		&gt; 类中的常量也常常声明为static</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    开发中，如何确定一个方法是否要声明为static的？</span></span><br><span class="line"><span class="comment"> *    	&gt; 操作静态属性的方法，通常设置为static的</span></span><br><span class="line"><span class="comment"> *      &gt; 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用</span></span><br><span class="line">		<span class="comment">// 静态变量的加载要早于对象的创建。</span></span><br><span class="line">		<span class="comment">//由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</span></span><br><span class="line">		Chinese.nation = <span class="string">"中国"</span>;</span><br><span class="line">		</span><br><span class="line">		Chinese c1 = <span class="keyword">new</span> Chinese();</span><br><span class="line">		c1.name = <span class="string">"姚明"</span>;</span><br><span class="line">		c1.age = <span class="number">40</span>;</span><br><span class="line">		c1.nation = <span class="string">"CHN"</span>;</span><br><span class="line">		</span><br><span class="line">		Chinese c2 = <span class="keyword">new</span> Chinese();</span><br><span class="line">		c2.name = <span class="string">"马龙"</span>;</span><br><span class="line">		c2.age = <span class="number">30</span>;</span><br><span class="line">		c2.nation = <span class="string">"CHINA"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//静态属性举例：System.out</span></span><br><span class="line">		System.out.println(c1.nation);<span class="comment">//CHINA，c2改了后c1的也会跟着改，这就是静态结构</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//编译不通过，使用类去调实例属性，是调不了滴，试想一下每个对象都有自己的一套属性，这样调是调哪个对象的？</span></span><br><span class="line"><span class="comment">//		Chinese.name = "张继科";</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//实例调用非静态方法</span></span><br><span class="line">		c1.eat();</span><br><span class="line">		 <span class="comment">//使用static修饰方法：静态方法</span></span><br><span class="line">		<span class="comment">// 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用</span></span><br><span class="line">		Chinese.show();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//编译不通过，类无法调用非静态方法，试想一下每个对象都有自己的一套方法，这样调是调哪个对象的？</span></span><br><span class="line"><span class="comment">//		Chinese.eat();</span></span><br><span class="line"><span class="comment">//		Chinese.info();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中国人</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">static</span> String nation;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"中国人吃中餐"</span>);</span><br><span class="line">		<span class="comment">//非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</span></span><br><span class="line">		<span class="comment">//调用非静态结构</span></span><br><span class="line">		<span class="keyword">this</span>.info();</span><br><span class="line">		System.out.println(<span class="string">"name :"</span> +name);</span><br><span class="line">		<span class="comment">//调用静态结构</span></span><br><span class="line">		walk();</span><br><span class="line">		System.out.println(<span class="string">"nation : "</span> + nation);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//静态方法随着类的加载而加载</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是一个中国人！"</span>);</span><br><span class="line">		<span class="comment">//静态方法中，只能调用静态的方法或属性</span></span><br><span class="line">		<span class="comment">//不能调用非静态的结构</span></span><br><span class="line"><span class="comment">//		eat();</span></span><br><span class="line"><span class="comment">//		name = "Tom";</span></span><br><span class="line">		<span class="comment">//可以调用静态的结构</span></span><br><span class="line">		System.out.println(Chinese.nation);</span><br><span class="line">		walk();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"name :"</span> + name +<span class="string">",age : "</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li><p>因为不需要实例就可以访问static方法，因此static方法内部不能有this。 (也不能有super ? YES!)</p>
</li>
<li><p>static修饰的方法不能被重写， 重写方法的目的是为了多态，或者说：重写是实现多态的前提，即重写是发生在继承中且是针对非static方法的。  语法上子类允许出现和父类只有方法体不一样其他都一模一样的static方法，但是在父类引用指向子类对象时，通过父类引用调用的依然是父类的static方法，而不是子类的static方法。 </p>
</li>
<li><p>说到static应该马上想到随着类的加载而加载（所以static也不会去修饰类），主要是用来修饰类的内部结构，不能修饰构造器，因为构造器是处于类和对象之间的一道过程！它不会随着类的加载而加载，需要主动调用。</p>
</li>
</ul>
<h3 id="类变量和实例变量的内存解析"><a href="#类变量和实例变量的内存解析" class="headerlink" title="类变量和实例变量的内存解析"></a>类变量和实例变量的内存解析</h3><p>要了解类变量的内存解析，我们就要引入一个新的内存结构：方法区</p>
<p>栈主要存放的是局部变量；<br>堆放的是new出来的结构：对象和数组<br>方法区：类的加载信息、静态域、常量池。我们这里主要了解下静态域的结构</p>
<p>我们还是老规矩通过一组代码和图解去理解：</p>
<p>类在被使用时被加载到内存中！类的静态属性会被加载到方法区中的静态域中—记忆法：static静态 域field也称属性。</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/74.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/75.jpg" class="lozad"><br><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/76.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/77.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/78.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/79.jpg" class="lozad"></p>
<p>通过图可以了解到，静态的属性放的位置只有一份！所以无论通过类还是不同的对象去调取修改的话，获得的结果也是修改之后的，即全局共享。</p>
<h2 id="理解main（）方法的语法"><a href="#理解main（）方法的语法" class="headerlink" title="理解main（）方法的语法"></a>理解main（）方法的语法</h2><blockquote>
<p>我们知道<code>main()</code>方法是程序的入口，开始学习的时候因为要运行程序，所以我们会直接记住它的构造去使用，但是不清楚它的“内涵”，在学习完前面的知识后我们发现，对于<code>main（）</code>方法的语法，它的每个关键字和形参我们都已经学习过了。在这里就可以清晰的展开它的详细的语法构造</p>
</blockquote>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/80.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> main()方法的使用说明：</span></span><br><span class="line"><span class="comment"> 1.main()方法作为程序的入口</span></span><br><span class="line"><span class="comment"> 2.main()也是一个普通的静态方法</span></span><br><span class="line"><span class="comment"> 3.main()方法也可以作为我们与控制台交互的方式(之前：使用Scanner)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//入口</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//main()方法也是一个普通的静态方法</span></span><br><span class="line">		Main.main(<span class="keyword">new</span> String[<span class="number">100</span>]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//静态里面只能调静态，要调用非静态的属性和方法必须实例化对象，通过对象去调</span></span><br><span class="line">		MainTest test = <span class="keyword">new</span> MainTest();</span><br><span class="line">		test.show();</span><br><span class="line">		</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">			args[i] = <span class="string">"args_"</span> + i;</span><br><span class="line">			System.out.println(args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>main()方法也可以作为我们与控制台交互的方式(之前：使用Scanner)</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/81.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/82.jpg" class="lozad"></p>
<p>通过main方法也可以总结出许多面向对象的知识：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/90.jpg" class="lozad"></p>
<h2 id="类的成员之四：代码块"><a href="#类的成员之四：代码块" class="headerlink" title="类的成员之四：代码块"></a>类的成员之四：代码块</h2><h3 id="代码块的使用"><a href="#代码块的使用" class="headerlink" title="代码块的使用"></a>代码块的使用</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/83.jpg" class="lozad"></p>
<p>代码块就是一对{}</p>
<p>还是通过代码去认识：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类的成员之四：代码块（或初始化块）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 代码块的作用：用来初始化类、对象</span></span><br><span class="line"><span class="comment"> * 2. 代码块如果有修饰的话，只能使用static.</span></span><br><span class="line"><span class="comment"> * 3. 分类：静态代码块  vs 非静态代码块</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4. 静态代码块</span></span><br><span class="line"><span class="comment"> * 	   &gt;内部可以有输出语句</span></span><br><span class="line"><span class="comment"> * 	   &gt;随着类的加载而执行,而且只执行一次</span></span><br><span class="line"><span class="comment"> * 	   &gt;作用：初始化类的信息</span></span><br><span class="line"><span class="comment"> * 	   &gt;如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</span></span><br><span class="line"><span class="comment"> * 	   &gt;静态代码块的执行要优先于非静态代码块的执行</span></span><br><span class="line"><span class="comment"> * 	   &gt;静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5. 非静态代码块</span></span><br><span class="line"><span class="comment"> * 		&gt;内部可以有输出语句</span></span><br><span class="line"><span class="comment"> * 		&gt;随着对象的创建而执行</span></span><br><span class="line"><span class="comment"> * 		&gt;每创建一个对象，就执行一次非静态代码块</span></span><br><span class="line"><span class="comment"> * 		&gt;作用：可以在创建对象时，对对象的属性等进行初始化</span></span><br><span class="line"><span class="comment"> * 		&gt;如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</span></span><br><span class="line"><span class="comment"> * 		&gt;非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		String desc = Person.desc;<span class="comment">//静态代码块随着类的加载而执行,</span></span><br><span class="line">		Person.info();<span class="comment">//而且只执行一次</span></span><br><span class="line">		System.out.println(desc); </span><br><span class="line">		</span><br><span class="line">		Person p1 = <span class="keyword">new</span> Person();<span class="comment">//非静态代码块随着对象的创建而执行</span></span><br><span class="line">		Person p2 = <span class="keyword">new</span> Person();<span class="comment">//每造一个对象都执行非静态代码块一次</span></span><br><span class="line">		System.out.println(p1.age);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> String desc = <span class="string">"我是一个人"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//代码块如果有修饰的话，只能使用static.---静态代码块  vs 非静态代码块</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//非static的代码块</span></span><br><span class="line">	<span class="comment">//如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello, block - 2"</span>);<span class="comment">//可以有输出语句</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello, block - 1"</span>);</span><br><span class="line">		<span class="comment">//调用非静态结构</span></span><br><span class="line">		age = <span class="number">1</span>;<span class="comment">//作用：可以在创建对象时，对对象的属性等进行初始化</span></span><br><span class="line">		eat();</span><br><span class="line">		<span class="comment">//调用静态结构，类的加载早于对象，所以调用静态的结构是完全可以的</span></span><br><span class="line">		desc = <span class="string">"我是一个爱学习的人1"</span>;</span><br><span class="line">		info();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static的代码块</span></span><br><span class="line">	<span class="comment">//如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello,static block-2"</span>);<span class="comment">//可以有输出语句</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello,static block-1"</span>);</span><br><span class="line">		<span class="comment">//调用静态结构</span></span><br><span class="line">		desc = <span class="string">"我是一个爱学习的人"</span>;<span class="comment">//作用：初始化类的信息</span></span><br><span class="line">		info();</span><br><span class="line">		<span class="comment">//不可以调用非静态结构，随着类的加载和执行，这个时候哪有非静态结构（它们随对象创建和加载）</span></span><br><span class="line"><span class="comment">//		eat();</span></span><br><span class="line"><span class="comment">//		name = "Tom";</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"吃饭"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我是一个快乐的人！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发中，代码块的主要作用就是对类或对象的信息初始化，关于初始化我们前面也学习了对属性可以通过显式初始化赋值方式，也可以在构造器中进行初始化，代码块的功能就是给我们的初始化提供了多一个选择。我们完全可以不去使用它，因此在开发中代码块的使用频率是比较低的，这也是为什么要放到这里才去引入介绍的原因之一(还有是为了引入static关键字后去说明才能清晰的认识)。</p>
<h3 id="属性赋值的先后顺序"><a href="#属性赋值的先后顺序" class="headerlink" title="属性赋值的先后顺序"></a>属性赋值的先后顺序</h3><p>代码块的执行要先于构造器！静态代码块会随着类的加载而加载，而创建一个对象，构造器”始终”都会先执行super()方法意味着会先去加载父类然后调用父类的构造器，所以父类的静态代码块最早执行然后是非静态代码块执行紧接着才是构造器。</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/85.jpg" class="lozad"></p>
<p>赋值的规律遵从由父及子，静态先行！</p>
<p>注：静态代码块只随类的加载执行一次</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/84.jpg" class="lozad"></p>
<p><em>注：代码块也称初始化块</em></p>
<p>要注意一点的是：<code>main()</code>方法作为程序入口，实际上也是一个方法，只不过解释器在解释运行的时候自动的通过类去调用了！所以执行<code>main()</code>方法前会先加载类！而加载类也会优先把该类的父类给加载了，这意味着会从根父类开始从执行“父类们”到该main方法所在类的静态代码块！！！</p>
<p>思考：代码块赋值和显式赋值谁先谁后呢？下面通过代码看一下也去做一个总结：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对属性可以赋值的位置：</span></span><br><span class="line"><span class="comment"> * ①默认初始化</span></span><br><span class="line"><span class="comment"> * ②显式初始化/⑤在代码块中赋值</span></span><br><span class="line"><span class="comment"> * ③构造器中初始化</span></span><br><span class="line"><span class="comment"> * ④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 显示赋值和代码块根据摆放的顺序先后执行</span></span><br><span class="line"><span class="comment"> * 执行的先后顺序：① - ② / ⑤ - ③ - ④</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Order order = <span class="keyword">new</span> Order();</span><br><span class="line">		System.out.println(order.orderId);<span class="comment">//4</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示赋值和代码块根据摆放的顺序先后执行</span></span><br><span class="line">	<span class="keyword">int</span> orderId = <span class="number">3</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		orderId = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		orderId = 4; //先执行代码块</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	int orderId = 3;//再显式赋值</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字：final"><a href="#关键字：final" class="headerlink" title="关键字：final"></a>关键字：final</h2><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/86.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/87.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/88.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/89.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * final:最终的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. final可以用来修饰的结构：类、方法、变量</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. final 用来修饰一个类:此类不能被其他类所继承。</span></span><br><span class="line"><span class="comment"> *          比如：String类、System类、StringBuffer类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. final 用来修饰方法：表明此方法不可以被重写</span></span><br><span class="line"><span class="comment"> * 			比如：Object类中getClass();</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4. final 用来修饰变量：此时的"变量"就称为是一个常量</span></span><br><span class="line"><span class="comment"> * 	    4.1 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化</span></span><br><span class="line"><span class="comment"> * 		4.2 final修饰局部变量：</span></span><br><span class="line"><span class="comment"> *           尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</span></span><br><span class="line"><span class="comment"> *           </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//final 用来修饰变量：此时的"变量"就称为是一个常量</span></span><br><span class="line">	<span class="comment">//变量又分为类的属性和局部变量，让我们看看它们在final修饰下的区别：</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	final int WIDTH;  // final修饰属性不能使用默认初始化</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> WIDTH = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> LEFT;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> RIGHT;</span><br><span class="line"><span class="comment">//	final int DOWN;</span></span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		LEFT = <span class="number">1</span>;<span class="comment">// final修饰属性可以在代码块中初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">		RIGHT = <span class="number">2</span>; <span class="comment">// final修饰属性可以在构造器中初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		RIGHT = n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void setDown(int down)&#123;</span></span><br><span class="line"><span class="comment">//		this.DOWN = down; // 报错,final修饰属性在方法中给属性赋值是不行的</span></span><br><span class="line">	<span class="comment">//这是因为构造器是对象出生的最后一道关卡，调用完构造器后在内存中对象就应该被加载了，final修饰的变量也会在堆空间出现，所以此时该变量应该是有值的，在方法中赋值显然太晚了。</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//		WIDTH = 20;//final修饰的变量不能修改值</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//final修饰局部变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">10</span>;<span class="comment">//常量</span></span><br><span class="line"><span class="comment">//		NUM += 20;//报错，常量不能被修改</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="comment">//final修饰形参时，当我们调用此方法时，给该形参赋上实参，一旦赋值以后在方法内只能对该形参进行调用而不能进行修改</span></span><br><span class="line"><span class="comment">//		num = 20;//编译不通过</span></span><br><span class="line">		System.out.println(num);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		num = num + <span class="number">5</span>;</span><br><span class="line">		</span><br><span class="line">		FinalTest test = <span class="keyword">new</span> FinalTest();</span><br><span class="line"><span class="comment">//		test.setDown(3);</span></span><br><span class="line">		</span><br><span class="line">		test.show(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final用来修饰类---不能被继承</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalA</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错，不能继承被final修饰的类</span></span><br><span class="line"><span class="comment">//class B extends FinalA&#123;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//报错，不能继承被final修饰的类</span></span><br><span class="line"><span class="comment">//class C extends String&#123;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">	<span class="comment">//final 用来修饰方法：表明此方法不可以被重写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> <span class="keyword">extends</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">	<span class="comment">//报错，final 用来修饰方法：表明此方法不可以被重写</span></span><br><span class="line"><span class="comment">//	public void show()&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发中我们还会经常遇到<code>static final</code>组合搭配:</p>
<ul>
<li>static final 用来修饰属性：全局常量</li>
<li>static体现的是随着类的加载而加载，final体现是不能变！</li>
</ul>
<h2 id="关键字：abstract—抽象类与方法"><a href="#关键字：abstract—抽象类与方法" class="headerlink" title="关键字：abstract—抽象类与方法"></a>关键字：abstract—抽象类与方法</h2><p><code>abstract</code>翻译为”抽象的“。它可以修饰类和方法。被修饰的类和方法就成为抽象类和抽象方法</p>
<p><strong>抽象类：</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/91.jpg" class="lozad"></p>
<p>简单粗暴的理解，使用<code>abstract</code>修饰的类意味着<strong>这个类不能造对象了(不能实例化)</strong>！学习完多态后不难发现，我们在平时的使用中父类对象的使用就变得很少了， 一般都是将其引用指向各种丰富的子类对象，实现多态。父类不做事情只是把方法传承下去给子类去实现，这样的父类就可以定义为抽象类。</p>
<p><strong>抽象方法：</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/92.jpg" class="lozad"></p>
<p>提到抽象方法第一反应是：含有抽象方法的类一定是一个抽象类</p>
<p>还是放到代码中去理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * abstract关键字的使用</span></span><br><span class="line"><span class="comment"> * 1.abstract:抽象的</span></span><br><span class="line"><span class="comment"> * 2.abstract可以用来修饰的结构：类、方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. abstract修饰类：抽象类</span></span><br><span class="line"><span class="comment"> * 		&gt; 此类不能实例化</span></span><br><span class="line"><span class="comment"> *      &gt; 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</span></span><br><span class="line"><span class="comment"> *      &gt; 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4. abstract修饰方法：抽象方法</span></span><br><span class="line"><span class="comment"> * 		&gt; 抽象方法只有方法的声明，没有方法体</span></span><br><span class="line"><span class="comment"> * 		&gt; 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</span></span><br><span class="line"><span class="comment"> *         &gt; 若子类重写了父类中的所有的抽象方法后，此子类方可实例化</span></span><br><span class="line"><span class="comment"> *            若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//一旦Person类抽象了，就不可实例化</span></span><br><span class="line"><span class="comment">//		Person p1 = new Person();</span></span><br><span class="line"><span class="comment">//		p1.eat();</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Creature</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//不是抽象方法：</span></span><br><span class="line"><span class="comment">//	public void eat()&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//抽象方法只有方法的声明，没有方法体</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的(子类可以继承去用)。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"人走路"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name,age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	若子类重写了父类中的所有的抽象方法后，此子类方可实例化</span></span><br><span class="line">	<span class="comment">//继承了抽象类的子类必须实现重写抽象类中定义的抽象方法(不然抽象方法什么都不做定义来有什么意义？就是为了让子类必须去实现重写)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"学生多吃有营养的食物"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//继承的抽象方法也必须去重写，子类必须实现重写抽象类中定义的所有抽象方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"学生应该呼吸新鲜的没有雾霾的空气"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类是用来模型化那些父类<strong>无法确定全部实现的方法</strong>，而是由其子类提供具体实现的对象的类</p>
<p><strong>抽象类的应用：</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/93.jpg" class="lozad"></p>
<p><strong>absract使用中的注意点</strong>：</p>
<ul>
<li>abstract不能用来修饰：属性、构造器(不能重写)等结构</li>
<li>abstract不能用来修饰私有方法（声明为private的方法不能被重写）、静态方法（不认为是重写覆盖）、final方法（直接就不让你重写）、final的类（不能继承）</li>
</ul>
<p>其实并不要把抽象类想的很复杂，可以这样理解：<br>抽象类就是比普通类多定义了抽象方法（也可以没有），除了不能直接进行类的实例化操作之外，并没有任何的不同</p>
<p><strong>补充：抽象类的匿名子类的使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 抽象类的匿名子类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		method(<span class="keyword">new</span> Student());<span class="comment">//匿名对象---没有变量名</span></span><br><span class="line">		</span><br><span class="line">		Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">		method1(worker);<span class="comment">//非匿名的类 非匿名的对象 ---有变量名 有类名</span></span><br><span class="line">		</span><br><span class="line">		method1(<span class="keyword">new</span> Worker());<span class="comment">//非匿名的类 匿名的对象 --无变量名 有类名</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建了一匿名子类的对象：p --- 有变量名 没类名</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"吃东西"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"好好呼吸"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		method1(p);</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//创建匿名子类的匿名对象  ---无变量名 无类名</span></span><br><span class="line">		method1(<span class="keyword">new</span> Person()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"吃好吃东西"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"好好呼吸新鲜空气"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">		p.eat();</span><br><span class="line">		p.breath();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Student s)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Creature</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//不是抽象方法：</span></span><br><span class="line"><span class="comment">//	public void eat()&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//抽象方法只有方法的声明，没有方法体</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的(子类可以继承去用)。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"人走路"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name,age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	若子类重写了父类中的所有的抽象方法后，此子类方可实例化</span></span><br><span class="line">	<span class="comment">//继承了抽象类的子类必须实现重写抽象类中定义的抽象方法(不然抽象方法什么都不做定义来有什么意义？就是为了让子类必须去实现重写)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"学生多吃有营养的食物"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//继承的抽象方法也必须去重写，子类必须实现重写抽象类中定义的所有抽象方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"学生应该呼吸新鲜的没有雾霾的空气"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名子类对象的意义：只用一次！懒得去设计类并且只需要用到一次的话就可以使用它。</p>
<h2 id="关键字：interface—接口"><a href="#关键字：interface—接口" class="headerlink" title="关键字：interface—接口"></a>关键字：interface—接口</h2><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p><strong>接口的概述：</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/94.jpg" class="lozad"></p>
<p>接口和类是两个并列的结构</p>
<p>接口的作用就是为了解决java不支持多继承的问题。一个类可以实现多个接口，一定程度上解决了单继承性的局限性。父类和子类一般是is-a的关系，强调的是本质类型是一样的，接口使得实现代码重用拓展功能从类与类的关系抽离出来。把不是一类的却又相同行为特征的对象抽离封装出来，让类去实现它。</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/95.jpg" class="lozad"></p>
<p>接口的使用：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/96.jpg" class="lozad"></p>
<p>java是面向对象的，意味着我们要通过类去new对象，所以必须要把接口转换成类的层面上去使用才可以(通过”对象.东西”的方式调功能)，故通过implements关键字来让类去接收接口的结构并限制必须是实现接口的抽象方法</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/97.jpg" class="lozad"></p>
<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><p>下面通过还是通过代码去学习接口的使用和知识点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口的使用</span></span><br><span class="line"><span class="comment"> * 1.接口使用interface来定义</span></span><br><span class="line"><span class="comment"> * 2.Java中，接口和类是并列的两个结构</span></span><br><span class="line"><span class="comment"> * 3.如何定义接口：定义接口中的成员</span></span><br><span class="line"><span class="comment"> * 		</span></span><br><span class="line"><span class="comment"> * 		3.1 JDK7及以前：只能定义全局常量和抽象方法</span></span><br><span class="line"><span class="comment"> * 			&gt;全局常量：public static final的.但是书写时，可以省略不写</span></span><br><span class="line"><span class="comment"> * 			&gt;抽象方法：public abstract的</span></span><br><span class="line"><span class="comment"> * 			</span></span><br><span class="line"><span class="comment"> * 		3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4. 接口中不能定义构造器的！意味着接口不可以实例化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5. Java开发中，接口通过让类去实现(implements)的方式来使用.</span></span><br><span class="line"><span class="comment"> *    如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</span></span><br><span class="line"><span class="comment"> *    如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</span></span><br><span class="line"><span class="comment"> *    注意：严格来说通常覆盖抽象方法这件事我们叫做实现，而不是重写</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * 6. Java类可以实现多个接口   ---&gt;弥补了Java单继承性的局限性</span></span><br><span class="line"><span class="comment"> *   格式：class AA extends BB implements CC,DD,EE</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> * 7. 接口与接口之间可以继承，而且可以多继承</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * *******************************</span></span><br><span class="line"><span class="comment"> * 8. 接口的具体使用，体现多态性</span></span><br><span class="line"><span class="comment"> * 9. 接口，实际上可以看做是一种规范</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 面试题：抽象类与接口有哪些异同？</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Flyable.MAX_SPEED);</span><br><span class="line">		System.out.println(Flyable.MIN_SPEED);</span><br><span class="line"><span class="comment">//		Flyable.MIN_SPEED = 2;</span></span><br><span class="line">		</span><br><span class="line">		Plane plane = <span class="keyword">new</span> Plane();</span><br><span class="line">		plane.fly();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口使用interface来定义，Java中，接口和类是并列的两个结构</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//全局常量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SPEED = <span class="number">7900</span>;<span class="comment">//第一宇宙速度</span></span><br><span class="line">	<span class="keyword">int</span> MIN_SPEED = <span class="number">1</span>;<span class="comment">//省略了public static final</span></span><br><span class="line">	<span class="comment">//java会认为他还是public static final</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//省略了public abstract</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Interfaces cannot have constructors接口中不能定义构造器，意味着接口不可以实例化</span></span><br><span class="line"><span class="comment">//	public Flyable()&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Attackable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java开发中，接口通过让类去实现(implements)的方式来使用.</span></span><br><span class="line"><span class="comment">//如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//实现类实现接口中的抽象方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"通过引擎起飞"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"驾驶员减速停止"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Kite</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">	<span class="comment">//只实现了一个抽象方法，没有实现全，把它定义为一个抽象类</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类可以实现多个接口--实现一个接口就有了相应的一些功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Flyable</span>,<span class="title">Attackable</span>,<span class="title">CC</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为CC接口继承了AA、BB所以实现类也需要实现它们的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口与接口之间可以继承，而且可以多继承</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CC</span> <span class="keyword">extends</span> <span class="title">AA</span>,<span class="title">BB</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么理解：接口是一种规范?</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/98.jpg" class="lozad"></p>
<p>如图是我们现实中电脑的USB接口，其实它就是一个规范，许多设备（如U盘打印机等等）都有USB接口，这些设备都可以通过USB接口来跟电脑交互传输数据。实际上这个接口就是一种规范，该口的长宽高、传输速度、里面有几个针孔等等这些最初就定义好了，类比于Java中接口的概念这些长宽高等属性在接口中就定义为<strong>常量</strong><br>只要是USB口就具有如传输数据、开启传输数据以及结束等等功能，这些功能在不同设备上传输的方式都不一样的。所以只能在接口中定义了一些抽象的方法<strong>这样的方法实际上不就是一种规范吗？（这就跟java的接口中定义的抽象方法一样）</strong>它定义了数据传输的规范，凡是想要用USB接口的设备就需要按规范去实现自己的传输方法—-这些实现类的集合我们就叫做驱动（为什么说是实现类集合？因为你不可能把所有的东西都写到一个类中，接口也会有很多，实现类(实现这些接口(规范)的类也可能会有许多)）<br>举例：把硬盘插到电脑会显示需要我们安装驱动，安装驱动实际上就是我们的USB接口定义了一些规范，现在你想要拿着这个设备来给电脑传输数据了就需要先把实现接口的实现类给下载并跑起来才行！</p>
<p>可以同个一个代码示例来交接下<strong>接口的使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口的使用</span></span><br><span class="line"><span class="comment"> * 1.接口使用上也满足多态性（自己没构造器对象也造不了，要用的话也只能通过多态的方式去使用）</span></span><br><span class="line"><span class="comment"> * 2.接口，实际上就是定义了一种规范</span></span><br><span class="line"><span class="comment"> * 3.开发中，体会面向接口编程！</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USBTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Computer com = <span class="keyword">new</span> Computer();</span><br><span class="line">		<span class="comment">//1.创建了接口的非匿名实现类的非匿名对象</span></span><br><span class="line">		Flash flash = <span class="keyword">new</span> Flash();</span><br><span class="line">		com.transferData(flash);<span class="comment">//体现了接口的多态性</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2. 创建了接口的非匿名实现类的匿名对象</span></span><br><span class="line">		com.transferData(<span class="keyword">new</span> Printer());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3. 创建了接口的匿名实现类的非匿名对象</span></span><br><span class="line">		USB phone = <span class="keyword">new</span> USB()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"手机开始工作"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"手机结束工作"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		com.transferData(phone);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4. 创建了接口的匿名实现类的匿名对象</span></span><br><span class="line">		</span><br><span class="line">		com.transferData(<span class="keyword">new</span> USB()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"mp3开始工作"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"mp3结束工作"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">	<span class="comment">//电脑传输数据功能接收的是遵循USB规范的传输设备的对象---多态的体现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span></span>&#123;<span class="comment">//USB usb = new Flash(); 接口的多态</span></span><br><span class="line">		usb.start();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"具体传输数据的细节"</span>);</span><br><span class="line">		</span><br><span class="line">		usb.stop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义与电脑传输的规范--谁要是想和电脑传输数据就要实现这个接口把接口中的规范去明确出来</span></span><br><span class="line"><span class="comment">//明确的意思就是拿到全局常量，实现抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">	<span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//U盘</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"U盘开启工作"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"U盘结束工作"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"打印机开启工作"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"打印机结束工作"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目的需求是多变的，我们必须以不变应万变才能从容开发，此处的“不变”就是“规范“。因此，我们开发项目往往是面向接口（规范）编程！</p>
<p><strong>拓展：看两个常见的排错题（笔试题）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目一</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//编译不通过。因为x是不明确的</span></span><br><span class="line">		<span class="comment">// System.out.println(x);</span></span><br><span class="line">        <span class="comment">//ps:该报错只针对于属性，对于方法有类优先原则</span></span><br><span class="line">		System.out.println(<span class="keyword">super</span>.x);<span class="comment">//1</span></span><br><span class="line">		System.out.println(A.x);<span class="comment">//0 ---接口中的x是全局常量直接调就完事</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> C().pX();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/100.jpg" class="lozad"></p>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/105.jpg" class="lozad"></p>
<h3 id="Java8中接口的新特性"><a href="#Java8中接口的新特性" class="headerlink" title="Java8中接口的新特性"></a>Java8中接口的新特性</h3><p>JDK7及以前：只能定义全局常量和抽象方法。在JDK8中更新了接口的特性，除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/101.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"CompareA:广东"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//默认方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"CompareA：上海"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//可以省略public</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"CompareA：上海"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法可以通过接口直接去调用。默认方式需要通过实现类实例化后通过”实例.方法“的方式去调用，可以直接当作实现类中的普通非静态方法。</p>
<p>基于上边的示例我们看一下怎么去调用接口的静态方法和默认方法已经java8接口新特性各种知识点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClassTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SubClass s = <span class="keyword">new</span> SubClass();</span><br><span class="line"><span class="comment">//		s.method1();//报错：实现类对象完全拿不到接口中的静态方法</span></span><br><span class="line"><span class="comment">//		SubClass.method1();报错：实现类完全拿不到接口中的静态方法</span></span><br><span class="line">		<span class="comment">//知识点1：接口中定义的静态方法，只能通过接口来调用。</span></span><br><span class="line">		CompareA.method1();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class="line">		<span class="comment">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class="line">		s.method2();</span><br><span class="line">		<span class="comment">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</span></span><br><span class="line">		<span class="comment">//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class="line">		<span class="comment">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class="line">		<span class="comment">//那么在实现类没有重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class="line">		<span class="comment">//这就需要我们必须在实现类中重写此方法</span></span><br><span class="line">		s.method3();<span class="comment">//SuperClass:北京，输出的是父类的方法</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个与接口A的默认方法重名的方法，思考调用时会怎么样？</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SuperClass:北京"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义个接口B</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个与接口A的默认方法 重名的方法，思考调用时会怎么样？</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"CompareB：上海"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果实现类没有继承的父类中同名名参数的方法或重写方法，就会报错</span></span><br><span class="line">	<span class="comment">//因为编译器分不清到底调取的是A接口还是B接口的method3方法---接口冲突</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">CompareA</span>,<span class="title">CompareB</span></span>&#123;</span><br><span class="line">	<span class="comment">//实现类重写了接口中的默认方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SubClass：上海"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SubClass：深圳"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">		<span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">		<span class="comment">//调用接口中的默认方法</span></span><br><span class="line">		CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">		CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到java8新特性出来后，接口变得越来越像类了。其实我觉得有点失去了”接口就是一种规范的味道了“</p>
<h2 id="类的成员之五：内部类"><a href="#类的成员之五：内部类" class="headerlink" title="类的成员之五：内部类"></a>类的成员之五：内部类</h2><p>内部类作为五大类的成员之一，在开发中其实用到的并不多。所以先简单了解下知识点：</p>
<p>当一个属性无法简单描述类的特征的时候就可以使用内部类这种复杂的结构去描述一个类的特征！例如人的大脑比较复杂，不能像年龄和属性一样用普通类型变量甚至字符串足以完全描述，而把大脑单独造成一个类的话因为只需供给人类使用其他类不需要用到那么是有点浪费的。这个时候就可以把它定义为一个内部类。</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/102.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/103.jpg" class="lozad"></p>
<p>还是通过代码去看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类的内部成员之五：内部类</span></span><br><span class="line"><span class="comment"> * 1. Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.内部类的分类：成员内部类（静态、非静态）  vs 局部内部类(方法内、代码块内、构造器内)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.成员内部类：</span></span><br><span class="line"><span class="comment"> * 		一方面，作为外部类的成员：</span></span><br><span class="line"><span class="comment"> * 			&gt;调用外部类的结构</span></span><br><span class="line"><span class="comment"> * 			&gt;可以被static修饰，注:外部类不能用static修饰(static主要体现的是随着类的加载而加载，就是加载外部类)</span></span><br><span class="line"><span class="comment"> * 			&gt;可以被4种不同的权限修饰</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		另一方面，作为一个类：</span></span><br><span class="line"><span class="comment"> * 			&gt; 类内可以定义属性、方法、构造器等</span></span><br><span class="line"><span class="comment"> * 			&gt; 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</span></span><br><span class="line"><span class="comment"> * 			&gt; 可以被abstract修饰，表示此类不能被实例化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.关注如下的3个问题</span></span><br><span class="line"><span class="comment"> *   4.1 如何实例化成员内部类的对象</span></span><br><span class="line"><span class="comment"> *   4.2 如何在成员内部类中区分调用外部类的结构</span></span><br><span class="line"><span class="comment"> *   4.3 开发中局部内部类的使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如何实例化成员内部类的对象</span></span><br><span class="line">		<span class="comment">//创建Dog实例(静态的成员内部类):</span></span><br><span class="line">		Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line">		dog.show();</span><br><span class="line">		<span class="comment">//创建Bird实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">//		Person.Bird bird = new Person.Bird();//错误的,非静态结构必须要实例化后使用，即需要先实例化外部类</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		Person.Bird bird = p.new Bird();</span><br><span class="line">		bird.sing();</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		bird.display(<span class="string">"黄鹂"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name = <span class="string">"小明"</span>;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"人：吃饭"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//静态成员内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">		String name;</span><br><span class="line">		<span class="keyword">int</span> age;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"卡拉是条狗"</span>);</span><br><span class="line"><span class="comment">//			eat();//静态成员内部类不能调非静态方法</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">		<span class="comment">//类内可以定义属性、方法、构造器等</span></span><br><span class="line">		String name = <span class="string">"杜鹃"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"我是一只小小鸟"</span>);</span><br><span class="line">			Person.<span class="keyword">this</span>.eat();<span class="comment">//调用外部类的非静态属性</span></span><br><span class="line">			eat();</span><br><span class="line">			System.out.println(age);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如何在成员内部类中区分调用外部类的结构</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">			System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">			System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">			System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">CC</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发中局部内部类的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//开发中很少见</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">		<span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//		class MyComparable implements Comparable&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//				return 0;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		return new MyComparable();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二：匿名实现类的匿名对象</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/104.jpg" class="lozad"></p>
<p>注意1：局部内部类使用的一个注意点：<br>在局部内部类的方法中，如果调用局部内部类所声明的方法中的局部变量的话，要求此局部变量声明为final(这是因为方法执行完后变量就没了，为了让类还能使用实际上会给类穿一个副本，这个<strong>副本</strong>就不能修改)。看起来有点绕，我们看看代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在局部内部类的方法中（比如：show）如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,</span></span><br><span class="line"><span class="comment">	 * 要求此局部变量声明为final的。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * jdk 7及之前版本：要求此局部变量显式的声明为final的</span></span><br><span class="line"><span class="comment">	 * jdk 8及之后的版本：可以省略final的声明</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部变量</span></span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//				num = 20;</span></span><br><span class="line">				System.out.println(num);</span><br><span class="line">				</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意2：成员内部类和局部内部类，在编译以后，都会生成字节码<br>格式：</p>
<ul>
<li>成员内部类：<code>外部类$内部类.class</code></li>
<li>局部内部类：外部类$数字 内部类.class   （数字区分可能在不同的类成员中有同名方法）</li>
</ul>
<hr>
<p>至此java面向对象篇的内容就结束了，通过基础篇和面向对象篇的学习我们已经能基本上看懂所有的Java代码，剩下的Java内容实际上就是在这上面的基础上去学习Java生态提供给我们一些API的使用。<br>后面的JavaSE的学习将会分多篇文章挑选开发中比较常用的内容（如多线多进程、反射、常用类等等）去介绍。关于面向对象的知识点的学习大致就是上述的全部，如有纰漏和错误望指出。感谢学习者！谢谢~</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE    </a><a class="post-meta__tags" href="/tags/java/">java    </a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础    </a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象    </a></div><div class="post_share"><div class="social-share" data-image="/img/cover_default3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/24/JavaSE%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"><img class="prev_cover lozad" data-src="/img/cover_default2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>JavaSE之异常处理</span></div></a></div><div class="next-post pull-right"><a href="/2019/11/23/Java%E5%85%A5%E9%97%A8/"><img class="next_cover lozad" data-src="/img/cover_default3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>JavaSE基础篇</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/12/24/JavaSE之异常处理/" title="JavaSE之异常处理"><img class="relatedPosts_cover lozad"data-src="/img/cover_default2.jpg"><div class="relatedPosts_title">JavaSE之异常处理</div></a></div><div class="relatedPosts_item"><a href="/2019/11/23/Java入门/" title="JavaSE基础篇"><img class="relatedPosts_cover lozad"data-src="/img/cover_default3.jpg"><div class="relatedPosts_title">JavaSE基础篇</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzI1MC8yMzc1MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer style="background-image: url(/img/cover_default3.jpg)"><div id="footer"><div class="copyright">&copy;2019 - 2020 By Rhubarb C</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script color="0,0,255" opacity="0.7" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>