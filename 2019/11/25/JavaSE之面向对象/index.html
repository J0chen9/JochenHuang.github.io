<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>JavaSE之面向对象 | RhubarbC的博客</title><meta name="description" content="关于Java的个人学习之路！本文将介绍Java语言的最最最核心内容——“面向对象”的知识点！"><meta name="keywords" content="JavaSE,java,面向对象"><meta name="author" content="Rhubarb C"><meta name="copyright" content="Rhubarb C"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="JavaSE之面向对象"><meta name="twitter:description" content="关于Java的个人学习之路！本文将介绍Java语言的最最最核心内容——“面向对象”的知识点！"><meta name="twitter:image" content="http://yoursite.com/img/cover_default2.jpg"><meta property="og:type" content="article"><meta property="og:title" content="JavaSE之面向对象"><meta property="og:url" content="http://yoursite.com/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><meta property="og:site_name" content="RhubarbC的博客"><meta property="og:description" content="关于Java的个人学习之路！本文将介绍Java语言的最最最核心内容——“面向对象”的知识点！"><meta property="og:image" content="http://yoursite.com/img/cover_default2.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="JavaSE基础篇" href="http://yoursite.com/2019/11/23/Java%E5%85%A5%E9%97%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://deehuang.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: Rhubarb C","link":"链接: http://yoursite.com/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","source":"来源: RhubarbC的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">RhubarbC的博客</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#面向对象思想概述"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">面向对象思想概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#类和对象"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">类和对象</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的结构"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">类的结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#对象"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">对象</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建类的对象："><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">创建类的对象：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类与多个对象的关系"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">类与多个对象的关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#对象的内存解析"><span class="toc_mobile_items-number">2.2.3.</span> <span class="toc_mobile_items-text">对象的内存解析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#拓展：对象数组和匿名对象的使用"><span class="toc_mobile_items-number">2.2.4.</span> <span class="toc_mobile_items-text">拓展：对象数组和匿名对象的使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#对象数组"><span class="toc_mobile_items-number">2.2.4.1.</span> <span class="toc_mobile_items-text">对象数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#匿名对象"><span class="toc_mobile_items-number">2.2.4.2.</span> <span class="toc_mobile_items-text">匿名对象</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#类的成员"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">类的成员</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的成员之一：属性"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">类的成员之一：属性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的成员之二：方法"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">类的成员之二：方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法的声明与使用"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">方法的声明与使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法的重载"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">方法的重载</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#可变个数的形参的方法"><span class="toc_mobile_items-number">3.2.3.</span> <span class="toc_mobile_items-text">可变个数的形参的方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法参数的值传递机制"><span class="toc_mobile_items-number">3.2.4.</span> <span class="toc_mobile_items-text">方法参数的值传递机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#递归方法"><span class="toc_mobile_items-number">3.2.5.</span> <span class="toc_mobile_items-text">递归方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#面向对象特性之一：封装性"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">面向对象特性之一：封装性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是封装与隐藏"><span class="toc_mobile_items-number">3.3.1.</span> <span class="toc_mobile_items-text">什么是封装与隐藏</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#四种权限修饰符"><span class="toc_mobile_items-number">3.3.2.</span> <span class="toc_mobile_items-text">四种权限修饰符</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类的成员之三：构造器（或构造方法）"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">类的成员之三：构造器（或构造方法）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#构造器"><span class="toc_mobile_items-number">3.4.1.</span> <span class="toc_mobile_items-text">构造器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#属性的赋值过程"><span class="toc_mobile_items-number">3.4.2.</span> <span class="toc_mobile_items-text">属性的赋值过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#拓展：JavaBean和UML类图"><span class="toc_mobile_items-number">3.4.3.</span> <span class="toc_mobile_items-text">拓展：JavaBean和UML类图</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#JavaBean"><span class="toc_mobile_items-number">3.4.3.1.</span> <span class="toc_mobile_items-text">JavaBean</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#UML类图"><span class="toc_mobile_items-number">3.4.3.2.</span> <span class="toc_mobile_items-text">UML类图</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关键字：this的使用"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">关键字：this的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关键字：package、import的使用"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">关键字：package、import的使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#package"><span class="toc_mobile_items-number">3.6.1.</span> <span class="toc_mobile_items-text">package</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#包的使用与作用"><span class="toc_mobile_items-number">3.6.1.1.</span> <span class="toc_mobile_items-text">包的使用与作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#MVC设计模式"><span class="toc_mobile_items-number">3.6.1.2.</span> <span class="toc_mobile_items-text">MVC设计模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#import"><span class="toc_mobile_items-number">3.6.2.</span> <span class="toc_mobile_items-text">import</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#面向对象三大特性"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">面向对象三大特性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#面向对象特性之二：继承性"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">面向对象特性之二：继承性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#继承性"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">继承性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#继承的作用"><span class="toc_mobile_items-number">4.1.2.</span> <span class="toc_mobile_items-text">继承的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#继承性的使用"><span class="toc_mobile_items-number">4.1.3.</span> <span class="toc_mobile_items-text">继承性的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java关于继承性的规定："><span class="toc_mobile_items-number">4.1.4.</span> <span class="toc_mobile_items-text">Java关于继承性的规定：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#拓展：初探Object类"><span class="toc_mobile_items-number">4.1.5.</span> <span class="toc_mobile_items-text">拓展：初探Object类</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#方法的重写"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">方法的重写</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#面向对象特性之二：多态性"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">面向对象特性之二：多态性</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象思想概述"><span class="toc-number">1.</span> <span class="toc-text">面向对象思想概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和对象"><span class="toc-number">2.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类的结构"><span class="toc-number">2.1.</span> <span class="toc-text">类的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-number">2.2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建类的对象："><span class="toc-number">2.2.1.</span> <span class="toc-text">创建类的对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类与多个对象的关系"><span class="toc-number">2.2.2.</span> <span class="toc-text">类与多个对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的内存解析"><span class="toc-number">2.2.3.</span> <span class="toc-text">对象的内存解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展：对象数组和匿名对象的使用"><span class="toc-number">2.2.4.</span> <span class="toc-text">拓展：对象数组和匿名对象的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对象数组"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名对象"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">匿名对象</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类的成员"><span class="toc-number">3.</span> <span class="toc-text">类的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类的成员之一：属性"><span class="toc-number">3.1.</span> <span class="toc-text">类的成员之一：属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的成员之二：方法"><span class="toc-number">3.2.</span> <span class="toc-text">类的成员之二：方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法的声明与使用"><span class="toc-number">3.2.1.</span> <span class="toc-text">方法的声明与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法的重载"><span class="toc-number">3.2.2.</span> <span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变个数的形参的方法"><span class="toc-number">3.2.3.</span> <span class="toc-text">可变个数的形参的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法参数的值传递机制"><span class="toc-number">3.2.4.</span> <span class="toc-text">方法参数的值传递机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归方法"><span class="toc-number">3.2.5.</span> <span class="toc-text">递归方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象特性之一：封装性"><span class="toc-number">3.3.</span> <span class="toc-text">面向对象特性之一：封装性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是封装与隐藏"><span class="toc-number">3.3.1.</span> <span class="toc-text">什么是封装与隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四种权限修饰符"><span class="toc-number">3.3.2.</span> <span class="toc-text">四种权限修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的成员之三：构造器（或构造方法）"><span class="toc-number">3.4.</span> <span class="toc-text">类的成员之三：构造器（或构造方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造器"><span class="toc-number">3.4.1.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性的赋值过程"><span class="toc-number">3.4.2.</span> <span class="toc-text">属性的赋值过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展：JavaBean和UML类图"><span class="toc-number">3.4.3.</span> <span class="toc-text">拓展：JavaBean和UML类图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaBean"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UML类图"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">UML类图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字：this的使用"><span class="toc-number">3.5.</span> <span class="toc-text">关键字：this的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字：package、import的使用"><span class="toc-number">3.6.</span> <span class="toc-text">关键字：package、import的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#package"><span class="toc-number">3.6.1.</span> <span class="toc-text">package</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#包的使用与作用"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">包的使用与作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC设计模式"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">MVC设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-number">3.6.2.</span> <span class="toc-text">import</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象三大特性"><span class="toc-number">4.</span> <span class="toc-text">面向对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象特性之二：继承性"><span class="toc-number">4.1.</span> <span class="toc-text">面向对象特性之二：继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承性"><span class="toc-number">4.1.1.</span> <span class="toc-text">继承性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承的作用"><span class="toc-number">4.1.2.</span> <span class="toc-text">继承的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承性的使用"><span class="toc-number">4.1.3.</span> <span class="toc-text">继承性的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java关于继承性的规定："><span class="toc-number">4.1.4.</span> <span class="toc-text">Java关于继承性的规定：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展：初探Object类"><span class="toc-number">4.1.5.</span> <span class="toc-text">拓展：初探Object类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法的重写"><span class="toc-number">4.2.</span> <span class="toc-text">方法的重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象特性之二：多态性"><span class="toc-number">4.3.</span> <span class="toc-text">面向对象特性之二：多态性</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/cover_default2.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">JavaSE之面向对象</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-25<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-08</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/JavaSE/">JavaSE</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">16.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 56 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p><strong>写在前面：</strong></p>
<p>Java是面向对象的语言，面向对象也是java最最最重要的内容，可以说无对象不java。而面向对象的知识点其实是十分之多且繁杂的。为了避免学习的时候摸不着东西南北，所以在学习之前我们应该先在脑海中理清一些学习主线。<br>本篇把Java面向对象的学习主要分成三条主线，每条主线包含的内容如下：</p>
<ol>
<li>Java类及类的成员：属性、方法、构造器；代码块、内部类</li>
<li>面向对象的三大特征：封装性、继承性、多态性、（抽象性）</li>
<li>其他关键字：this、super、static、final、abstract、interface、package、import等（上面两条主线的内容已经涉及了一些关键字的使用，这条主线主要是学习一些其他关键字的使用）</li>
</ol>
<p>本文并非是按串行的方式把三条主线的内容介绍，而是并行的方式去介绍这些内容，因为他们彼此之间是有许多关系的（就是说在学习中这些主线中的内容会相互有所杂糅）。列出学习主线只是把面向对象的知识点在脑海中树立起一个框架，把知识点归类起来，而不会感觉这学一点那学一点最终整个人是懵的！如果在下面的学习中感觉有点懵，请和我一起回来再看看这个学习主线！你就知道自己在面向对象中已经掌握了什么知识了！</p>
<p>可能有人会问？你说说什么是面向对象编程的思想？其实思想是一个挺虚无缥缈的东西。我们重点在这里主要关注的是思想的体现，编程思想的体现就是落实到代码设计（你的代码是怎么写的，把想法落实到代码中这就是编程思想的体现），所以本文主要以代码去落实面向对象编程的知识（把代码整明白了就会渐悟理解面向对象的思想到底是做什么的），而非纸上谈兵只是空谈思想！所以在学习中如果跟我一样对概念的东西感觉无法消化，不要纠结~代码敲起来吧！</p>
<h1 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h1><p>高级语言有两个过渡的阶段，一个是面向过程，一个是面对对象，来让我们看下他们的区别：</p>
<p><strong>面向过程(POP)与面向对象(OOP)</strong> </p>
<ul>
<li>二者都是一种<strong>思想</strong>，面向对象是相对于面向过程而言的。<br>面向过程，强调的是<u>功能行为，以<strong>函数</strong>为最小单位，考虑怎么做</u>。<br>面向对象，将功能封装进对象，<u>强调具备了功能的对象，以<strong>类/对象</strong>为最小单位，考虑谁来做</u>。</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。 </li>
</ul>
<p>有些童鞋看了这段是不是想吐槽:这又画下划线的又把字体加粗就能让人懂了吗?让我举起我的栗子！(简单体会一下，不用太纠结!)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"人把大象装进冰箱" 用面向过程的思想去设计和面向对象的思想去设计：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</span></span><br><span class="line"><span class="comment"> 1）把冰箱门打开</span></span><br><span class="line"><span class="comment"> 2）抬起大象，塞进冰箱</span></span><br><span class="line"><span class="comment"> 3）把冰箱门关闭</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。（就是把功能封装到主体中，可以把名词做成类，把动词做成方法放到类中进行刻画，这里使用主体&#123;功能&#125;的形式去表述）:</span></span><br><span class="line"><span class="comment">  人&#123;</span></span><br><span class="line"><span class="comment">  		打开(冰箱)&#123;</span></span><br><span class="line"><span class="comment">  			冰箱.打开();</span></span><br><span class="line"><span class="comment">  		&#125;</span></span><br><span class="line"><span class="comment">  		</span></span><br><span class="line"><span class="comment">  		抬起(大象)&#123;</span></span><br><span class="line"><span class="comment">  			大象.进入(冰箱);</span></span><br><span class="line"><span class="comment">  		&#125;</span></span><br><span class="line"><span class="comment">  		</span></span><br><span class="line"><span class="comment">  		关闭(冰箱)&#123;</span></span><br><span class="line"><span class="comment">  			冰箱.闭合();</span></span><br><span class="line"><span class="comment">  		&#125;</span></span><br><span class="line"><span class="comment">  		</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  冰箱&#123;</span></span><br><span class="line"><span class="comment">  		打开()&#123;&#125;</span></span><br><span class="line"><span class="comment">  		闭合()&#123;&#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  大象&#123;</span></span><br><span class="line"><span class="comment">  		进入(冰箱)&#123;&#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了</span></span><br><span class="line"><span class="comment">	面向对象是把构成问题事物分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	面向过程像是人自己去做事情，把事情按步骤慢慢去完成</span></span><br><span class="line"><span class="comment">	而面向过程像是上帝视角去指导人去做事情，什么人能解决这个问题就让这个人做，没人能做就造人去做。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>其实我觉得面向过程到面向对象的过度可以理解为一个企业发展的过程：一开始的时候公司就几个人，这几个人不会明显分工各自做什么事，有任务来了就一起去做，这样会高效一些，这就是面向过程的思想。<br>当企业发展壮大上千上百人的时候，如果还是面向过程的做事情而不给这群人划分一下部门和职责的话那就显得特别混乱了，此时把公司分为几个部门如市场部、开发组、财务部（分类）等等给每个部门设计自己的部门职责和制度（部门的属性和功能），每个部门各司其职相互帮助。如果某个任务需要加一些别的功能需求，只需要在特定的部门添加上这些功能就完事了。这样整体就看上去非常的清晰、干净有流程了，这就是面向对象的设计思想</p>
<p>用面向对象的思想完成一个项目（或功能的思路）：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.jpg" class="lozad"></p>
<p><strong>面向对象的三大特征：</strong></p>
<ul>
<li>封装 (Encapsulation) </li>
<li>继承 (Inheritance) </li>
<li>多态 (Polymorphism) </li>
</ul>
<p><strong>面向对象有两个要素</strong>：类和对象，它们是面向对象的核心概念，核心概念，核心概念！</p>
<p>下面我们正式的进入面向对象的学习。</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>面向对象思想的体现之一就是类和对象的使用：</p>
<p>类和对象的使用其实就是面向对象思想落地的实现，它大体上分成三步</p>
<ol>
<li><p><strong>创建类，设计类的成员（重点）</strong></p>
</li>
<li><p>创建类的对象</p>
</li>
<li><p>通过“对象.属性” 或 “对象.方法”调用对象的结构</p>
</li>
</ol>
<p><strong>类</strong>：对一类事物的描述，是抽象的、概念上的定义</p>
<p><strong>对象</strong>：是实际存在的该类事物的每个个体，因而也称为实例(instance)</p>
<ul>
<li><p>面向对象程序设计的重点是类的设计</p>
<ul>
<li>设计类，就是设计类的成员。</li>
</ul>
</li>
</ul>
<p>通过下面的图应该很容易理解：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.jpg" class="lozad"></p>
<p><strong>简单理解类和对象与类和对象的关系：</strong></p>
<ul>
<li>类：抽象的、概念上的内容</li>
<li>对象：实实在在的一个个体（在java程序中的体现就是new出来的东西，在内存中是真正的创建这个对象并占据了一定的内存空间）</li>
<li>对象是由类派生出来的（new出来的）</li>
</ul>
<p><strong>理解：万事万物皆对象！（面试装逼技能）</strong></p>
<p>实际上完整的表述是万事万物皆是类的对象！</p>
<ol>
<li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构，如：<ul>
<li>Scanner,String等</li>
<li>文件：File</li>
<li>网络资源：URL</li>
</ul>
</li>
<li>涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</li>
</ol>
<h2 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h2><p>上面简单理解了类，那么java中创建类的语法格式是什么？</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.jpg" class="lozad"></p>
<p>知道类是怎么回事后，接下来了解下类的成员：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.jpg" class="lozad"></p>
<p>实际上，设计类，其实就是<strong>设计类的成员</strong>。类的成员除了有属性和方法外还有构造器；代码块、内部类。这里我们主要先简单讲讲常用到的类的成员：属性和方法。后面的内容中需要用到其他成员变量的时候我们再慢慢引入！循序渐进的去学习！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.jpg" class="lozad"></p>
<p>生活中描述事务无非就是描述事物的属性和行为。如：人有身高，体重等属性，有说话，游泳等行为。</p>
<p>属性和方法在现实中有许多种叫法，我们在这里做个统一化：</p>
<ul>
<li>属性 = 成员变量 = field = 域、字段</li>
<li>方法 = 成员方法 = 函数 = method</li>
</ul>
<p>老规矩，我们尽量把东西放到代码去说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、设计类，其实就是设计类的成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  属性 = 成员变量 = field = 域、字段</span></span><br><span class="line"><span class="comment"> *  方法 = 成员方法 = 函数 = method </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age =<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：具备的一些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"说话，使用的是"</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>类可以比作是一张设计的图纸，在上面我们设计了人类及它的成员变量即设计好了一个类，但是这个类只是个图纸写着这是个什么东西有什么功能而已，如果不去使用它，即按图纸创建制造东西那这个类就显得毫无意义。</p>
<p>那么怎么去使用java类呢？<br>使用java类其实就是创建一个个具体的对象去做事情。而我们把创建类的对象这个过程就叫做<strong>类的实例化或实例化类过程</strong></p>
<h3 id="创建类的对象："><a href="#创建类的对象：" class="headerlink" title="创建类的对象："></a>创建类的对象：</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.jpg" class="lozad"></p>
<p>还是用上面人类的例子，代码说话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、设计类，其实就是设计类的成员</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  属性 = 成员变量 = field = 域、字段</span></span><br><span class="line"><span class="comment"> *  方法 = 成员方法 = 函数 = method </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  创建类的对象 = 类的实例化 = 实例化类</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  二、类和对象的使用（面向对象思想落地的实现） //重要所以不断强调</span></span><br><span class="line"><span class="comment"> *       1.创建类，设计类的成员</span></span><br><span class="line"><span class="comment"> *       2.创建类的对象</span></span><br><span class="line"><span class="comment"> *       3.通过“对象.属性” 或 “对象.方法”调用对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Person类的对象</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用对象的结构：属性、方法</span></span><br><span class="line">        <span class="comment">//调用属性：“对象.属性”</span></span><br><span class="line">        p1.name = <span class="string">"deehuang"</span>;</span><br><span class="line">        p1.isMale = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(p1.name);<span class="comment">//deehuang</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用方法：“对象.方法”</span></span><br><span class="line">        p1.eat();</span><br><span class="line">        p1.sleep();</span><br><span class="line">        p1.talk(<span class="string">"Chinese"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age =<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：具备的一些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"说话，使用的是"</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一开始说到，本文重点学习的是面向对象思想编程的体现，落地到代码中去学习面向对象编程的思想。所以为了方便学习，下面的内容我就像上面代码示例一样都把知识点尽量放到代码块中去说明演示并简单阐述。在不断的学习代码中会有渐悟甚至顿悟的过程，读者在看到一些概念性的东西无须停下来死扣。我认为入门学习面向对象知识最好的学习方式理解代码！理解代码！理解代码！</p>
</blockquote>
<h3 id="类与多个对象的关系"><a href="#类与多个对象的关系" class="headerlink" title="类与多个对象的关系"></a>类与多个对象的关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一、设计类，其实就是设计类的成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  属性 = 成员变量 = field = 域、字段</span></span><br><span class="line"><span class="comment"> *  方法 = 成员方法 = 函数 = method </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  创建类的对象 = 类的实例化 = 实例化类</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  二、类和对象的使用（面向对象思想落地的实现）</span></span><br><span class="line"><span class="comment"> *       1.创建类，设计类的成员</span></span><br><span class="line"><span class="comment"> *       2.创建类的对象</span></span><br><span class="line"><span class="comment"> *       3.通过“对象.属性” 或 “对象.方法”调用对象的结果</span></span><br><span class="line"><span class="comment"> *       </span></span><br><span class="line"><span class="comment"> *  三、如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static）</span></span><br><span class="line"><span class="comment"> *      意味着：如果我们修改一个对象的属性a，则不影响另一个对象属性a的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Person类的对象</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用对象的结构：属性、方法</span></span><br><span class="line">        <span class="comment">//调用属性：“对象.属性”</span></span><br><span class="line">        p1.name = <span class="string">"Tom"</span>;</span><br><span class="line">        p1.isMale = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(p1.name);<span class="comment">//deehuang</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用方法：“对象.方法”</span></span><br><span class="line">        p1.eat();</span><br><span class="line">        p1.sleep();</span><br><span class="line">        p1.talk(<span class="string">"Chinese"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//***********************</span></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(p2.isMale);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//***********************</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把p1变量保存的对象地址值赋值给p3，导致p1和p3指向堆空间中的同一个对象实体</span></span><br><span class="line">        Person p3 = p1;</span><br><span class="line">        System.out.println(p3.name);<span class="comment">//deehuang </span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age =<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：具备的一些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"说话，使用的是"</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的内存解析"><a href="#对象的内存解析" class="headerlink" title="对象的内存解析"></a>对象的内存解析</h3><p>如果上面关于多个对象和类的关系有点难理解挺正常，这涉及了它底层的内存解析。我们来瞅瞅在JVM中对象的内存是怎么分配的：</p>
<p>先让我们来看下java虚拟机结构的图示：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.jpg" class="lozad"></p>
<p>java程序执行的过程：编译完源程序以后，生成一个或多个字节码文件。我们是使用JVM中的类的加载器（或装载器）和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中(一个字节码文件对应一个类)，这就涉及到内存解析（类与类的成员在内存中怎么分配调度）。</p>
<p>而我们对内存解析主要关注的是内存区域中的运行时数据区的方法区、堆和虚拟机栈的东西！</p>
<p>虚拟机栈：即为平时提到的栈结构。我们将<code>局部变量存储在栈结构中</code><br>堆：我们将<code>new出来的结构（比如：数组、对象）加载到堆空间中</code>。补充：对象的属性(非static)加载到堆空间中<br>方法区：类的加载信息、常量池、静态域</p>
<p>首先要明确一个前提：我们上面写的代码一般都是定义在main方法里面的，而我们说：方法中的变量都是局部变量。这意味着它们都存储在需虚拟机栈中！</p>
<p>我们还是通过一组代码加图解去看看对象的内存解析：</p>
<p>我们定义了一个人类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age =<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    <span class="comment">//方法：具备的一些功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"说话，使用的是"</span> + language);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/10.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/11.jpg" class="lozad"></p>
<p>如此详细明了的图解，已经不用多其他的了！ </p>
<h3 id="拓展：对象数组和匿名对象的使用"><a href="#拓展：对象数组和匿名对象的使用" class="headerlink" title="拓展：对象数组和匿名对象的使用"></a>拓展：对象数组和匿名对象的使用</h3><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *对象数组题目：</span></span><br><span class="line"><span class="comment">定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。</span></span><br><span class="line"><span class="comment"> 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</span></span><br><span class="line"><span class="comment">问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line"><span class="comment">问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1) 生成随机数：Math.random()，返回值类型double;  </span></span><br><span class="line"><span class="comment">2) 四舍五入取整：Math.round(double d)，返回值类型long。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建20个学生对象</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s2 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s3 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s4 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s5 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s6 = new Student();</span></span><br><span class="line">        <span class="comment">//一个个new也太low了！我们采用对象数组的方式快速创建20个Student对象</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//声明Student类型的数组</span></span><br><span class="line">		Student[] stus = <span class="keyword">new</span> Student[<span class="number">20</span>];  <span class="comment">//String[] arr = new String[10];</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length;i++)&#123;</span><br><span class="line">			<span class="comment">//给数组元素赋值</span></span><br><span class="line">			stus[i] = <span class="keyword">new</span> Student();</span><br><span class="line">			<span class="comment">//给Student对象的属性赋值</span></span><br><span class="line">			stus[i].number = (i + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//年级：[1,6]</span></span><br><span class="line">			stus[i].state = (<span class="keyword">int</span>)(Math.random() * (<span class="number">6</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//成绩：[0,100]</span></span><br><span class="line">			stus[i].score = (<span class="keyword">int</span>)(Math.random() * (<span class="number">100</span> - <span class="number">0</span> + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++)&#123;</span><br><span class="line"><span class="comment">//			System.out.println(stus[i].number + "," + stus[i].state </span></span><br><span class="line"><span class="comment">//					+ "," + stus[i].score);</span></span><br><span class="line">			</span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(stus[i].state == <span class="number">3</span>)&#123;</span><br><span class="line">				System.out.println(stus[i].info());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; stus.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(stus[j].score &gt; stus[j + <span class="number">1</span>].score)&#123;</span><br><span class="line">					<span class="comment">//如果需要换序，交换的是数组的元素：Student对象！！！</span></span><br><span class="line">					Student temp = stus[j];</span><br><span class="line">					stus[j] = stus[j + <span class="number">1</span>];</span><br><span class="line">					stus[j + <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++)&#123;</span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//学号</span></span><br><span class="line">	<span class="keyword">int</span> state;<span class="comment">//年级</span></span><br><span class="line">	<span class="keyword">int</span> score;<span class="comment">//成绩</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示学生信息的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"学号："</span> + number + <span class="string">",年级："</span> + state + <span class="string">",成绩："</span> + score;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对象数组内存解析</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/17.jpg" class="lozad"></p>
<p><strong>对象数组内存解析需要注意</strong>:</p>
<ul>
<li>引用类型的变量，只可能存储两类值：null 或 地址值(含变量类型)</li>
</ul>
<h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匿名对象的使用</span></span><br><span class="line"><span class="comment"> * 1. 理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象</span></span><br><span class="line"><span class="comment"> * 2. 特征：匿名对象只能调用一次</span></span><br><span class="line"><span class="comment"> * 3. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone p = <span class="keyword">new</span> Phone();<span class="comment">//p就是对象的变量名，我们称这个对象是有名的</span></span><br><span class="line">        p.sendEmail();</span><br><span class="line">        p.playGame();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line">        <span class="keyword">new</span> Phone().playGame();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Phone().price = <span class="number">199</span>;</span><br><span class="line">        <span class="keyword">new</span> Phone().showPrice();<span class="comment">//0.0</span></span><br><span class="line">        <span class="comment">//说明匿名对象只能调用一次，每次调用都是一个 新的对象，互不影响</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名对象的使用</span></span><br><span class="line">        PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line">        mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">        <span class="comment">//此时实际上是把对象赋值给了形参，所以在方法里面可以多次调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//外面的匿名对象赋值给了形参phone，所以对象在这里就变有名了</span></span><br><span class="line">        <span class="comment">//可以多次调用，如下所示拿它调了两次方法</span></span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发邮箱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩游戏"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(price);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h1><p>到此我们就对类和对象的使用有了初步的了解了。再次总结上面的对类和对象的使用实际上就是三个步骤的事情：</p>
<p>类和对象的使用（面向对象思想落地的实现）</p>
<ul>
<li>1.<strong>创建类，设计类的成员</strong></li>
<li>2.创建类的对象</li>
<li>3.通过“对象.属性” 或 “对象.方法”调用对象的结构</li>
</ul>
<p>这三步我认为也是贯穿整个java开发的核心步骤。后面的学习也是基于这三步不断去强化的</p>
<p>接下来要回归正题：其中类的设计是OOP的重点，而类的设计实际上就是设计类的成员，故类的成员这块知识点你说重不重要！所以下面将对类的成员内容进行详细介绍。(有一部分成员在后面的内容在引入，因为需要和其他知识点搭配起来理解)</p>
<h2 id="类的成员之一：属性"><a href="#类的成员之一：属性" class="headerlink" title="类的成员之一：属性"></a>类的成员之一：属性</h2><p>先通过图大致的了解一下属性基本结构</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/13.jpg" class="lozad"></p>
<p>还是通过结合代码理解知识，在前面对对象的内存解析中我们提到了<strong>局部变量</strong>的概念，在代码中也会解决一些童鞋的疑惑：<strong>属性</strong>与<strong>局部变量</strong>的区别是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类中属性的使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 属性：是类中定义的变量，描述类具有的特点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 属性(成员变量)  vs  局部变量</span></span><br><span class="line"><span class="comment"> * 1.相同点：</span></span><br><span class="line"><span class="comment"> * 	1.1 定义变量的格式：数据类型 变量名 = 变量值</span></span><br><span class="line"><span class="comment"> *	1.2 先声明，后使用</span></span><br><span class="line"><span class="comment"> *	1.3 变量都有其对应的作用域(这三点是所有变量的共性)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.不同点：</span></span><br><span class="line"><span class="comment"> *	2.1 在类中声明的位置不同：</span></span><br><span class="line"><span class="comment"> *		属性：直接定义在类的一堆&#123;&#125;内</span></span><br><span class="line"><span class="comment"> *      局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> *	2.2.关于权限修饰符的不同（权限修饰符详细内容在类的封装性去讲） </span></span><br><span class="line"><span class="comment"> *		常用的权限修饰符：private、public、缺省(变量声明前面没有修饰符)、protected</span></span><br><span class="line"><span class="comment"> *	如： private Sting name;   public int age;根据修饰符不同就赋予了变量不同的权限</span></span><br><span class="line"><span class="comment"> *               </span></span><br><span class="line"><span class="comment"> * 		属性：可以在声明属性时，指明权限，使用权限修饰符</span></span><br><span class="line"><span class="comment"> * 			 目前，大家声明属性时，都使用缺省就可以了</span></span><br><span class="line"><span class="comment"> *		局部变量：不可以使用权限修饰符</span></span><br><span class="line"><span class="comment"> *          </span></span><br><span class="line"><span class="comment"> *	2.3 默认初始化值的情况</span></span><br><span class="line"><span class="comment"> *	当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外</span></span><br><span class="line"><span class="comment"> *量类型都是引用类型。</span></span><br><span class="line"><span class="comment"> *		属性：类的属性，根据其类型，都有默认初始化值</span></span><br><span class="line"><span class="comment"> *           整型(byte、short、int、long) --&gt; 0</span></span><br><span class="line"><span class="comment"> *           浮点型(float、double) --&gt; 0.0</span></span><br><span class="line"><span class="comment"> *           字符型(char) --&gt; 0（或'\u0000'）</span></span><br><span class="line"><span class="comment"> *           布尔型(boolean) --&gt; false</span></span><br><span class="line"><span class="comment"> *           引用数据类型(类、数组、接口、String) --&gt; null</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> *		局部变量：没有初始化值。</span></span><br><span class="line"><span class="comment"> * 				意味着我们在的调局部变量之前，一定要显式赋值</span></span><br><span class="line"><span class="comment"> *              特别的：形参在调用时，我们再赋值即可 </span></span><br><span class="line"><span class="comment"> *          </span></span><br><span class="line"><span class="comment"> *	2.4 在内存中加载的位置：</span></span><br><span class="line"><span class="comment"> *		属性：加载到堆空间(非static)</span></span><br><span class="line"><span class="comment"> *      局部变量：加载到栈空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">//属性的默认初始化值</span></span><br><span class="line">        System.out.println(u1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(u1.age);<span class="comment">//0</span></span><br><span class="line">        System.out.println(u1.isMale);<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 局部变量没有初始化值：特别的：形参在调用时，我们再赋值即可 </span></span><br><span class="line">        u1.talk(<span class="string">"中文"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性(或成员变量)</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age; <span class="comment">//可以添加权限修饰符（了解）</span></span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span> </span>&#123;<span class="comment">//language:形参，也是局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"我们使用"</span> + language + <span class="string">"进行交流"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//局部变量没有初始化，报错</span></span><br><span class="line">        <span class="comment">//String food;//The local variable food may not have been initialized</span></span><br><span class="line">        </span><br><span class="line">        String food = <span class="string">"煎饼果子"</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"南方人爱吃："</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你细品，细细地品！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/12.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/14.jpg" class="lozad"></p>
<p>成员变量和成员变量在内存的位置：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/16.jpg" class="lozad"></p>
<h2 id="类的成员之二：方法"><a href="#类的成员之二：方法" class="headerlink" title="类的成员之二：方法"></a>类的成员之二：方法</h2><h3 id="方法的声明与使用"><a href="#方法的声明与使用" class="headerlink" title="方法的声明与使用"></a>方法的声明与使用</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15.jpg" class="lozad"></p>
<p>不多说，直奔主题：类中方法的声明和使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类中方法的声明和使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 方法：描述类应该具有的功能</span></span><br><span class="line"><span class="comment"> * 比如：Math类：sqrt()开方操作、random()[0,1)的随机数、...</span></span><br><span class="line"><span class="comment"> *          Scanner类：nextXxx()用于从键盘获取数据 ...</span></span><br><span class="line"><span class="comment"> *          Arrays类：sort() \ binarySearch() \ toString() \ equals()\ ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 举例几类方法的声明：</span></span><br><span class="line"><span class="comment"> * public void eat()&#123;&#125; //无形参，void表示声明的方法没有返回值</span></span><br><span class="line"><span class="comment"> * public void sleep(int hour)&#123;&#125; //有形参</span></span><br><span class="line"><span class="comment"> * public String getName()&#123;&#125; //无形参，类型 + 方法名表示有返回值(return)的方法</span></span><br><span class="line"><span class="comment"> * public String getNation(String nation)&#123;&#125;//有形参</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  2. 方法的声明：</span></span><br><span class="line"><span class="comment"> *		权限修饰符 返回值类型 方法名(形参列表)&#123;</span></span><br><span class="line"><span class="comment"> *			方法体；</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *      注意:static、final、abstract 来修饰的方法，后面再讲</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> * 3. 说明：</span></span><br><span class="line"><span class="comment"> *  3.1 关于权限修饰符：默认方法的权限修饰符都使用publicJava规定的4种权限修饰符：</span></span><br><span class="line"><span class="comment"> *private、public、缺省、protected --&gt;封装性来细说</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  3.2 返回值类型：有返回值 vs 没有返回值</span></span><br><span class="line"><span class="comment"> *      3.2.1 </span></span><br><span class="line"><span class="comment"> *			如果方法有返回值，则必须在方法声明时，指定返回值的类型，同时，方法中return关键字</span></span><br><span class="line"><span class="comment"> *来返回指定类型的变量或者常量："return 数据"。</span></span><br><span class="line"><span class="comment"> *          如果方法没有返回值，则方法声明时，使用void来表示。就不使用return。但是如果使用</span></span><br><span class="line"><span class="comment"> *的话，只能"return"，表示结束此方法的意思</span></span><br><span class="line"><span class="comment"> *       </span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      3.2.2 思考：我们定义方法该不该有返回值？</span></span><br><span class="line"><span class="comment"> *          ① 看题目要求</span></span><br><span class="line"><span class="comment"> *          ② 凭经验</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  3.3 方法名：属于标识符，遵循标识符的规则和规范：”见名知意“</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  3.4 形参列表：方法可以声明0个，1个，或多个形参</span></span><br><span class="line"><span class="comment"> *  	3.4.1 格式：数据类型1 形参1, 数据类型2 形参2,... </span></span><br><span class="line"><span class="comment"> *          </span></span><br><span class="line"><span class="comment"> *  	3.4.2 思考：我们定义方法时，该不该定义形参？</span></span><br><span class="line"><span class="comment"> *       	① 题目要求</span></span><br><span class="line"><span class="comment"> *          ② 凭经验</span></span><br><span class="line"><span class="comment"> *                  </span></span><br><span class="line"><span class="comment"> *  3.5 方法体：方法功能的体现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * return关键字的使用：</span></span><br><span class="line"><span class="comment"> * 		1.使用范围</span></span><br><span class="line"><span class="comment"> *		2.作用：①结束方法 ②针对有返回值类型的方法使用'return 数据'方式返回所要的数据</span></span><br><span class="line"><span class="comment"> *		3.注意点：return关键字的后面不可以声明执行语句</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. 方法的使用中，可以调用当前类的属性或方法</span></span><br><span class="line"><span class="comment"> *          	 特殊：方法A中又调用了方法A：递归方法	</span></span><br><span class="line"><span class="comment"> *          	 方法中不能定义别的方法！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Customer cust  = <span class="keyword">new</span> Customer();</span><br><span class="line">        cust.eat();</span><br><span class="line">        cust.sleep(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"客户吃饭"</span>);</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//void方法中使用return的意义是结束方法</span></span><br><span class="line">        <span class="comment">//return后不可以加表达式</span></span><br><span class="line">        <span class="comment">//System.out.println("HEOLL");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"休息了"</span> + hour + <span class="string">" 个小时"</span>);</span><br><span class="line">        eat();<span class="comment">//方法的使用中可以调用当前类的方法</span></span><br><span class="line">        <span class="comment">//sleep(10);//递归法，没有终止条件会抛stackoverflowError</span></span><br><span class="line">        <span class="comment">//因为不断调用方法不断给声明形参会在栈中不断创建变量空间最终导致栈溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;<span class="comment">//方法的使用中可以调用当前类的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getNation</span><span class="params">(String nation)</span> </span>&#123;</span><br><span class="line">        String info = <span class="string">"我的国籍是"</span> + nation;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//public void play() &#123;&#125; //方法中不能定义另一个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>方法的重载是比较偏概念性的东西。<br>总结一下构成重载的条件： “两同一不同”</p>
<ul>
<li><p>同一个类、相同方法名</p>
<ul>
<li>参数列表不同：参数个数不同，参数类型不同</li>
</ul>
</li>
</ul>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/18.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/19.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法的重载（overload）  loading...</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</span></span><br><span class="line"><span class="comment"> * 	</span></span><br><span class="line"><span class="comment"> *  "两同一不同":同一个类、相同方法名</span></span><br><span class="line"><span class="comment"> *            参数列表不同：参数个数不同，参数类型不同</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 举例：</span></span><br><span class="line"><span class="comment"> *    Arrays类中重载的sort() / binarySearch()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.判断是否是重载：</span></span><br><span class="line"><span class="comment"> *    跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * 4. 在通过对象调用方法时，如何确定某一个指定的方法：</span></span><br><span class="line"><span class="comment"> *      方法名 ---&gt; 参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		OverLoadTest test = <span class="keyword">new</span> OverLoadTest();</span><br><span class="line">		test.getSum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如下的4个方法构成了重载</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">double</span> d1,<span class="keyword">double</span> d2)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(String s ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如下的3个方法不能与上述4个方法构成重载：因为参数列表相同（只与个数和类型有关）</span></span><br><span class="line"><span class="comment">//	public int getSum(int i,int j)&#123;//跟返回值类型无关</span></span><br><span class="line"><span class="comment">//		return 0;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void getSum(int m,int n)&#123;//参数名不能作为标准，只看类型和个数</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	private void getSum(int i,int j)&#123;//跟修饰符无关</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 重载概念的引入就是为了告诉我们在通过对象调用方法时，如何确定某一个指定的方法：<strong>方法名+ 参数列表</strong></p>
<h3 id="可变个数的形参的方法"><a href="#可变个数的形参的方法" class="headerlink" title="可变个数的形参的方法"></a>可变个数的形参的方法</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/20.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 可变个数形参的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.jdk 5.0新增的内容</span></span><br><span class="line"><span class="comment"> * 2.具体使用：</span></span><br><span class="line"><span class="comment"> *   2.1 可变个数形参的格式：数据类型 ... 变量名</span></span><br><span class="line"><span class="comment"> *   2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个...</span></span><br><span class="line"><span class="comment"> *   2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</span></span><br><span class="line"><span class="comment"> *   2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</span></span><br><span class="line"><span class="comment"> *   2.5 可变个数形参在方法的形参中，必须声明在末尾</span></span><br><span class="line"><span class="comment"> * 	 2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参（由于2.5自然的就有了2.6）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodArgsTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		MethodArgsTest test = <span class="keyword">new</span> MethodArgsTest();</span><br><span class="line">		test.show(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//		test.show("hello");</span></span><br><span class="line"><span class="comment">//		test.show("hello","world");</span></span><br><span class="line"><span class="comment">//		test.show();</span></span><br><span class="line">		</span><br><span class="line">		test.show(<span class="keyword">new</span> String[]&#123;<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"CC"</span>&#125;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"show(String)"</span>);</span><br><span class="line">	&#125;<span class="comment">//只传一个参数的话会优先匹配此方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String ... strs)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"show(String ... strs)"</span>);</span><br><span class="line">		<span class="comment">//想要获取传入的每个参数，要使用循环遍历的方式取到，实际上strs就是一个数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">			System.out.println(strs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//	public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;//5.0以前是使用数组的来定义可变个数形参的方法，所以会跟上面的方法重载冲突</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//The variable argument type String of the method show must be the last parameter</span></span><br><span class="line">    <span class="comment">//意思就是可变个数参数在方法形参中必须声明在最后末尾</span></span><br><span class="line"><span class="comment">//	public void show(String ...strs,int i)&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/21.jpg" class="lozad"></p>
<p>理解上面的内容其实需要明白java关于变量赋值的特性：</p>
<ul>
<li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值</li>
<li>如果变量是引用，此时赋值的是变量所保存的地址值</li>
</ul>
<p>而方法形参的值传递机制其实和变量赋值就是一样的！</p>
<p>我们针对<strong>从形参是基本数据类型</strong>来看一下值传递机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法的形参的传递机制：值传递</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 形参：方法定义时，声明的小括号内的参数</span></span><br><span class="line"><span class="comment">   实参：方法调用时，实际传递给形参的数据</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">2. 值传递机制：</span></span><br><span class="line"><span class="comment">	如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"m = "</span> + m + <span class="string">" , n = "</span> + n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换两个变量的值的方法</span></span><br><span class="line"><span class="comment">//        int temp = m;</span></span><br><span class="line"><span class="comment">//        m = n;</span></span><br><span class="line"><span class="comment">//        n = temp;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把它封装到方法里去实现</span></span><br><span class="line">        ValueTransferTest test = <span class="keyword">new</span> ValueTransferTest();</span><br><span class="line">        test.swap(m, n);<span class="comment">//这里的m和n就是实参</span></span><br><span class="line">        System.out.println(<span class="string">"m = "</span> + m + <span class="string">" , n = "</span> + n);</span><br><span class="line">        <span class="comment">//发现输出的是没有交换的结果？？这是怎么回事？</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//这里的m和n是实参</span></span><br><span class="line">        <span class="comment">//交换两个变量的值的方法</span></span><br><span class="line">        <span class="keyword">int</span> temp = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释上面的问题就需要从内存解析去下手了：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/22.jpg" class="lozad"></p>
<p>swap方法执行完后，它里面的变量的作用域消失，那栈中属于swap的局部变量就相继出栈。从始至终main方法中的局部变量m和n都没有变动。所以就出现了没有交换成功的现象</p>
<hr>
<p>针对<strong>实参是引用数据类型</strong>来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法的形参的传递机制：值传递</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 形参：方法定义时，声明的小括号内的参数</span></span><br><span class="line"><span class="comment">   实参：方法调用时，实际传递给形参的数据</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">2. 值传递机制：</span></span><br><span class="line"><span class="comment">	如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</span></span><br><span class="line"><span class="comment">	如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值(含变量的数据类型)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	思考:</span></span><br><span class="line"><span class="comment">	Person p1 = new Person();</span></span><br><span class="line"><span class="comment">	User u1 = p1;//编译不通过为什么？</span></span><br><span class="line"><span class="comment">	变量赋值要满足两点中的一点：类型一致、满足自动类型提升（不考虑强转的情况）</span></span><br><span class="line"><span class="comment">	而这里就是因为引用类型变量存储的不单是地址值，还包括了变量的数据类型。u1的数据类型已经声明了是User类型了，而p1存的是Person类型+地址值。类型不一致故编译不通过。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTransferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        </span><br><span class="line">        data.m = <span class="number">10</span>;</span><br><span class="line">        data.n = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"m = "</span> + m + <span class="string">" , n = "</span> + n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换m和n的值,这种方式是可以成功的</span></span><br><span class="line"><span class="comment">//        int temp = data.m;</span></span><br><span class="line"><span class="comment">//        data.m = data.n;</span></span><br><span class="line"><span class="comment">//        data.n = temp;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果我们想把交换值的代码封装到方法中</span></span><br><span class="line">        ValueTransferTest test = <span class="keyword">new</span> ValueTransferTest();</span><br><span class="line">        test.swap(data);<span class="comment">//data是引用据类型，这里传递的是实参</span></span><br><span class="line">        System.out.println(<span class="string">"m = "</span> + m + <span class="string">" , n = "</span> + n);</span><br><span class="line">        <span class="comment">//交换成功！</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pubilc <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Data data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//交换m和n的值的方法</span></span><br><span class="line">        <span class="keyword">int</span> temp = data.m;</span><br><span class="line">        data.m = data.n;</span><br><span class="line">        data.n = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面如果传递值是引用数据类型，则可以成功，这是为什么呢？还是需要通过内存解析去解释：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/23.jpg" class="lozad"></p>
<p>对于参数是引用数据类型的方法，此时实参赋给形参的是实参存储数据的地址值。所以它们操作的是同一个对象实体故能成功交互值</p>
<p>到此已经画了不少内存图了，可想而知它的重要性，它对我们分析程序的运行有极大的帮助，在画内存图的过程中只要时刻谨记两个点，就不会出错：</p>
<ol>
<li>内存结构：<ul>
<li>栈：局部变量</li>
<li>堆：new出来的结构（非static）、成员变量、数组</li>
</ul>
</li>
<li>变量：成员变量 vs 局部变量(方法内、方法形参、构造器内、构造器形参、代码块内)</li>
</ol>
<p><em>PS：String类型在上面代码事例中会有特殊情况，这是因为它在内存中是存储在常量池中的，而非堆，关于String类型和方法区的内容我们以后再讲到。这里只要记住值传递机制的两个结论而不要去记上面的代码：</em></p>
<ul>
<li><em>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</em></li>
<li><em>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值(含变量的数据类型)</em></li>
</ul>
<p><strong>简单记就是变量里存的是什么就传的是什么！</strong></p>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/24.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归方法的使用（了解）</span></span><br><span class="line"><span class="comment"> * 1.递归方法：一个方法体内调用它自身。</span></span><br><span class="line"><span class="comment"> * 2. 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制(不用自己写for和While)。</span></span><br><span class="line"><span class="comment"> * 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 例1：计算1-100之间所有自然数的和</span></span><br><span class="line">		<span class="comment">// 方式一：</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		<span class="comment">// 方式二：</span></span><br><span class="line">		RecursionTest test = <span class="keyword">new</span> RecursionTest();</span><br><span class="line">		<span class="keyword">int</span> sum1 = test.getSum(<span class="number">100</span>);</span><br><span class="line">		System.out.println(sum1);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"*****************"</span>);</span><br><span class="line">		<span class="keyword">int</span> value = test.f(<span class="number">10</span>);</span><br><span class="line">		System.out.println(value);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 例1：计算1-n之间所有自然数的和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 例2：计算1-n之间所有自然数的乘积:n!</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//例3：已知有一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line">	<span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//			return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象特性之一：封装性"><a href="#面向对象特性之一：封装性" class="headerlink" title="面向对象特性之一：封装性"></a>面向对象特性之一：封装性</h2><blockquote>
<p>为什么在这里引入封装性的学习？因为我们要引出权限修饰符去介绍类与类的结构！前面已经说到，知识点并非死板的按主线去介绍。里面的许多知识点是相辅相成相互依赖的，根本没办法个说个的，本文主提倡的是循序渐进的方式去总结知识点和博主我的学习心得~所以读者看到这里突然冒出的封装性！不要懵！不要懵！不要懵！</p>
</blockquote>
<h3 id="什么是封装与隐藏"><a href="#什么是封装与隐藏" class="headerlink" title="什么是封装与隐藏"></a>什么是封装与隐藏</h3><p>为什么要封装？</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/25.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/26.jpg" class="lozad"></p>
<p>还是落地到代码去理解知识点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 面向对象的特征一：封装与隐藏</span></span><br><span class="line"><span class="comment"> * 一、 问题的引入：</span></span><br><span class="line"><span class="comment"> *	当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是在实际问题中，我们往往要给属性赋值加入额外的限制条件。这个限制条件就不能在属性声明时体现，我们只能通过方法进行限制条件添加（如:setLegs）同时，我们要避免用户再使用"对象.属性"的方式对属性进行赋值，则需要将属性声明为私有的(private)--&gt;此时，针对于属性就体现了"封装性"。(把它隐藏起来了)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、封装性的体现：</span></span><br><span class="line"><span class="comment"> *	我们将类的属性xxx私有化(private)，同时提供公共的(pubilc)方法来获取(getXxx)和设置(setXxx)此属性的值</span></span><br><span class="line"><span class="comment"> *	PS：这只是封装性的体现，上述不能说等同于封装性，封装性包括了很多体现!!!比如说一个人是好人，在公车上给老人让座只是好人的一个体现而已...还有很多事情体现了这是个好像人（请细品）</span></span><br><span class="line"><span class="comment"> *	拓展：封装性的体现：① 如上  ② 不对外暴露的私有的方法  ③ 单例模式   ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 三、封装性的体现，需要权限修饰来配合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        a.name = <span class="string">"大黄"</span>;</span><br><span class="line">        a.age = <span class="number">6</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//      a.legs = -4;//-4只腿？？？</span></span><br><span class="line">        <span class="comment">//这明显不合理，所以应该将legs属性保护起来，防止乱用。</span></span><br><span class="line">        <span class="comment">//我们要加限制腿数的条件，只能把属性封装成方法去设置</span></span><br><span class="line">        <span class="comment">//并且为了避免外界通过”对象.属性“的方式直接赋值，还要把属性声明为私有的(private)</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置了限定方法，就不允许外界直接去通过调属性a.legs操作</span></span><br><span class="line"><span class="comment">//      a.legs = 4;//The field Animal.legs is not visible</span></span><br><span class="line">        a.setLegs(<span class="number">6</span>);</span><br><span class="line">        a.show();</span><br><span class="line">        a.setLegs(<span class="number">6</span>);</span><br><span class="line">        a.show();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//既然legs属性隐藏起来然后提供设置legs的方法，当然还需要提供获取legs的方法</span></span><br><span class="line">        <span class="keyword">int</span> l = a.getLegs();</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> legs;<span class="comment">//腿的个数，设置成私有权限，让外界不能直接调</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对属性的设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLegs</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//限制腿的个数只能是正数并且是以对数存在</span></span><br><span class="line">        <span class="keyword">if</span>(l &gt;= <span class="number">0</span> &amp;&amp; l % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            legs = l;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            legs = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对属性的获取</span></span><br><span class="line">    <span class="function">pubilc <span class="keyword">int</span> <span class="title">getLegs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> legs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物吃东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name = "</span> + name + <span class="string">", age = "</span> + age + <span class="string">", legs = "</span> + legs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码示例中我们简单体会了下封装性其中一个体现，不难看出要将封装性体现出来需要<strong>权限修饰符</strong>的配合！所以下面让我们看看常用的四种权限修饰符的理解：</p>
<h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/27.jpg" class="lozad"></p>
<p>在这里我们只介绍三种权限：public、缺省和private，因为protected涉及了面向对象的继承性，所以留到学习继承性中去介绍会有更深的体会！</p>
<p>这里我们新建一个包名为<code>io.deehuang.github.java1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">封装性的体现，需要权限修饰来配合。</span></span><br><span class="line"><span class="comment">1.Java规定的4种权限：(从小到大排列)：private、缺省(啥也不写)、protected、public</span></span><br><span class="line"><span class="comment">2.4种权限可以用来修饰“类及类的内部”结构：属性、方法、构造器、内部类</span></span><br><span class="line"><span class="comment">3.具体的，4种权限都可以用来修饰”类的内部“结构：属性、方法、构造器、内部类</span></span><br><span class="line"><span class="comment">	修饰类的话，只能使用：缺省、public</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> orderPrivate;<span class="comment">//私有</span></span><br><span class="line">    <span class="keyword">int</span> orderDefault;<span class="comment">//缺省</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> orderPublic;<span class="comment">//公有</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> orderPrivate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> orderDefault = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> orderPublic = <span class="number">3</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缺省</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> orderPrivate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> orderDefault = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> orderPublic = <span class="number">3</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> orderPrivate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> orderDefault = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> orderPublic = <span class="number">3</span>;  </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里再新建一个class文件写测试类，因为同一个文件下只能有一个public类</span></span><br><span class="line"><span class="comment">//The public type OderTest must be defined in its own file</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Order order = <span class="keyword">new</span> Order();</span><br><span class="line">		</span><br><span class="line">		order.orderDefault = <span class="number">1</span>;</span><br><span class="line">		order.orderPublic = <span class="number">2</span>;</span><br><span class="line">		<span class="comment">//出了Order类之后，私有的结构就不可以调用了</span></span><br><span class="line"><span class="comment">//		order.orderPrivate = 3;//The field Order.orderPrivate is not visible</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		order.methodDefault();</span><br><span class="line">		order.methodPublic();</span><br><span class="line">		<span class="comment">//出了Order类之后，私有的结构就不可以调用了</span></span><br><span class="line"><span class="comment">//		order.methodPrivate();//The method methodPrivate() from the type Order is not visible</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们再新建一个包名为<code>io.deehuang.github.java2</code>进行试图调Java1包的类结构去测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">封装性的体现，需要权限修饰来配合。</span></span><br><span class="line"><span class="comment">1.Java规定的4种权限：(从小到大排列)：private、缺省(啥也不写)、protected、public</span></span><br><span class="line"><span class="comment">2.4种权限可以用来修饰“类及类的内部”结构：属性、方法、构造器、内部类</span></span><br><span class="line"><span class="comment">3.具体的，4种权限都可以用来修饰”类的内部“结构：属性、方法、构造器、内部类</span></span><br><span class="line"><span class="comment">	修饰类的话，只能使用：缺省、public</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> io.deehuang.github.java1.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;<span class="comment">//不同包下的类名可以一样</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Order order = <span class="keyword">new</span> Order();</span><br><span class="line"></span><br><span class="line">		order.orderPublic = <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// 出了Order类所属的包之后，私有的结构、缺省声明的结构就不可以调用了</span></span><br><span class="line"><span class="comment">//		order.orderDefault = 1;</span></span><br><span class="line">		<span class="comment">// order.orderPrivate = 3;//The field Order.orderPrivate is not visible</span></span><br><span class="line"></span><br><span class="line">		order.methodPublic();</span><br><span class="line">		<span class="comment">// 出了Order类所属的包之后，私有的结构、缺省声明的结构就不可以调用了</span></span><br><span class="line"><span class="comment">//		order.methodDefault();</span></span><br><span class="line">		<span class="comment">// order.methodPrivate();//The method methodPrivate() from the type Order is not visible</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以形象点理解四个权限：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/28.jpg" class="lozad"></p>
<p><strong>总结封装性</strong>:</p>
<ul>
<li><p>Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</p>
</li>
<li><p><strong>封装性的体现：</strong></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/40.jpg" class="lozad"></p>
</li>
</ul>
<p>了解了封装性后，我们又回到主题，继续介绍回类的成员!</p>
<h2 id="类的成员之三：构造器（或构造方法）"><a href="#类的成员之三：构造器（或构造方法）" class="headerlink" title="类的成员之三：构造器（或构造方法）"></a>类的成员之三：构造器（或构造方法）</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>任何一个类，都有构造器！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/29.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/30.jpg" class="lozad"></p>
<p>根据参数不同，构造器可以分为如下两类： </p>
<ul>
<li>隐式无参构造器（系统默认提供） </li>
<li>显式定义一个或多个构造器（无参、有参）</li>
</ul>
<p><strong>构造器的使用与说明</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类的结构之三：构造器（或构造方法、constructor）的使用</span></span><br><span class="line"><span class="comment"> * construct：建设、建造。  construction:CCB（中国建设银行）  constructor:建设者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、构造器的作用：</span></span><br><span class="line"><span class="comment"> * 1.创建对象</span></span><br><span class="line"><span class="comment"> * 2.初始化对象的信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、说明：</span></span><br><span class="line"><span class="comment"> * 1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器</span></span><br><span class="line"><span class="comment"> * 2.定义构造器的格式：权限修饰符  类名(形参列表)&#123;&#125;</span></span><br><span class="line"><span class="comment"> * 3.一个类中定义的多个构造器，彼此构成重载</span></span><br><span class="line"><span class="comment"> * 4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</span></span><br><span class="line"><span class="comment"> * 5.一个类中，至少会有一个构造器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> io.deehuang.github.java1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建类的对象:new + 构造器</span></span><br><span class="line">        <span class="comment">//如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();<span class="comment">//我们将Person()这个结构就叫构造器 </span></span><br><span class="line">        p.eat();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在造对象的同时，给对象的属性赋值</span></span><br><span class="line">        <span class="comment">//初始化对象的属性</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"DeeHuang"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发现把空参构造器注释掉后，下面写了不是空参的构造器，创建对象的时候编译失败</span></span><br><span class="line">    <span class="comment">//这是因为一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以有多个构造器，但是形参列表要不同：构造器的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在造对象的同时，给对象的属性赋值</span></span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以有多个构造器，但是形参列表要不同：构造器的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在造对象的同时，给对象的属性赋值</span></span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面通过构造器可以给属性赋值，我们前面说的通过<code>对象.属性</code>的方式也可以赋值或封装属性方法来给属性赋值甚至属性一开始还有默认初始化值或者显式初始化值(直接声明+赋值属性)。不知道各位童鞋是否有疑问：TM这么多值什么这跟什么%￥@！&amp;*……？它们赋值的顺序和过程是怎么样的？莫浮躁~下面就简单介绍属性的赋值过程</p>
</blockquote>
<h3 id="属性的赋值过程"><a href="#属性的赋值过程" class="headerlink" title="属性的赋值过程"></a><strong>属性的赋值过程</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 总结：属性赋值的先后顺序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * ① 默认初始化</span></span><br><span class="line"><span class="comment"> * ② 显式初始化</span></span><br><span class="line"><span class="comment"> * ③ 构造器中初始化</span></span><br><span class="line"><span class="comment"> * ps:上面三个赋值都是对象创建之前的操作，所以就叫初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ④ 通过"对象.方法" 或 "对象.属性"的方式，赋值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 以上操作的先后顺序：① - ② - ③ - ④  </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		User u = <span class="keyword">new</span> User();</span><br><span class="line">		</span><br><span class="line">		System.out.println(u.age);<span class="comment">//1 说明显式赋值在默认初始化后面</span></span><br><span class="line">		</span><br><span class="line">		User u1 = <span class="keyword">new</span> User(<span class="number">2</span>);</span><br><span class="line">		System.out.println(u1.age);<span class="comment">//2 说明构造器初始化在显式赋值的后面</span></span><br><span class="line">        </span><br><span class="line">		u1.setAge(<span class="number">3</span>);</span><br><span class="line">		u1.setAge(<span class="number">5</span>);</span><br><span class="line">		System.out.println(u1.age);<span class="comment">//3 说明“对象.方法”方式赋值在构造器初始化后面</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展：JavaBean和UML类图"><a href="#拓展：JavaBean和UML类图" class="headerlink" title="拓展：JavaBean和UML类图"></a>拓展：JavaBean和UML类图</h3><p>了解一下JavaBean和UML图(随意看看就好，基础篇里用不着)</p>
<h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/31.jpg" class="lozad"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JavaBean是一种Java语言写成的可重用组件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	所谓JavaBean，是指符合如下标准的Java类：</span></span><br><span class="line"><span class="comment">		&gt;类是公共的</span></span><br><span class="line"><span class="comment">		&gt;有一个无参的公共的构造器</span></span><br><span class="line"><span class="comment">		&gt;有属性，且有对应的get、set方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		id = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/32.jpg" class="lozad"></p>
<p>有什么用？经常会看到题目或者需求就是用UML类图表示的！</p>
<h2 id="关键字：this的使用"><a href="#关键字：this的使用" class="headerlink" title="关键字：this的使用"></a>关键字：this的使用</h2><blockquote>
<p>跟封装性的知识点一样，引入在这里是为了能为后面的知识点学习铺垫！</p>
</blockquote>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/33.jpg" class="lozad"></p>
<p>还是落实到代码去理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this关键字的使用：</span></span><br><span class="line"><span class="comment"> * 1.this可以用来修饰、调用：属性、方法、构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.this修饰属性和方法：</span></span><br><span class="line"><span class="comment"> *   this理解为：当前对象  或 当前正在创建的对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  2.1  在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是，</span></span><br><span class="line"><span class="comment"> *   通常情况下，我们都选择省略"this."。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式</span></span><br><span class="line"><span class="comment"> *   的使用"this.变量"的方式，表明此变量是属性，而非形参。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  2.2 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方</span></span><br><span class="line"><span class="comment"> *	法。但是，通常情况下，我们都选择省略"this."。特殊情况下，如果构造器的形参和类的属性同名时，我们必</span></span><br><span class="line"><span class="comment"> *	须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. this调用构造器</span></span><br><span class="line"><span class="comment"> *    ① 我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器</span></span><br><span class="line"><span class="comment"> *    ② 构造器中不能通过"this(形参列表)"方式调用自己</span></span><br><span class="line"><span class="comment"> *    ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了"this(形参列表)"</span></span><br><span class="line"><span class="comment"> *    ④ 规定："this(形参列表)"必须声明在当前构造器的首行</span></span><br><span class="line"><span class="comment"> *    ⑤ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        </span><br><span class="line">        p1.setAge(<span class="number">1</span>);<span class="comment">//0</span></span><br><span class="line">        System.out.println(p1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通常情况下，我们都选择省略"this."。</span></span><br><span class="line">    <span class="comment">//特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eat();<span class="comment">//this也可以调方法</span></span><br><span class="line">        <span class="comment">//假如Person初始化时需要考虑40行代码（下面处省略四十行）</span></span><br><span class="line">        <span class="comment">//那彼此构成重载的构造器都要重复写40行(代码冗余了)?low实在是low。</span></span><br><span class="line">        <span class="comment">//此时可以使用this调用构造器(看下面的重载方法)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();<span class="comment">//调用空参的构造器，防止代码冗余！</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//构造器是正在创建的对象进行初始化,这里的this表示当前正在创建的对象</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        this();//Constructor call must be the first statement in a constructor</span></span><br><span class="line">        <span class="comment">//规定："this(形参列表)"必须声明在当前构造器的首行</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        name = name;//编译器会就近原则的找name 这里就是形参自己赋值给自己</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//关键字this表示当前对象，就会去找对象的同名属性去了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人吃饭"</span>);</span><br><span class="line">        <span class="keyword">this</span>.study();  <span class="comment">//this可以调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键字：package、import的使用"><a href="#关键字：package、import的使用" class="headerlink" title="关键字：package、import的使用"></a>关键字：package、import的使用</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><h4 id="包的使用与作用"><a href="#包的使用与作用" class="headerlink" title="包的使用与作用"></a>包的使用与作用</h4><p>为什么要引入包的概念呢？是为了更好的实现项目中类的管理，所以提供了包的概念</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/34.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/35.jpg" class="lozad"></p>
<p>落实代码中创建一个包和class来看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.deehuang.github.java1;<span class="comment">//package声明类或接口所属的包，声明在源文件的首行</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、package关键字的使用</span></span><br><span class="line"><span class="comment"> *  1.为了更好的实现项目中类的管理，提供包的概念</span></span><br><span class="line"><span class="comment"> *  2.使用package声明类或接口所属的包，声明在源文件的首行</span></span><br><span class="line"><span class="comment"> *  3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)：”见名知意“</span></span><br><span class="line"><span class="comment"> *  4.每”.“一次，就代表一层文件目录</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  补充：同一个包下，不能命名同名的接口、类</span></span><br><span class="line"><span class="comment"> *              不同的包下，可以命名同名的接口、类</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageImportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是jdk中常用的一些包的介绍：</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/38.jpg" class="lozad"></p>
<h4 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h4><p>在包的作用中有介绍到MVC设计模式，这里就简单了解一下（这是javaWeb的知识点，感兴趣的先简单了解一下就可了！莫纠结）</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/36.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/37.jpg" class="lozad"></p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/39.jpg" class="lozad"></p>
<p>直接落实代码中理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.deehuang.github.practice;<span class="comment">//package声明类或接口所属的包，声明在源文件的首行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//导入util下的所有结构</span></span><br><span class="line"><span class="keyword">import</span> io.deehuang.github.java1.PackageImportTest;<span class="comment">//导入不同包的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.deehuang.github.java.Person;<span class="comment">//导入不同包的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;<span class="comment">//lang包的子包内结构需要显方导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、package关键字的使用</span></span><br><span class="line"><span class="comment"> *  1.为了更好的实现项目中类的管理，提供包的概念</span></span><br><span class="line"><span class="comment"> *  2.使用package声明类或接口所属的包，声明在源文件的首行</span></span><br><span class="line"><span class="comment"> *  3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)：”见名知意“</span></span><br><span class="line"><span class="comment"> *  4.每”.“一次，就代表一层文件目录</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  补充：同一个包下，不能命名同名的接口、类</span></span><br><span class="line"><span class="comment"> *              不同的包下，可以命名同名的接口、类</span></span><br><span class="line"><span class="comment"> *        </span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> * 二、import关键字的使用</span></span><br><span class="line"><span class="comment"> *  import：导入</span></span><br><span class="line"><span class="comment"> *  1. 在源文件中显式的使用import结构导入指定包下的类、接口</span></span><br><span class="line"><span class="comment"> *  2. 声明在包的声明和类的声明之间</span></span><br><span class="line"><span class="comment"> *  3. 如果需要导入多个结构，则并列的写出即可</span></span><br><span class="line"><span class="comment"> *  4. 可以使用"xxx.*"的方式，表示可以导入xxx包下所有的结构(不包括子包)</span></span><br><span class="line"><span class="comment"> *  5. 如果使用的类或接口是java.lang包下定义的，可以省略import结构</span></span><br><span class="line"><span class="comment"> *  6.如果使用的类或接口是本包下定义的，则可以省略import结构</span></span><br><span class="line"><span class="comment"> *  7. 如果在源文件中，使用不同报下的同名的类，则必须至少有一个类需要以全类名的方式显示</span></span><br><span class="line"><span class="comment"> *  8.使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包(包里创建的包)下的结构，则仍需要显式导入</span></span><br><span class="line"><span class="comment"> *  9.import static:导入类或接口中的静态结构：属性或方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String info = Arrays.toString(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);<span class="comment">//导入Arrays才能使用</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//需要导入util包下的ArrayList</span></span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();<span class="comment">//也需要导入util包下的HashMap类</span></span><br><span class="line">        <span class="comment">//像这种用到同一个包下多个结构的情况，不需要重复写import，可用" * "号导入</span></span><br><span class="line">       </span><br><span class="line">        PackageImportTest pi = <span class="keyword">new</span> PackageImportTest();<span class="comment">//使用不同包的类需要导入</span></span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">"123"</span>;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//像String和system属于Java的核心包，定义在lang下。不需要导入，可以直接使用</span></span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="comment">//如果在源文件中，使用不同报下的同名的类，则必须至少有一个类需要以全类名的方式显示</span></span><br><span class="line">        <span class="comment">//假设有两个包下都有名为Person类，而我都想在这里用，着就会冲突！</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();<span class="comment">//导入import io.deehuang.github.java1.Person;</span></span><br><span class="line">        <span class="comment">//此时我还想导入java1包里的Person：使用全类名方式显示</span></span><br><span class="line">        io.deehuang.github.java2.Person p1 = <span class="keyword">new</span> io.deehuang.github.java2.Person();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包(包里创建的包)下的结构，则仍需要显式导入</span></span><br><span class="line">        Field field = <span class="keyword">null</span>; <span class="comment">//Field类是lang包下reflect包里的结构。因为是子包所以需要显式import,不可省略</span></span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//import static:导入类或接口中的静态结构：属性或方法</span></span><br><span class="line">        out.println();<span class="comment">//out静态结构在前面被导入后可以直接用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的成员在本模块里只介绍了三个，本模块的内容至此也先告一段落了。其他成员如内部类和代码块因为需要引入继承等知识的概念才能更好的上手掌握，所有需要先进入到下一个模块的学习再在其中插入介绍。还是那句话学习是循序渐进的过程，知识点的杂糅是希望有承上启下的作用。所以后面的模块中突然介绍到别的类的成员的时候莫懵逼！建议各位童鞋可以多回去看看写在开头的话~</p>
<hr>
<h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><blockquote>
<p>面向对象的三大特性有：封装、继承、多态。<br>封装性的知识点在上面的类与类的结构模块中已经提到，所以这里主要介绍的是继承与多态，以及引入一些与之紧密联系的知识点（包括未介绍完的类的成员以及一些关键字的使用）</p>
</blockquote>
<h2 id="面向对象特性之二：继承性"><a href="#面向对象特性之二：继承性" class="headerlink" title="面向对象特性之二：继承性"></a>面向对象特性之二：继承性</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/41.jpg" class="lozad"></p>
<p>继承性其实是一个非常好理解的知识点。首先看下面两个UML类图：</p>
<p>为描述和处理个人信息，定义Person类：</p>
<img style="zoom: 67%;" data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/42.jpg" class="lozad">



<p>为描述和处理学生信息，定义Student类：</p>
<img style="zoom: 67%;" data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/43.jpg" class="lozad">

<p>我们发现，Student类里面除了<code>school</code>属性外，其他的属性和方法都在Person类中定义过了。如果还有其他的比如Teacher类、Waiter类等等类需要定义相同的属性和行为的时，那我们这些方法都要重复的写一遍。这不仅十分麻烦而且会让我们的代码显得臃肿，这时候我们可能会想到能否有一种方式，让两个类“发生关系”，使得Student类去复用一下Person类的代码？Yes！这种方式就是继承。使用继承的方式去设计代码，可以减少代码冗余、大大提高代码的复用性！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/44.jpg" class="lozad"></p>
<p>在这里我们把继承的Person叫做Student的父类，而自然而然的Student就是Person的子类了。</p>
<h3 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h3><ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。 </li>
<li>继承的出现，更有利于功能的扩展。 </li>
<li>继承的出现让类与类之间产生了关系，为之后多态性的使用提供了前提</li>
</ul>
<p><em>注意：不要仅为了获取其他类中某个功能而去继承</em></p>
<h3 id="继承性的使用"><a href="#继承性的使用" class="headerlink" title="继承性的使用"></a>继承性的使用</h3><p>终究要回归代码层面去看看继承性是怎么回事</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 面向对象的特征之二：继承性    why?</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一、继承性的好处：</span></span><br><span class="line"><span class="comment"> * ① 减少了代码的冗余，提高了代码的复用性</span></span><br><span class="line"><span class="comment"> * ② 便于功能的扩展</span></span><br><span class="line"><span class="comment"> * ③ 为之后多态性的使用，提供了前提</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二、继承性的格式： class A extends B&#123;&#125;</span></span><br><span class="line"><span class="comment"> *  A：子类、派生类、subclass</span></span><br><span class="line"><span class="comment"> *  B：父类、超类、基类、superclass</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  2.1 体现：一旦子类A继承父类B以后，子类A就获取了父类B中声明的所有属性、方法</span></span><br><span class="line"><span class="comment"> *      特别的：父类声明为private的属性和方法，子类继承父类以后，仍然认为获取父类中私有的结构。</span></span><br><span class="line"><span class="comment"> *  只是因为封装性的影响，使得子类不能直接调用父类的结构而已</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展</span></span><br><span class="line"><span class="comment"> *  子类和父类的关系，不同于子集和集合的关系</span></span><br><span class="line"><span class="comment"> *  extends是延展、拓展的意思</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//父类声明为private的属性和方法，子类继承父类以后，仍然认为获取父类中私有的结构</span></span><br><span class="line">        <span class="comment">//只是因为封装性的影响，使得子类不能直接调用父类的结构而已</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//        s1.age = 1; //父类的私有属性，出了类不能调。这是因为封装性的影响</span></span><br><span class="line">        s1.eat();</span><br><span class="line">        s1.name = <span class="string">"deehuang"</span>;</span><br><span class="line">        s1.setAge(<span class="number">10</span>);</span><br><span class="line">       <span class="comment">//如果没有继承过来即s1对象中不会有age属性，那么调用getAge()方法也会找不到age而报错</span></span><br><span class="line">        <span class="comment">//能通过getAge方法获取private属性age说明子类会把父类声明private的属性也继承过来</span></span><br><span class="line">        System.out.println(s1.getAge());<span class="comment">//10 说明是继承过来了</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继承父类的属性不用自己重复写了</span></span><br><span class="line"><span class="comment">//    String name;</span></span><br><span class="line"><span class="comment">//    int age;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子类继承父类以后，还可以声明自己的属性或方法：实现功能的拓展</span></span><br><span class="line">    String major;<span class="comment">//年级---声明自己的属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, String major)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="comment">//        this.age = age;//父类的私有属性子类不能调了！</span></span><br><span class="line">        <span class="keyword">this</span>.getAge();</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//继承父类的方法不用自己重复写了</span></span><br><span class="line"><span class="comment">//    public void eat() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("恰饭");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//    public void sleep() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("睡觉");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子类可与声明自己的属性或方法,实现功能的拓展</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java关于继承性的规定："><a href="#Java关于继承性的规定：" class="headerlink" title="Java关于继承性的规定："></a>Java关于继承性的规定：</h3><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/45.jpg" class="lozad"></p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/46.jpg" class="lozad"></p>
<ol>
<li>一个类可以被多个子类继承</li>
<li>Java中类的单继承性：一个类只能有一个父类</li>
<li>子父类是相对的概念：一个子类也有可能是别的类的父类</li>
<li>子类直接继承的父类，称为：直接父类。间接继承的父类成为：间接父类</li>
<li>子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</li>
</ol>
<hr>
<p>讲到直接和间接的继承关系，就不得不提到Java中默认被所有类所有类直接或间接继承的类!</p>
<h3 id="拓展：初探Object类"><a href="#拓展：初探Object类" class="headerlink" title="拓展：初探Object类"></a><strong>拓展：初探Object类</strong></h3><p>我们随便声明一个Person类，里面没有任何结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中new一个Person类的对象，通过”.”的方式发现Eclipse给我列出了一些不知从何而来的方法？并且说明了它们来自Object类！</p>
<p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/47.jpg" class="lozad"></p>
<p>这说明如果我们没有显式的声明一个类的父类的话，则此类继承于<code>java.lang.Object</code>类</p>
<p>上面我们说到子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法的结论：可以推导出：<br>所有的java类（除j<code>ava.lang.Object</code>类之外）都直接或间接地继承于<code>Java.lang.Object</code>类。<br>也就意味着，所有的java类具有<code>java.lang.Obeject</code>类声明的功能</p>
<p>所以Object也叫做根父类，它是所有类的父类！</p>
<blockquote>
<p>这里的只是简单的引入下Object类，具体Object类的使用我们后面的另外起模块讲解！ </p>
<p>了解了继承性之后我们就可以在此基础上学习更多主线中的知识点了</p>
</blockquote>
<h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p><img alt data-src="/2019/11/25/JavaSE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/48.jpg" class="lozad"></p>
<p>方法的重写这块知识点其实并不难，老规矩，东西都写在代码块中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 方法的重写(override / overwrite)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. 重写的规定：</span></span><br><span class="line"><span class="comment"> *          方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型&#123;</span></span><br><span class="line"><span class="comment"> *                      //方法体</span></span><br><span class="line"><span class="comment"> *                  &#125;</span></span><br><span class="line"><span class="comment"> *          约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      ① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同	</span></span><br><span class="line"><span class="comment"> *      ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符（可以大于）</span></span><br><span class="line"><span class="comment"> *          &gt;特殊情况：子类不能重写父类中声明为private权限的方法</span></span><br><span class="line"><span class="comment"> *      ③ 返回值类型：</span></span><br><span class="line"><span class="comment"> *          &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</span></span><br><span class="line"><span class="comment"> *          &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</span></span><br><span class="line"><span class="comment"> *          &gt;父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</span></span><br><span class="line"><span class="comment"> *      ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到JavaSE高级篇去说）</span></span><br><span class="line"><span class="comment"> *  **********************************************************************</span></span><br><span class="line"><span class="comment"> *      子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。 具体放在static关键字模块中再去介绍   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">"IT"</span>);</span><br><span class="line">        s.walk(<span class="number">10</span>);<span class="comment">//输出的了Person类中的show引证了3.②的结论</span></span><br><span class="line">        s.study();</span><br><span class="line">        </span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">      <span class="comment">//重写以后，当创建子类对象后，通过子类对象调用父类中的同名同参数的方法时，实际执行的是子类父类重写的方法</span></span><br><span class="line">        s.eat();</span><br><span class="line">        p.eat();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恰饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"走路：走了"</span> + distance + <span class="string">"公里"</span>);</span><br><span class="line">        show();<span class="comment">//private无法重写，所以调用的是父类的show</span></span><br><span class="line">        eat();<span class="comment">//eat方法被重写，所以调用的是子类的eat()</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子类不能重写父类中声明为private权限的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一个人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String major;<span class="comment">// 专业</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String major)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学习：专业是"</span> + major);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对父类中的eat方法进行了重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生在学生饭堂恰鸡腿"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</span></span><br><span class="line">    <span class="comment">// 父类是Public，此时编译报错</span></span><br><span class="line"><span class="comment">//    void eat() &#123;</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 子类不能重写父类中声明为private权限的方法（这里就没有构成重写了）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一个学生"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面向对象特性之二：多态性"><a href="#面向对象特性之二：多态性" class="headerlink" title="面向对象特性之二：多态性"></a>面向对象特性之二：多态性</h2></div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE    </a><a class="post-meta__tags" href="/tags/java/">java    </a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象    </a></div><div class="post_share"><div class="social-share" data-image="/img/cover_default2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/11/23/Java%E5%85%A5%E9%97%A8/"><img class="next_cover lozad" data-src="/img/cover_default3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>JavaSE基础篇</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/23/Java入门/" title="JavaSE基础篇"><img class="relatedPosts_cover lozad"data-src="/img/cover_default3.jpg"><div class="relatedPosts_title">JavaSE基础篇</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzI1MC8yMzc1MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer style="background-image: url(/img/cover_default2.jpg)"><div id="footer"><div class="copyright">&copy;2019 By Rhubarb C</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script color="0,0,255" opacity="0.7" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>