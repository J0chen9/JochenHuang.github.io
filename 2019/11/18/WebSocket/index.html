<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>WebSocket | RhubarbC的博客</title><meta name="description" content="关于WebSocket的个人学习心得:WebSocket协议是基于TCP的一种新的协议。WebSocket最初在HTML5规范中被引用为TCP连接，作为基于TCP的套接字API的占位符。它实现了浏览器与服务器全双工(full-duplex)通信。其本质是保持TCP连接，在浏览器和服务端通过Socket进行通信。 本文将python去编写websocket服务端来去一步步分析请求过程~"><meta name="keywords" content="python,Tornado,Websocket"><meta name="author" content="Rhubarb C"><meta name="copyright" content="Rhubarb C"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/11/18/WebSocket/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="WebSocket"><meta name="twitter:description" content="关于WebSocket的个人学习心得:WebSocket协议是基于TCP的一种新的协议。WebSocket最初在HTML5规范中被引用为TCP连接，作为基于TCP的套接字API的占位符。它实现了浏览器与服务器全双工(full-duplex)通信。其本质是保持TCP连接，在浏览器和服务端通过Socket进行通信。 本文将python去编写websocket服务端来去一步步分析请求过程~"><meta name="twitter:image" content="http://yoursite.com/img/cover_default2.jpg"><meta property="og:type" content="article"><meta property="og:title" content="WebSocket"><meta property="og:url" content="http://yoursite.com/2019/11/18/WebSocket/"><meta property="og:site_name" content="RhubarbC的博客"><meta property="og:description" content="关于WebSocket的个人学习心得:WebSocket协议是基于TCP的一种新的协议。WebSocket最初在HTML5规范中被引用为TCP连接，作为基于TCP的套接字API的占位符。它实现了浏览器与服务器全双工(full-duplex)通信。其本质是保持TCP连接，在浏览器和服务端通过Socket进行通信。 本文将python去编写websocket服务端来去一步步分析请求过程~"><meta property="og:image" content="http://yoursite.com/img/cover_default2.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Tornado框架进阶" href="http://yoursite.com/2019/11/19/Tornado%E6%A1%86%E6%9E%B6%E8%BF%9B%E9%98%B6/"><link rel="next" title="Tornado框架入门" href="http://yoursite.com/2019/11/16/Tornado%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://deehuang.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: Rhubarb C","link":"链接: http://yoursite.com/2019/11/18/WebSocket/","source":"来源: RhubarbC的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">RhubarbC的博客</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#WebScoket介绍："><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">WebScoket介绍：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#WebScoket握手过程"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">WebScoket握手过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Websocket数据解析过程"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">Websocket数据解析过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Tornado实现web群聊"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Tornado实现web群聊</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#结语"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">结语</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#WebScoket介绍："><span class="toc-number">1.</span> <span class="toc-text">WebScoket介绍：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WebScoket握手过程"><span class="toc-number">2.</span> <span class="toc-text">WebScoket握手过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Websocket数据解析过程"><span class="toc-number">3.</span> <span class="toc-text">Websocket数据解析过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tornado实现web群聊"><span class="toc-number">4.</span> <span class="toc-text">Tornado实现web群聊</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结语"><span class="toc-number">5.</span> <span class="toc-text">结语</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/cover_default2.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">WebSocket</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-18<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-19</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/WebSocket/">WebSocket</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 19 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="WebScoket介绍："><a href="#WebScoket介绍：" class="headerlink" title="WebScoket介绍："></a>WebScoket介绍：</h1><p>HTTP是基于Socket实现的协议。它是短链接（发一个请求：连接响应断开），规定了由浏览器发起请求，服务端只负责响应这样的通讯模式<br>HTTP是一种在一个TCP连接上进行单工通信的协议。只有客户端能主动往服务端发送请求然后服务端返回响应，而服务端却不能主动的给客户端发送数据。</p>
<p>WebScoket是一个双工通道。也是通过Socket实现的协议。与HTTP不同的是：客户端和服务端连接后，客户端不会直接断开。而是双端相互之间都可以一直地随意地发送接收消息直到一方主动断开链接。<br>WebScoket让我们可以在客户端和Web服务端之间实现实时通信，不需要客户端发起请求，服务端可以主动直接向客户端<strong>推送</strong>数据！</p>
<p>如果还觉得有点迷糊，这里有个最常见的应用场景就是“聊天室”！<br>程序设计的需求是：某人往群里发了一条消息，所有人都会收到这条消息。<br>如果按照HTTP的请求响应模式去设计程序，那么每个人都需要一直往服务端长轮询的发请求来监测是否有消息发到群里。使用WebSocket就不一样了，某人往群里发了消息，服务端主动给每个人推送过去。卧槽，有没有突然醍醐灌顶的感觉！</p>
<h1 id="WebScoket握手过程"><a href="#WebScoket握手过程" class="headerlink" title="WebScoket握手过程"></a>WebScoket握手过程</h1><p>WebSocket本质上就是一个Socket!两人建立连接，谁也<u>不断开</u>，我能给你发消息，你也能给我发消息！</p>
<p>WebSocket分为客户端和服务端，它们的握手（连接）过程是这样的：</p>
<ul>
<li><p>服务端：有两种，一种是我们自己手写的Socket服务端。另外一种是<u>web框架</u>就是别人写好的socket服务端</p>
<ol>
<li><p>服务端开启Socket，监听IP和端口等待客户端来连接</p>
</li>
<li><p>允许连接</p>
</li>
<li><p><em>服务端接收到特殊的值，【把特殊值和magic string相加进行哈希加密sha1】<br>*PS:magic string是一个固定的字符串！magic string=’ 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 ‘</em></p>
</li>
<li><p>*加密后的值发送给客户端</p>
</li>
</ol>
</li>
<li><p>客户端：浏览器</p>
<ol start="2">
<li><p>客户端向服务端（IP和端口）发起连接请求，连接成功后就可以收发数据</p>
</li>
<li><p><em>客户端生成一个特殊值（随机字符串）,【把特殊值和magic string相加进行哈希加密sha1】，把加密值保留在本地用作验证，然后向服务端发送一段特殊值<br>*PS:migic string是一个固定的字符串！migc string=’ 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 ‘</em></p>
</li>
<li><p>*客户端接收到加密的值 ，与本地的加密值作对比。如果一致两个加密值的话就表示服务端协议与客户端协议一样，即本次握手过程就是遵循websocket的！websocket连接建立成功！、</p>
</li>
</ol>
</li>
<li><p>收发数据：websocket连接创建成功后双方就可以随意地收发数据：客户端可以主动向服务端发，服务端也可以主动向客户端发</p>
</li>
</ul>
<p>PS：上面执行过程没有星号的是TCP的握手过程，【*】号的执行过程表示的是websocket的握手过程。<br>当客户端向服务端发送连接请求时，不仅连接 （TCP握手）。 还会发送【握手】信息，并等待服务端响应（WebSocket握手过程），至此连接才创建成功！ </p>
<p>下面让我们来使用python去实现WebSocket握手过程： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""1.启动服务端"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8002</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 等待用户连接</span></span><br><span class="line">conn, address = sock.accept()</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2.客户端连接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8002/xxoo"</span>); <span class="comment">//ws表示的是websocket协议</span></span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="comment">//这句代码浏览器内部就帮我们做了客户端websocket的所有握手工作（发握手请求，拿到响应进行验证）</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//当客户端向服务端发送连接请求时，不仅连接还会发送【Ws握手请求】信息，并等待服务端响应【Ws握手】，至此WS握手（连接）才创建成功！</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">3.建立连接（ws握手）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请求和响应的【握手】信息需要遵循规则：</span></span><br><span class="line"><span class="string">从请求【握手】信息中提取 Sec-WebSocket-Key</span></span><br><span class="line"><span class="string">利用magic_string 和 Sec-WebSocket-Key 进行sha1加密，再进行base64加密</span></span><br><span class="line"><span class="string">将加密结果响应给客户端</span></span><br><span class="line"><span class="string">注：magic string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请求【握手】信息为（ws请求格式）：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">GET /chatsocket HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 127.0.0.1:8002</span></span><br><span class="line"><span class="string">Connection: Upgrade</span></span><br><span class="line"><span class="string">Pragma: no-cache</span></span><br><span class="line"><span class="string">Cache-Control: no-cache</span></span><br><span class="line"><span class="string">Upgrade: websocket</span></span><br><span class="line"><span class="string">Origin: http://localhost:63342</span></span><br><span class="line"><span class="string">Sec-WebSocket-Version: 13</span></span><br><span class="line"><span class="string">Sec-WebSocket-Key: mnwFxiOlctXFN/DeMt1Amg==</span></span><br><span class="line"><span class="string">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> haxshlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_headers</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将请求头格式化成字典</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    header_dict = &#123;&#125;</span><br><span class="line">    data = str(data, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    header, body = data.split(<span class="string">'\r\n\r\n'</span>, <span class="number">1</span>)</span><br><span class="line">    header_list = header.split(<span class="string">'\r\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(header_list)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> len(header_list[i].split(<span class="string">' '</span>)) == <span class="number">3</span>:</span><br><span class="line">                header_dict[<span class="string">'method'</span>], header_dict[<span class="string">'url'</span>], header_dict[<span class="string">'protocol'</span>] = header_list[i].split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k, v = header_list[i].split(<span class="string">':'</span>, <span class="number">1</span>)</span><br><span class="line">            header_dict[k] = v.strip()</span><br><span class="line">    <span class="keyword">return</span> header_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8002</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#获取客户端socket对象</span></span><br><span class="line">conn, address = sock.accept()</span><br><span class="line"><span class="comment">#获取客户端的【ws握手】请求消息</span></span><br><span class="line">data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#提取【握手请求消息】中的websocket-key与magic string进行sha1加密</span></span><br><span class="line">headers = get_headers(data) <span class="comment">#提取请求头信息（与http请求格式一样请求头请求体以换行分割）</span></span><br><span class="line">magic_string = <span class="string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span></span><br><span class="line">value = headers[<span class="string">'Sec-WebSocket-Key'</span>] + magic_string</span><br><span class="line">ac = base64.b64encode(hashlib.sha1(value.encode(<span class="string">'utf-8'</span>)).digest()) <span class="comment">#返回给客户端的加密值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把ws握手响应发送回客户端</span></span><br><span class="line"><span class="comment">#ws响应格式，</span></span><br><span class="line">response_tpl = <span class="string">"HTTP/1.1 101 Switching Protocols\r\n"</span> \</span><br><span class="line">      <span class="string">"Upgrade:websocket\r\n"</span> \</span><br><span class="line">      <span class="string">"Connection: Upgrade\r\n"</span> \</span><br><span class="line">      <span class="string">"Sec-WebSocket-Accept: %s\r\n"</span> \    </span><br><span class="line">      <span class="string">"WebSocket-Location: ws://%s%s\r\n\r\n"</span></span><br><span class="line"><span class="comment">#将生成的加密值放到Sec-webSocket-Accept请求头中所对应的值中</span></span><br><span class="line">response_str = response_tpl % (ac.decode(<span class="string">'utf-8'</span>), headers[<span class="string">'Host'</span>], headers[<span class="string">'url'</span>])</span><br><span class="line"><span class="comment"># 响应【握手】信息</span></span><br><span class="line">conn.send(bytes(response_str, encoding=<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 检验是否ws握手（连接）成功 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8002/xxoo"</span>); <span class="comment">//ws表示的是websocket协议</span></span></span><br><span class="line"><span class="actionscript">    socket.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">1111</span>)  </span></span><br><span class="line"><span class="actionscript">    &#125; <span class="comment">// 如果ws握手成功 就会触发该函数的执行。失败就不会触发</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>websocket连接建立成功后，接下来就可以进行客户端和服务端的收发数据了。这个过程里面也是十分的有门道！</p>
<p>在学习前先补充一个知识点：位运算和与运算</p>
<p>位运算:1001001<br>右移动 &gt;&gt;  右4位：00001001（相当于把低四位删掉，前后在高位补4个0）<br>左移动&lt;&lt;   左4位：100100010000 （直接在低位后面补零） </p>
<p>与运算:&amp;<br>a,b是1,1：1<br>a,b是0,1：0<br>a,b是0,0：0</p>
<h1 id="Websocket数据解析过程"><a href="#Websocket数据解析过程" class="headerlink" title="Websocket数据解析过程"></a>Websocket数据解析过程</h1><p>websocket客户端和服务端收发数据时，需要对数据进行【封包】和【解包】。客户端的JavaScript类库已经封装【封包】和【解包】过程，但Socket服务端需要手动实现。 </p>
<p>也就是说我们接收和发送数据都不能直接通过<code>sent</code>和<code>recv</code>去发送或者接收，websocket规定了收发消息的数据格式，即如果你要使用websocket进行通讯，那么久必须要去遵循它的规则去对收发的数据进行解析！</p>
<p>客户端即浏览器内部已经帮我们封装好了对websocket数据的解析的功能，我们直接调用websocket对象<code>send</code>或者<code>onmessage</code>方法就可以好似没有解析过程似的直接去收发消息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- websocket客户端发送消息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8002/xxoo"</span>); <span class="comment">//ws表示的是websocket协议</span></span></span><br><span class="line"><span class="actionscript">    socket.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        socket.send(<span class="string">'deehuang真帅！'</span>)</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="comment">// 如果ws握手成功 就会触发该函数的执行。失败就不会触发</span></span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    socket.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event);   <span class="comment">//event封装了关于消息的一些信息，通过event.data可以拿到数据</span></span></span><br><span class="line"><span class="actionscript">    &#125; <span class="comment">// 如果接收到了服务端发送的数据会出发该函数的执行</span></span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    ws.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="comment">//服务端主动断开连接的时候会触发该函数的执行！</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是在我们Socket服务端中却没有提供这样的功能。所以在服务端中如果我们要通过websocket向客户端发送数据，则需要对数据按websocket的规则进行封装，这个过程叫做【封包】。反之如果我们要接收客户端的数据的话需要按websocket的规则进行【解包】过程，否则拿到的数据我们是看不明白的！</p>
<p>下面是websocket服务端的数据解析过程：</p>
<p> 一、解包过程：</p>
<p>下表是websocket数据包格式，让我们来解读一下它的意思</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">解读上表去实现解包：</span></span><br><span class="line"><span class="string">客户端发送过来的数据实际上就是在要发送的数据的前面塞点头部信息进去！它就是按上表中的格式进行封包的！解包就是如何解析这个数据包去获取客户端发来的数据</span></span><br><span class="line"><span class="string">PS：数据包传输过来就是一堆二进制格式的数字，这些二进制数字一位或者多位数字组成的值有不同的涵义。我们要学习解析数据包就是去了解它是怎么封包的：数据头包含了什么信息？如何去解读这些位都表示了什么？我们的客户端发送的数据封装在那些位上？在这里只是介绍怎么去获取到我们要的数据部分</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">假设info是从客户端发送来的数据包：</span></span><br><span class="line"><span class="string">1.表头上面数字从左到右起每八位表示一个字节，例如开始的：0 1 2 3 4 5 6 7，这八个值就表示第一个字节中的八位。以此类推8 9 0 1 2 3 4 5第二个字节的八位......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2.info[0]获取数据包的第一个字节信息，info[1]获取数据包的第二个字节信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3.每个字节中的一位和多位组成的值表达了不同的涵义(表的第一行写了名字)，如第一个字节的第一位代表的是FIN。获取这些值可以通过位运算或者与运算的方式实现。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4.payload_len的值是告诉我们数据头所占的长度的【它的最大值是127（因为该值最多占7位）】</span></span><br><span class="line"><span class="string">当payload_len&lt;126的时候表示数据头就占0~15位即数据头占2字节的长度</span></span><br><span class="line"><span class="string">当payload_len=126的时候表示数据头长度在0~15位的基础再延伸16位，即数据头总共占用4个字节长度</span></span><br><span class="line"><span class="string">当payload_len=126的时候表示数据头长度在0~15位的基础再延伸64位，即数据头总共占用10个字节长度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5.数据包中的数据信息是被加密过的，通过payload_len我们可以定下数据头的长度。数据头往后的4个字节表示的是masking key的值，它是用来给数据解密的！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6.一个数据包的由三部分组成：数据头（payload告诉长度）--&gt;masking key（4字节）--&gt;数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#怎么获取特定位的值？</span></span><br><span class="line">info = conn.recv(<span class="number">8096</span>)  <span class="comment">#获取客户端发送的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取FIN可以采用位运算的方式，它的值是第一个字节的第一位</span></span><br><span class="line"><span class="comment">#info[0]表示获取的第一个字节(上表中的0~7)的数据，第一个字节(八个值)中向右移七位就可获得FIN的值</span></span><br><span class="line">fin = info[<span class="number">0</span>] &gt;&gt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取opcode可以采用与运算的方式，它的值是第一个字节的后四位</span></span><br><span class="line"><span class="comment">#info[0]表示获取的第一个字节(上表中的0~7)的数据，op的最大值是1111即15，进行与运算就拿到后四位的值</span></span><br><span class="line">opcode = info[<span class="number">0</span>] &amp; <span class="number">15</span>   <span class="comment">#计算后四位的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取Payload len同理，它的值是第二个字节的后七位</span></span><br><span class="line"><span class="comment">#info[1]表示获取第二个字节，Payload的最大值1111111的值是127，进行与运算就得到后七位的值</span></span><br><span class="line">payload_len = info = info[<span class="number">1</span>] &amp; <span class="number">127</span></span><br></pre></td></tr></table></figure>

<p>下面是代码具体实现获取客户端的数据【解包】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = conn.recv(<span class="number">8096</span>)  <span class="comment">#获取客户端发送的数据（字节格式）</span></span><br><span class="line"></span><br><span class="line">   payload_len = info[<span class="number">1</span>] &amp; <span class="number">127</span></span><br><span class="line">   <span class="keyword">if</span> payload_len == <span class="number">126</span>: <span class="comment">#数据头占4个字节（延长两个）</span></span><br><span class="line">       extend_payload_len = info[<span class="number">2</span>:<span class="number">4</span>] <span class="comment">#获取延出的两个字节的值</span></span><br><span class="line">       mask_key = info[<span class="number">4</span>:<span class="number">8</span>]  <span class="comment">#在数据头的后面取4个字节</span></span><br><span class="line">       decoded = info[<span class="number">8</span>:]  <span class="comment">#这就是我们的数据，因为它被mask_key加密了所以才命名decoded</span></span><br><span class="line">   <span class="keyword">elif</span> payload_len == <span class="number">127</span>: <span class="comment">#数据头占10字节（延出八个）</span></span><br><span class="line">       extend_payload_len = info[<span class="number">2</span>:<span class="number">10</span>]  <span class="comment">#获取延出的八个字节的值</span></span><br><span class="line">       mask_key = info[<span class="number">10</span>:<span class="number">14</span>]</span><br><span class="line">       decoded = info[<span class="number">14</span>:]</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       extend_payload_len = <span class="literal">None</span> <span class="comment">#数据头没有延长</span></span><br><span class="line">       mask_key = info[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">       decoded = info[<span class="number">6</span>:]</span><br><span class="line"></span><br><span class="line">   bytes_list = bytearray()</span><br><span class="line">   <span class="comment">#解密数据,官方文档是通过这样解的</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(len(decoded)):</span><br><span class="line">       <span class="comment">#把数据部分每一个字节一个字节与mask_key进行异或运算</span></span><br><span class="line">       chunk = decoded[i] ^ mask_key[i % <span class="number">4</span>]</span><br><span class="line">       bytes_list.append(chunk) <span class="comment">#把解码的数据先统一变成字节最后再一起转换成字符串</span></span><br><span class="line">   body = str(bytes_list, encoding=<span class="string">'utf-8'</span>) <span class="comment">#这就可以去解码中文了(utf8中文占三字节)！</span></span><br><span class="line">   print(body)</span><br></pre></td></tr></table></figure>

<p>二、封包过程：</p>
<p>如果我们要向客户端发送数据就要对数据进行封包。</p>
<p>有了上面解包的基础！不难理解封包就是在按上面协议规定的数据包格式进行封装就完事！一个数据包一般是由三部分组成：数据头–&gt;mask_key–&gt;数据。对于封包我们可以使用<em>struct</em>模块帮助我们轻松实现！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(conn, msg_bytes)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    WebSocket服务端向客户端发送消息</span></span><br><span class="line"><span class="string">    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()</span></span><br><span class="line"><span class="string">    :param msg_bytes: 向客户端发送的字节</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">import</span> struct <span class="comment">#封装二进制包的模块</span></span><br><span class="line"></span><br><span class="line">    token = <span class="string">b"\x81"</span> <span class="comment">#发送第一个字节的数据头即FIN这些位</span></span><br><span class="line">    length = len(msg_bytes)</span><br><span class="line">    <span class="comment">#根据数据长度的不同使用不同模式的封包（模块内部就是加上payload_len和mask_key把数据放后面）</span></span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">126</span>: </span><br><span class="line">        token += struct.pack(<span class="string">"B"</span>, length)</span><br><span class="line">    <span class="keyword">elif</span> length &lt;= <span class="number">0xFFFF</span>:</span><br><span class="line">        token += struct.pack(<span class="string">"!BH"</span>, <span class="number">126</span>, length)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        token += struct.pack(<span class="string">"!BQ"</span>, <span class="number">127</span>, length)</span><br><span class="line"></span><br><span class="line">    msg = token + msg_bytes</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>WebSocket客户端即我们的浏览器怎么去接收消息呢？接收到消息后会触发ws对象中的onmessage函数的执行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 检验客户端是否接收到消息成功 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8002/xxoo"</span>); <span class="comment">//ws表示的是websocket协议</span></span></span><br><span class="line"><span class="actionscript">    socket.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">1111</span>)  </span></span><br><span class="line"><span class="actionscript">    &#125; <span class="comment">// 如果ws握手成功 就会触发该函数的执行。失败就不会触发</span></span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    socket.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event);   <span class="comment">//event封装了关于消息的一些信息，通过event.data可以拿到数据</span></span></span><br><span class="line"><span class="actionscript">    &#125;<span class="comment">// 如果接收到了服务端发送的数据会出发该函数的执行</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于websocket协议数据包解析的更多内容（如数据头中FIN,opcode的作用）可以参考下面的官方文档：</p>
<blockquote>
<p>The MASK bit simply tells whether the message is encoded. Messages from the client must be masked, so your server should expect this to be 1. (In fact, <a href="http://tools.ietf.org/html/rfc6455#section-5.1" target="_blank" rel="noopener">section 5.1 of the spec</a> says that your server must disconnect from a client if that client sends an unmasked message.) When sending a frame back to the client, do not mask it and do not set the mask bit. We’ll explain masking later. <em>Note: You have to mask messages even when using a secure socket.</em>RSV1-3 can be ignored, they are for extensions.</p>
<p>The opcode field defines how to interpret the payload data: 0x0 for continuation, <code>0x1</code> for text (which is always encoded in UTF-8), <code>0x2</code> for binary, and other so-called “control codes” that will be discussed later. In this version of WebSockets, <code>0x3</code> to <code>0x7</code> and <code>0xB</code> to <code>0xF</code> have no meaning.</p>
<p>The FIN bit tells whether this is the last message in a series. If it’s 0, then the server will keep listening for more parts of the message; otherwise, the server should consider the message delivered. More on this later.</p>
<p><strong>Decoding Payload Length</strong></p>
<p>To read the payload data, you must know when to stop reading. That’s why the payload length is important to know. Unfortunately, this is somewhat complicated. To read it, follow these steps:</p>
<ol>
<li>Read bits 9-15 (inclusive) and interpret that as an unsigned integer. If it’s 125 or less, then that’s the length; you’re <strong>done</strong>. If it’s 126, go to step 2. If it’s 127, go to step 3.</li>
<li>Read the next 16 bits and interpret those as an unsigned integer. You’re <strong>done</strong>.</li>
<li>Read the next 64 bits and interpret those as an unsigned integer (The most significant bit MUST be 0). You’re <strong>done</strong>.</li>
</ol>
<p><strong>Reading and Unmasking the Data</strong></p>
<p>If the MASK bit was set (and it should be, for client-to-server messages), read the next 4 octets (32 bits); this is the masking key. Once the payload length and masking key is decoded, you can go ahead and read that number of bytes from the socket. Let’s call the data <strong>ENCODED</strong>, and the key <strong>MASK</strong>. To get <strong>DECODED</strong>, loop through the octets (bytes a.k.a. characters for text data) of <strong>ENCODED</strong> and XOR the octet with the (i modulo 4)th octet of MASK. In pseudo-code (that happens to be valid JavaScript):</p>
<p>var DECODED = “”;<br>for (var i = 0; i &lt; ENCODED.length; i++) {<br>  DECODED[i] = ENCODED[i] ^ MASK[i % 4];<br>}</p>
<p>Now you can figure out what <strong>DECODED</strong> means depending on your application.</p>
</blockquote>
<h1 id="Tornado实现web群聊"><a href="#Tornado实现web群聊" class="headerlink" title="Tornado实现web群聊"></a>Tornado实现web群聊</h1><p>上面是通过自己通过python写websocket服务端以此来学习和加深对websocket协议内部原理的理解！在实际运用中其实并不用自己去写，像客户端浏览器中的javascript的类库对websocket提供便捷的接口使得我们使用起来十分舒服。在服务端开发中许多web框架都支持websocket，给它封装了十分便捷的接口直接供我们调用！</p>
<p>Tornado是一个支持WebSocket的优秀框架！下面是一个使用Tornado去基于websocket实现web聊天室的例子！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""服务端"""</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.render(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#继承的是websocket.WebSocketHandler，这样才能处理ws请求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatHandler</span><span class="params">(tornado.websocket.WebSocketHandler)</span>:</span></span><br><span class="line">    <span class="comment"># 用于存储当前聊天室用户</span></span><br><span class="line">    waiters = set()</span><br><span class="line">    <span class="comment"># 用于存储历时消息</span></span><br><span class="line">    messages = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        客户端与服务端已经完成Ws握手</span></span><br><span class="line"><span class="string">        客户端连接成功时，自动执行</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#self里面就封装了创建的对象，每个用户来连接都要把他们的socket保存到waiters列表中才能找得到每个用户的socket去sent</span></span><br><span class="line">        ChatHandler.waiters.add(self) </span><br><span class="line">     </span><br><span class="line">        uid = str(uuid.uuid4())</span><br><span class="line">        self.write_message(uid) <span class="comment">#给客户端发数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> msg <span class="keyword">in</span> ChatHandler.messages:</span><br><span class="line">            content = self.render_string(<span class="string">'message.html'</span>, **msg)</span><br><span class="line">            self.write_message(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        客户端连发送消息时，自动执行</span></span><br><span class="line"><span class="string">        有一个人（客户端）发消息，就要给群聊中的所有用户发消息</span></span><br><span class="line"><span class="string">        write_message()是给客户端发送的数据 </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        msg = json.loads(message)</span><br><span class="line">        ChatHandler.messages.append(message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> ChatHandler.waiters:</span><br><span class="line">            <span class="comment">#给聊天室的每一个用户发消息</span></span><br><span class="line">            <span class="comment">#render会直接sent过去，我们是要通过websocket去sent的所以使用render_string表示的是只是拿到渲染模板引擎后的字符串再write_message过去，这样实现了给前端添加html标签了！</span></span><br><span class="line">            content = client.render_string(<span class="string">'message.html'</span>, **msg)</span><br><span class="line">            client.write_message(content) <span class="comment">#给客户端发数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        客户端关闭连接时，，自动执行</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ChatHandler.waiters.remove(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    settings = &#123;</span><br><span class="line">        <span class="string">'template_path'</span>: <span class="string">'templates'</span>,</span><br><span class="line">        <span class="string">'static_path'</span>: <span class="string">'static'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    application = tornado.web.Application([</span><br><span class="line">        (<span class="string">r"/"</span>, IndexHandler),</span><br><span class="line">        (<span class="string">r"/chat"</span>, ChatHandler),</span><br><span class="line">    ], **settings)</span><br><span class="line">    application.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>websocket聊天室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"提交"</span> <span class="attr">onclick</span>=<span class="string">"sendMsg();"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"close"</span> <span class="attr">value</span>=<span class="string">"关闭连接"</span> <span class="attr">onclick</span>=<span class="string">"closeConn();"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid #dddddd;margin: 20px;min-height: 500px;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/jquery-2.1.4.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            wsUpdater.start();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> wsUpdater = &#123;</span></span><br><span class="line"><span class="actionscript">            socket: <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">            uid: <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">            start: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> url = <span class="string">"ws://127.0.0.1:8888/chat"</span>;</span></span><br><span class="line"><span class="actionscript">                wsUpdater.socket = <span class="keyword">new</span> WebSocket(url);</span></span><br><span class="line"><span class="actionscript">                wsUpdater.socket.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(event);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">if</span>(wsUpdater.uid)&#123;</span></span><br><span class="line">                        wsUpdater.showMessage(event.data);</span><br><span class="line"><span class="actionscript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">                        wsUpdater.uid = event.data;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            showMessage: <span class="function"><span class="keyword">function</span><span class="params">(content)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                $(<span class="string">'#container'</span>).append(content);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> msg = &#123;</span></span><br><span class="line">                uid: wsUpdater.uid,</span><br><span class="line"><span class="javascript">                message: $(<span class="string">"#txt"</span>).val()</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="javascript">            wsUpdater.socket.send(<span class="built_in">JSON</span>.stringify(msg));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上是个人学习之路，如有误，欢迎指正！<a href="https://www.cnblogs.com/wupeiqi/articles/6558766.html" target="_blank" rel="noopener">参考文献</a></p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python    </a><a class="post-meta__tags" href="/tags/Tornado/">Tornado    </a><a class="post-meta__tags" href="/tags/Websocket/">Websocket    </a></div><div class="post_share"><div class="social-share" data-image="/img/cover_default2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/11/19/Tornado%E6%A1%86%E6%9E%B6%E8%BF%9B%E9%98%B6/"><img class="prev_cover lozad" data-src="/img/tornado_cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Tornado框架进阶</span></div></a></div><div class="next-post pull-right"><a href="/2019/11/16/Tornado%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"><img class="next_cover lozad" data-src="/img/tornado_cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Tornado框架入门</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/19/Tornado框架进阶/" title="Tornado框架进阶"><img class="relatedPosts_cover lozad"data-src="/img/tornado_cover.jpg"><div class="relatedPosts_title">Tornado框架进阶</div></a></div><div class="relatedPosts_item"><a href="/2019/11/16/Tornado框架入门/" title="Tornado框架入门"><img class="relatedPosts_cover lozad"data-src="/img/tornado_cover.jpg"><div class="relatedPosts_title">Tornado框架入门</div></a></div><div class="relatedPosts_item"><a href="/2019/11/21/Celery/" title="Celery"><img class="relatedPosts_cover lozad"data-src="/img/cover_default3.jpg"><div class="relatedPosts_title">Celery</div></a></div><div class="relatedPosts_item"><a href="/2019/11/21/缓存数据库Redis/" title="缓存数据库Redis"><img class="relatedPosts_cover lozad"data-src="/img/cover_default3.jpg"><div class="relatedPosts_title">缓存数据库Redis</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzI1MC8yMzc1MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer style="background-image: url(/img/cover_default2.jpg)"><div id="footer"><div class="copyright">&copy;2019 - 2020 By Rhubarb C</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script color="0,0,255" opacity="0.7" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>