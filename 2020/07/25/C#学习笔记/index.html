<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>C#学习笔记 | RhubarbC的博客</title><meta name="description" content="C#学习笔记"><meta name="keywords" content=""><meta name="author" content="Rhubarb C"><meta name="copyright" content="Rhubarb C"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="C#学习笔记"><meta name="twitter:description" content="C#学习笔记"><meta name="twitter:image" content="http://yoursite.com/img/cover_default3.jpg"><meta property="og:type" content="article"><meta property="og:title" content="C#学习笔记"><meta property="og:url" content="http://yoursite.com/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="RhubarbC的博客"><meta property="og:description" content="C#学习笔记"><meta property="og:image" content="http://yoursite.com/img/cover_default3.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="CPP中构造函数的分类以及调用(容易出错)" href="http://yoursite.com/2020/05/04/CPP%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%B0%83%E7%94%A8-%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://deehuang.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: Rhubarb C","link":"链接: http://yoursite.com/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","source":"来源: RhubarbC的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">RhubarbC的博客</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#接口和抽象类"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">接口和抽象类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#抽象类"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">抽象类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#未做基类而生的”抽象类“与开放-关闭原则"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">未做基类而生的”抽象类“与开放/关闭原则</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#接口"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">接口</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#依赖和耦合"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">依赖和耦合</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#依赖反转"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">依赖反转</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#反射与依赖注入"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">反射与依赖注入</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#接口的显式实现"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">接口的显式实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#反射"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">反射</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#依赖注入"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">依赖注入</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#接口和抽象类"><span class="toc-number">1.</span> <span class="toc-text">接口和抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象类"><span class="toc-number">1.1.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#未做基类而生的”抽象类“与开放-关闭原则"><span class="toc-number">1.1.1.</span> <span class="toc-text">未做基类而生的”抽象类“与开放/关闭原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">1.2.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖和耦合"><span class="toc-number">1.2.1.</span> <span class="toc-text">依赖和耦合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖反转"><span class="toc-number">1.3.</span> <span class="toc-text">依赖反转</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反射与依赖注入"><span class="toc-number">2.</span> <span class="toc-text">反射与依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口的显式实现"><span class="toc-number">2.1.</span> <span class="toc-text">接口的显式实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-number">2.2.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖注入"><span class="toc-number">2.3.</span> <span class="toc-text">依赖注入</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/cover_default3.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">C#学习笔记</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-25<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-27</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><blockquote>
<p>“学习编程的重点不是学，而是用!“，多敲代码，勿忘初心，最近在看刘铁锰老师的<a href="https://www.bilibili.com/video/BV13b411b7Ht?p=27" target="_blank" rel="noopener">C#语言入门详解</a>，感觉质量确实是高，本篇学习笔记也是基于老师的讲解做的一些个人学习纪录和心得。</p>
</blockquote>
<h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><p><img alt="image-20200725181138731" data-src="/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cimage-20200725181138731.png" class="lozad"></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="未做基类而生的”抽象类“与开放-关闭原则"><a href="#未做基类而生的”抽象类“与开放-关闭原则" class="headerlink" title="未做基类而生的”抽象类“与开放/关闭原则"></a>未做基类而生的”抽象类“与开放/关闭原则</h3><p>所谓原则，就是在编程过程中需要遵守的准则，这是为了在团队高校协作和日后的可拓展性可维护性着想所设定的一系列编程规范</p>
<p>下面通过代码看一下什么是抽象类:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">namespace 抽象类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//抽象类指的是函数成员没有完全被实现的类：</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个抽象类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Study</span>(<span class="params"></span>)</span>; <span class="comment">//不能是private 子类都没法访问怎么去实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>ps：</em></p>
<ul>
<li><em>抽象类（也被称为抽象类中的抽象方法也叫纯虚方法）不能被实例化，它就是为被继承而生的</em></li>
<li>抽象成员必须是函数成员（方法，属性，索引器，事件等等）</li>
<li>派生自抽象类的子类必须实现抽象类中的抽象方法</li>
<li>继承至抽象类的子类，除非自己也是抽象类，否则必须实现抽象类的抽象方法</li>
</ul>
<p>从上面的例子和ps中可以看出，抽象类就是为做基类而生的，它唯一能做的事情就是作为基类类型去声明变量，引用那些完全实现它抽象成员的那些子类类型的实例然后玩<strong>”多态“</strong>的骚操作</p>
<p><strong>开闭原则：</strong></p>
<p><strong>封装确定的，开放不确定的，推迟到合适的子类去实现，这就是我们的开闭原则</strong></p>
<ul>
<li>该原则简单理解就是没事别随便去修改已经写好的代码（除了修改bug和添加新成员新方法除外，这里主要指的的逻辑，比如一些<code>If else</code>语句，日后有新功能实现又要在上面加<code>elseif</code>？？？未免太Low）</li>
<li>为了实现这样的原则，我们应该封装一些不变的、稳定的、固定和确定的成员，而把那些不确定的，有可能改变的成员声明为抽象成员并留给子类去实现</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">namespace 抽象类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//抽象类指的是函数成员没有完全被实现的类：</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IVechicleBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Stop</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Fill</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">string</span> CarType</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Vehicle</span>: <span class="title">VechicleBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Stopped!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fill</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Pay and fill"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//不实现接口的话就只能定义为抽象方法下放给子类去实现了 注意:有了抽象方法的类必须是一个抽象类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">string</span> carType</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">string</span> carType</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"<span class="subst">&#123;carType&#125;</span> is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Truck</span> : <span class="title">Vehicle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">string</span> carType</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"<span class="subst">&#123;carType&#125;</span> is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：上面的例子可以看出，抽象类是可以定义抽象方法，也可以定义实例成员，类成员等正常的类成员的，但是我们经常会有需求要设计了一个抽象类中的成员全是抽象（纯虚类）。这其实很常见，那就引入了另外一个语言为我们准备好的更加抽象的概念：接口（接口就是完全未实现逻辑的类，而抽象类是未完全实现逻辑的类）！</p>
<p>可以看出，语言的设计是越来越抽象化的，这是为了让软件工程化，好维护好测试。<br>抽象程度：类 &lt; 抽象类 &lt; 接口/纯虚类</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>从上面我们可以知道，接口是由抽象方法演变而来的，对于接口有几个需要注意的地方：</p>
<ul>
<li><p>接口中的成员都是<strong>public</strong></p>
</li>
<li><p>接口本质就是服务的调用者或者说是服务的消费者与服务的提供者之间的一种”契约“，既然是契约，那里面的东西对双方应该都是透明可见的，所以有了上面的规定（public修饰接口中的所有成员）</p>
</li>
<li><p>契约也称协议、合同，是一种约束。<br>在约束的保障下，使得自由合作成为可能（所谓“自由合作”就是指服务的提供者（实现了契约的类）和服务的消费者（在内部调用另外的类中的方法的类）在一种约束（接口）下，可以自由的组合自己想做的事情（不同的类型都可以调用同一个方法，只需要双方都遵守了一种契约即可））。<br>如<code>Array</code>类型即我们常见的<code>int[]</code>这种数组类型，实现了<code>IEnumerable</code>这个接口，<code>ArrayList</code>也是如此（提供方遵守了<code>IEnumerable</code>契约），所以如果有一个方法要求只需要传进来的类型可以被迭代即可的需求，那么这两种类型就都可以传入方法参数中，只要参数类型定义为<code>IEnumerable</code>接口类型即可（这里就是需求方遵守<code>IEnumerable</code>契约），这就实现了“自由合作组合。”</p>
</li>
<li><p>可能看到这里仍然对自由组合还有点云里雾里的感觉，可以简单认为，接口约束了一组功能，这组功能的调用者是被约束的（只能调用接口里所包含的功能，接口里没有包含的功能你看不见你也调用不了），而且能确保调用者放心的去调用这些功能（因为一定是实现好的），不用担心是”谁”把功能提供给你的。所以自由组合就是随便的把”谁”给到调用者都可以，而这个“谁”就是实现了接口的对象。</p>
</li>
</ul>
<h3 id="依赖和耦合"><a href="#依赖和耦合" class="headerlink" title="依赖和耦合"></a>依赖和耦合</h3><p> 一个类（服务的消费者）里面引用了别的类型（服务的提供者），我们就说这个类<strong>依赖</strong>在了引用的类型上面，一个类完全依赖于另一个类上，我们就说它们是紧耦合的。紧耦合出现的问题是，如果被依赖的这个类出现问题，那么依赖的类就很难发现这个问题（因为逻辑问题程序一般不会报错）</p>
<p>看下面的例子</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> engine = <span class="keyword">new</span> Engine();</span><br><span class="line">            <span class="keyword">var</span> car = <span class="keyword">new</span> Car(engine);</span><br><span class="line">            car.Run(<span class="number">3</span>);</span><br><span class="line">            Console.WriteLine(car.Speed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Engine</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> RPM &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Work</span>(<span class="params"><span class="keyword">int</span> gas</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//            this.RPM = 1000 * gas;</span></span><br><span class="line">            <span class="comment">//如果我这边逻辑是0， 模拟出问题的情况，那么外部获得结果就会很迷茫（不报错），只能通过一步步调试发现问题</span></span><br><span class="line">            <span class="keyword">this</span>.RPM = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Car依赖于Engine</span></span><br><span class="line">        <span class="keyword">private</span> Engine _engine; <span class="comment">//这就是紧耦合的</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params">Engine engine</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>._engine = engine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Speed &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">int</span> gas</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _engine.Work(gas);</span><br><span class="line">            <span class="keyword">this</span>.Speed = _engine.RPM / <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在开发中我们要尽量避免紧耦合的问题，为了避免这样的问题，我们需要引入接口。</p>
<p>从下面的示例能更加清晰地理解接口的解耦和作用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//在这里我们只需要换个实现了接口的类对象（遵守了契约的功能提供者），都可以实现我们想要的功能</span></span><br><span class="line">            <span class="keyword">var</span> user = <span class="keyword">new</span> PhoneUser(<span class="keyword">new</span> ApplePhone());</span><br><span class="line">            user.UsePhone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">PhoneUser</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//依赖的不是某一个特定的对象上了，而是一组遵守了契约的提供者们 实现了解耦！</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IPhone _phone;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PhoneUser</span>(<span class="params">IPhone phone</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _phone = phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UsePhone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _phone.Dail();</span><br><span class="line">            _phone.PickUp();</span><br><span class="line">            _phone.Send();</span><br><span class="line">            _phone.Receive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//契约</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IPhone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Dail</span>(<span class="params"></span>)</span>; <span class="comment">// 打电话</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">PickUp</span>(<span class="params"></span>)</span>; <span class="comment">// 接电话</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Send</span>(<span class="params"></span>)</span>; <span class="comment">// 发短信</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Receive</span>(<span class="params"></span>)</span>; <span class="comment">// 收短信</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务的提供者</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ApplePhone</span> : <span class="title">IPhone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dail</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Apple calling"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PickUp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello! This is Jock! --- from Phone"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Apple message ring"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"good morning! --- from message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务的提供者</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">HuaWeiPhone</span> : <span class="title">IPhone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dail</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"HuaWeiPhone calling"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PickUp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello! This is Jock! --- from Phone"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"HuaWeiPhone message ring"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"good evening! --- from message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：接口的存在可以让“<strong>功能的提供方</strong>”变得可替换，降低了紧耦合的时候，功能的提供方（某个类）不可被替换的高风险高成本</p>
<h2 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h2><p>当我们面对一个问题的时候，我们正常的思维是把大问题化解为若干位中问题或者小问题，中问题不能被解决的时候要分解为小问题，直到这些小问题可以被直接解决（自顶向下，逐步求精的思维方式），这样的解决问题的方式会导致，大问题的解决需要依赖于它分解出来的所有中问题和小问题的解决。<br><img alt="image-20200726164322709" data-src="/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726164322709.png" class="lozad"></p>
<p>依赖反转原则就是给我们一种新的思路，用来平衡上面这种自顶向下，逐步求精的思维方式（注意，这是用来平衡这种思维方式，并非完全否定这种思维方式，有时候这种方式挺好用的）。 </p>
<p>依赖反转这四个字，相信通过前面的学习，对于依赖的意思已经不会陌生了，那么反转指的是什么呢？</p>
<p>这个反转实际上就是在上面使用接口松耦合的例子中用到的方式，让某个类不是依赖在某个类上，而是依赖某个接口上，实现类型间的解耦。<br><img alt="image-20200726165223903" data-src="/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726165223903.png" class="lozad"></p>
<p>如图中所示，按正常思维自顶向下的思维方式，我们设计司机，卡车司机，和赛车手的时候都会让他们依赖在自己的某种类型的车上，要是有一天司机想要开卡车、赛车怎么办？只能去里面去里面改类型了（这严重违反了我们的开闭原则），我们可以巧妙地利用之前说到的接口松耦的方式，如图中右边所示，让司机依赖于某个接口（而不是特定的类型），然后让各种类型的车去实现这个接口，那么哪天司机想开什么车，我们只需要在外部传入不同类型的车给它就O了，而不用去修改内部的逻辑。<br>说到现在，可能会有疑惑?我们不是讲反转吗，怎么扯东扯西的，反转是什么？其实从图中已经可以看出来，自定向下的解决问题的方式我们的依赖关系的箭头都是向下的，改成类接口松耦合的方式后，箭头方向就变成了从下往上指了，这个就是所谓的<strong>反转</strong>！这就是依赖反转名字的由来，反转的就是箭头的方向，所以大家理解的时候不要去死扣字眼理解了，看这个图应该能理解出那层抽象概念，本身这块知识领域就是抽象的。</p>
<p>所以当类实现一个接口的时候，类与接口之间的关系事实上也是“紧耦合”。所以就会导致箭头反转了。通过接口，让类与类之间不直接的紧耦合在一起！</p>
<h1 id="反射与依赖注入"><a href="#反射与依赖注入" class="headerlink" title="反射与依赖注入"></a>反射与依赖注入</h1><p>设计原则中的S（单一职责原则）规定，一个类只做一件事，所以实现的接口不要有不相干的功能</p>
<p>设计原则中的I（接口隔离原则）规定，服务调用者不会多要服务（把胖接口拆分开来，分成多个小接口，每个小接口都描述一个单一的功能。或者接口隔离的本质是不同的功能给隔离开，再用接口把 它们封装起来，这就是接口隔离的由来）</p>
<p>单一职责和接口隔离事实上说的是一件事情， 只不过一个站在的是服务的提供者的角度来看这个接口的设计，另一个是站在服务调用者的角度去看这个接口类型</p>
<p>一个接口可以继承多个接口，然后我们在服务的调用者中引用所需服务的那个接口，那么即使传入的是实现了大接口的类，那么也只能调用到小接口的服务。这就实现了接口隔离（服务调用者不会多调服务）</p>
<p>实现接口隔离其实就是为了让调用者<strong>用不到</strong>，或者说是<strong>看不到</strong>没用的服务，C#给我们提供了独有的语法实现了<strong>看不到</strong>的隔离，那就是接口的显式实现（默认全都都暴露的实现方式就是隐式）：</p>
<h2 id="接口的显式实现"><a href="#接口的显式实现" class="headerlink" title="接口的显式实现"></a>接口的显式实现</h2><ul>
<li>显式实现<br><img alt="image-20200726224038710" data-src="/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726224038710.png" class="lozad"><br>只有我们拿一个<code>IKiller</code>类型的变量来引用<code>WarmKiller</code>类的实例的时候，这个方法才能被调用<br><img alt="image-20200726224327069" data-src="/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726224327069.png" class="lozad"></li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射其实不是C#的功能，它是属于.net 平台的功能。</p>
<p>反射就是<strong>动态</strong>的去内存里面拿到对象与它绑定类型的描述，然后再根据这些描述去创建新的对象。</p>
<p>下面直接用上面用到的例子来看实例了解反射的使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//在这里我们只需要换个实现了接口的类对象（遵守了契约的功能提供者），都可以实现我们想要的功能</span></span><br><span class="line">            <span class="keyword">var</span> user = <span class="keyword">new</span> PhoneUser(<span class="keyword">new</span> ApplePhone());</span><br><span class="line">            user.UsePhone();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//============分割线==============</span></span><br><span class="line">            <span class="keyword">var</span> t = user.GetType();<span class="comment">//拿到当前对象的描述信息</span></span><br><span class="line">            <span class="comment">//根据描述信息去创建对象 通过Activator激活器创建对象</span></span><br><span class="line">            <span class="keyword">object</span> o = Activator.CreateInstance(t);</span><br><span class="line">            MethodInfo DailFun = t.GetMethod(<span class="string">"Dail"</span>);</span><br><span class="line">            MethodInfo SentFun = t.GetMethod(<span class="string">"Sent"</span>);</span><br><span class="line">            <span class="comment">//注意要在某个类型上去使用方法，所以方法的调用的时候是需要去传入对象实例的，上面只是获取了对象中方法的描述信息</span></span><br><span class="line">            DailFun.Invoke(o,<span class="literal">null</span>); <span class="comment">//第一个参数表在哪个对象跑方法，后面的参数都是需要传入方法的参数，没有就null</span></span><br><span class="line">            SentFun.Invoke(o, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//上面创建实例和调用方法的过程中，我们都完全没有去调用静态类型或者方法（类名或者方法名）</span></span><br><span class="line">            <span class="comment">//都是通过内存里动态的读出类型的描述和方法的描述（metadata）去调用</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">PhoneUser</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//依赖的不是某一个特定的对象上了，而是一组遵守了契约的提供者们 实现了解耦！</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IPhone _phone;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PhoneUser</span>(<span class="params">IPhone phone</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _phone = phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UsePhone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _phone.Dail();</span><br><span class="line">            _phone.PickUp();</span><br><span class="line">            _phone.Send();</span><br><span class="line">            _phone.Receive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//契约</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IPhone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Dail</span>(<span class="params"></span>)</span>; <span class="comment">// 打电话</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">PickUp</span>(<span class="params"></span>)</span>; <span class="comment">// 接电话</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Send</span>(<span class="params"></span>)</span>; <span class="comment">// 发短信</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Receive</span>(<span class="params"></span>)</span>; <span class="comment">// 收短信</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务的提供者</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ApplePhone</span> : <span class="title">IPhone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dail</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Apple calling"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PickUp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello! This is Jock! --- from Phone"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Apple message ring"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"good morning! --- from message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务的提供者</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">HuaWeiPhone</span> : <span class="title">IPhone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dail</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"HuaWeiPhone calling"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PickUp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello! This is Jock! --- from Phone"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"HuaWeiPhone message ring"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"good evening! --- from message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>大部分时间我们不会自己去写上面的原始的反射实现方式，都是用的是框架内继承的反射功能，其中最著名的就是我们的依赖注入功能（DI）</p>
<p>上面我们有说到依赖反转（dependency inversion）也是DI，其实这是一个概念的东西，而依赖注入是基于这个概念上，结合接口和反射机制诞生出来一种应用，很多人会混淆之间的关系。</p>
<p>依赖注入有个很重要的东西叫做“容器”，我们把各种各样的类型和它们的接口放到对应的容器（SericeCollection）里面去（这一部叫做注册服务），然后我们要实例的时候，就向容器说你给我个实例就可以了。值得注意的是：在注册服务的时候，我们创建对象的时候，是要一次就创建一个新对象还是创建一个单例模式。</p>
<p><img alt="image-20200726232332199" data-src="/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726232332199.png" class="lozad"></p>
<p>使用容器的好处就是，日后我如果想要更新类型，不用<code>HeavyTank</code>了，而是用其他市县了<code>ITank</code>的类型，我不用去所有用到该类型的一个一个地方去改代码（改那些new 类型出来的地方），只需要在容器里修改注册的类型就行了，例如：<br><img alt="image-20200726232624686" data-src="/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726232624686.png" class="lozad"><br>看到这里，是不是很想说一句：妙啊！</p>
<p>你以为DI容器只有那么点功能吗？远远不止<br>如果一个类型有依赖关系（无论是依赖在某一类型还是某个接口上，都属于依赖），只要把依赖的类型/接口注册到容器，并且把这个类型也注册到容器中，那么我们在向容器要服务的时候，容器会自动的帮我们创造出需要的实例注入依赖对象。秒啊！</p>
<p><img alt="image-20200726233322978" data-src="/2020/07/25/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200726233322978.png" class="lozad"></p>
<p>所以所谓依赖注入，就是把注册到容器中的类型创建实例给注入到有依赖关系的构造器里面去。</p>
<p>我们经常看到所谓的API，其实API里面不一定都是接口，它有可能是一组函数，一组类，一组接口。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/cover_default3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/05/04/CPP%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%B0%83%E7%94%A8-%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99/"><img class="next_cover lozad" data-src="/img/cover_default3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>CPP中构造函数的分类以及调用(容易出错)</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NzI1MC8yMzc1MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><footer style="background-image: url(/img/cover_default3.jpg)"><div id="footer"><div class="copyright">&copy;2019 - 2020 By Rhubarb C</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script color="0,0,255" opacity="0.7" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>